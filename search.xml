<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Leetcode-415.字符串相加</title>
    <url>/2019/08/31/leetcode/415.zi-fu-chuan-xiang-jia/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。</p>
<p>注意：</p>
<p>num1 和num2 的长度都小于 5100.<br>num1 和num2 都只包含数字 0-9.<br>num1 和num2 都不包含任何前导零。<br>你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式。</p>
<span id="more"></span>

<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/add-strings">https://leetcode-cn.com/problems/add-strings</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h4><p>解题思路：模拟竖式加法</p>
<p>1.设定i，j分别指向nums1，nums2的尾部，模拟人工加法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">addStrings</span><span class="params">(string num1, string num2)</span> </span>&#123;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i=num1.<span class="built_in">size</span>()<span class="number">-1</span>,j=num2.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="keyword">int</span> sum;</span><br><span class="line">        <span class="keyword">char</span> ch;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>&amp;&amp;j&gt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            a=num1[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            b=num2[j]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            </span><br><span class="line">            sum=a+b+k;</span><br><span class="line">            <span class="keyword">if</span>(sum&gt;<span class="number">9</span>)</span><br><span class="line">                k=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                k=<span class="number">0</span>;</span><br><span class="line">            sum%=<span class="number">10</span>;</span><br><span class="line">            ch=sum+<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            res+=ch;</span><br><span class="line">            i--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            a=num1[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            sum=a+k;</span><br><span class="line">            <span class="keyword">if</span>(sum&gt;<span class="number">9</span>)</span><br><span class="line">                k=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                k=<span class="number">0</span>;</span><br><span class="line">            sum%=<span class="number">10</span>;</span><br><span class="line">            ch=sum+<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            res+=ch;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            b=num2[j]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            sum=b+k;</span><br><span class="line">            <span class="keyword">if</span>(sum&gt;<span class="number">9</span>)</span><br><span class="line">                k=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                k=<span class="number">0</span>;</span><br><span class="line">            sum%=<span class="number">10</span>;</span><br><span class="line">            ch=sum+<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            res+=ch;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">1</span>)</span><br><span class="line">            res+=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Leetcode</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-792.匹配子序列的单词数</title>
    <url>/2019/08/28/leetcode/792.pi-pei-zi-xu-lie-de-dan-ci-shu/</url>
    <content><![CDATA[<p>给定字符串 S 和单词字典 words, 求 words[i] 中是 S 的子序列的单词个数。</p>
<p>示例:<br>输入:<br>S = “abcde”<br>words = [“a”, “bb”, “acd”, “ace”]<br>输出: 3<br>解释: 有三个是 S 的子序列的单词: “a”, “acd”, “ace”。<br>注意:</p>
<p>所有在words和 S 里的单词都只由小写字母组成。<br>S 的长度在 [1, 50000]。<br>words 的长度在 [1, 5000]。<br>words[i]的长度在[1, 50]。</p>
<span id="more"></span>

<h4 id="解法1：Map"><a href="#解法1：Map" class="headerlink" title="解法1：Map"></a>解法1：Map</h4><p>解题思路</p>
<p>​    1.根据words数组每个字符串的首字母将其在数组内的索引值存入到首字母对应的map中，例如words[3]=”bacc” 则 map[‘b’]=[3];（map类型为&lt;char,vector<int>&gt;）</p>
<p>​    2.遍历S数组，若当前位置的字符在map中有值，将其map的值提出赋值给t数组，并将原来map值清空</p>
<p>​    3.构建wordnum数组，用来存当前情况下，各个words已经匹配到的字符数。遍历t数组，提出每个索引，判断该索引words单词是否已经匹配完全，若未完全，根据其下一个字符放入对应map中</p>
<p>​    4.遍历wordnum数组，若wordnum[i]&gt;=words[i].size()表示该单词匹配成功，res+1</p>
<p>​    5.返回res</p>
<p>改进：</p>
<p>​    1.发现其中有很多重复单词，利用map统计各个不同单词出现的次数，将没有重复单词的字符串赋值给words</p>
<p>更新新的words个数</p>
<p>​    2.统计res时，根据该单词出现的次数更新</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numMatchingSubseq</span><span class="params">(string S, vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> wordlen=words.<span class="built_in">size</span>();</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>,vector&lt;<span class="keyword">int</span>&gt;&gt; m;</span><br><span class="line">        unordered_map&lt;string,<span class="keyword">int</span>&gt; mset;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;wordlen;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            mset[words[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> iter = mset.<span class="built_in">begin</span>(); iter != mset.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">        &#123;</span><br><span class="line">            words[i]=iter-&gt;first;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        wordlen=i;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">wordnum</span><span class="params">(wordlen,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;wordlen;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            m[words[i][<span class="number">0</span>]].<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;S.<span class="built_in">length</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">t</span><span class="params">(m[S[i]])</span></span>;</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            m[S[i]].<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;t.<span class="built_in">size</span>();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> k=t[j];</span><br><span class="line">                wordnum[k]++;</span><br><span class="line">                <span class="keyword">if</span>(wordnum[k]&lt;words[k].<span class="built_in">size</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    m[words[k][wordnum[k]]].<span class="built_in">push_back</span>(k);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;wordlen;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(wordnum[i]&gt;=words[i].<span class="built_in">size</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                res+=mset[words[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Leetcode</tag>
        <tag>map</tag>
      </tags>
  </entry>
  <entry>
    <title>读书笔记|图解机器学习算法</title>
    <url>/2021/10/15/dian-zi-shu-yi-ji-bi-ji/tu-jie-ji-qi-xue-xi/</url>
    <content><![CDATA[<h1 id="图解机器学习算法"><a href="#图解机器学习算法" class="headerlink" title="图解机器学习算法"></a>图解机器学习算法</h1><p>作者：秋庭伸也</p>
<p>Python:3.7</p>
<p>scikit-learn:0.20.3</p>
<p>机器学习</p>
<ul>
<li>有监督学习<ul>
<li>分类(二元分类、多元分类）：逻辑回归， 支持向量机 ，支持向量机（核方法），朴素贝叶斯，随机森林，神经网络，KNN</li>
<li>回归：线性回归，正则化，支持向量机，支持向量机（核方法），随机森林，神经网络，KNN</li>
</ul>
</li>
<li>无监督学习<ul>
<li>降维：PCA、LSA、NMF、LDA、LLE、t-SNE</li>
<li>聚类：k-means、混合高斯模型</li>
</ul>
</li>
<li>强化学习</li>
</ul>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h5 id="图型绘制"><a href="#图型绘制" class="headerlink" title="图型绘制"></a>图型绘制</h5><p>散点图：scatter</p>
<p>直方图：hist</p>
<p>柱状图：bar</p>
<p>折线图：plot</p>
<p>箱型图：boxplot</p>
<h5 id="pandas"><a href="#pandas" class="headerlink" title="pandas"></a>pandas</h5><p>相关系数：corr</p>
<p>统计信息：describe</p>
<p>散点图矩阵：scatter_matrix</p>
<h2 id="有监督学习"><a href="#有监督学习" class="headerlink" title="有监督学习"></a>有监督学习</h2><h3 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h3><p>一元回归：y = w<del>0</del>+w<del>1</del>*x<del>1</del></p>
<p>多元回归：y = w<del>0</del>+w<del>1</del>*x<del>1</del>+w<del>2</del>*x<del>2</del></p>
<p>多项式回归：y = w<del>0</del>+w<del>1</del>*x<del>1</del>+w<del>2</del>*x^2^<del>1</del></p>
<h3 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h3><p>超参数α</p>
<p>岭回归Ridge</p>
<p>Lasso回归</p>
<h3 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h3><p>二分类sigmoid</p>
<p>多分类softmax</p>
<p>np.r_</p>
<p>np.random.normal</p>
<p>model.predict_proba</p>
<h3 id="支持向量机"><a href="#支持向量机" class="headerlink" title="支持向量机"></a>支持向量机</h3><p>间隔最大化</p>
<p>线性支持向量机：处理二分类</p>
<p>软间隔，超参数</p>
<p>支持向量：间隔内侧、间隔上 数据</p>
<p>网格搜索，随即搜索</p>
<p>make_blobs</p>
<h3 id="支持向量机（核方法）SVC"><a href="#支持向量机（核方法）SVC" class="headerlink" title="支持向量机（核方法）SVC"></a>支持向量机（核方法）SVC</h3><p>高维空间使用支持向量机学习决策边界 ，然后投影到原始特征形成的向量空间上，得到决策边界</p>
<p>通过核函数，核方法可以使用在高维空间中学习到的决策边界，无需构建具体的线性分离的高维空间。</p>
<p>不宜直接使用非线性核函数，应先使用线性核函数进行分析，以了解数据。</p>
<h3 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h3><p>常用于自然语言分类问题</p>
<p>BoW（Bag of Words）词袋  </p>
<p>计算两种概率：</p>
<p>1.每个标签出现的概率</p>
<p>2.在各标签下，每个单词出现的条件概率</p>
<p>平滑：在没有出现单词的位置也分配小的概率值</p>
<h3 id="随机森林"><a href="#随机森林" class="headerlink" title="随机森林"></a>随机森林</h3><h5 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h5><p>不纯度，基尼指数，加权平均基尼指数</p>
<p>1.计算某个区域的所有特征值和候选分割的不纯度</p>
<p>2.以分割时不纯度减少最多的分割方式分割区域</p>
<p>3.对于分割后的区域重复1，2步骤</p>
<h5 id="随机森林-1"><a href="#随机森林-1" class="headerlink" title="随机森林"></a>随机森林</h5><p>Bootstrap方法以及随机选取特征值方法</p>
<h5 id="特征重要度"><a href="#特征重要度" class="headerlink" title="特征重要度"></a>特征重要度</h5><p>对随机森林的所有决策树求在以某个特征分割时的不纯度并取平均值</p>
<h3 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h3><p>输入层，中间层，输出层</p>
<h5 id="简单感知机"><a href="#简单感知机" class="headerlink" title="简单感知机"></a>简单感知机</h5><h5 id="Early-Stopping"><a href="#Early-Stopping" class="headerlink" title="Early Stopping"></a>Early Stopping</h5><p>早停法 防止过拟合</p>
<h3 id="KNN（K近邻）"><a href="#KNN（K近邻）" class="headerlink" title="KNN（K近邻）"></a>KNN（K近邻）</h3><p>1.计算输入数据与训练数据之间的距离。</p>
<p>2.得到距离输入数据最近的k个训练数据。</p>
<p>3.对训练数据的标签进行多数表决，将结果作为分类结果。</p>
<p>数据量小，维度小 适合</p>
<h2 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h2><h3 id="PCA主成分分析"><a href="#PCA主成分分析" class="headerlink" title="PCA主成分分析"></a>PCA主成分分析</h3><p>具有相关性的数据</p>
<p>PCA的工作就是从原始的空间中顺序地找一组相互正交的坐标轴，新的坐标轴的选择与数据本身是密切相关的。</p>
<p>其中，第一个新坐标轴选择是原始数据中方差最大的方向，第二个新坐标轴选取是与第一个坐标轴正交的平面中使得方差最大的，第三个轴是与第1,2个轴正交的平面中方差最大的。依次类推，可以得到n个这样的坐标轴。</p>
<p>思考：我们如何得到这些包含最大差异性的主成分方向呢？</p>
<p>答案：事实上，通过计算数据矩阵的协方差矩阵，然后得到协方差矩阵的特征值特征向量，选择特征值最大(即方差最大)的k个特征所对应的特征向量组成的矩阵。这样就可以将数据矩阵转换到新的空间当中，实现数据特征的降维。</p>
<p>由于得到协方差矩阵的特征值特征向量有两种方法：特征值分解协方差矩阵、奇异值分解协方差矩阵，所以PCA算法有两种实现方法：基于特征值分解协方差矩阵实现PCA算法、基于SVD分解协方差矩阵实现PCA算法。</p>
<p>降维是指在保留数据特征的前提下，以少量的变量表示有许多变量的数据，有助于降低多变量数据分析的复杂度。</p>
<p>用低维变量表示高维空间的数据，低维的轴叫做主成分。</p>
<h5 id="方向"><a href="#方向" class="headerlink" title="方向"></a>方向</h5><p>由构成新变量时对象数据变量的权重决定</p>
<h5 id="重要度"><a href="#重要度" class="headerlink" title="重要度"></a>重要度</h5><p>与变量偏差有关</p>
<h5 id="主成分得分"><a href="#主成分得分" class="headerlink" title="主成分得分"></a>主成分得分</h5><p>第一主成分，第二主成分</p>
<h5 id=""><a href="#" class="headerlink" title=""></a></h5><p>1.计算协方差矩阵</p>
<p>2对协方差矩阵求解特征值问题，求出特征向量和特征值</p>
<p>3.以数据表示各主成分方向。</p>
<p>特征值，特征向量</p>
<h3 id="LSA潜在语义分析（LSI）"><a href="#LSA潜在语义分析（LSI）" class="headerlink" title="LSA潜在语义分析（LSI）"></a>LSA潜在语义分析（LSI）</h3><p>从大量文本数据中找出单词之间的潜在关联性</p>
<p>潜在语义空间</p>
<p>矩阵分解</p>
<p>主要的问题有：<br>　　　　1） SVD计算非常的耗时，尤其是我们的文本处理，词和文本数都是非常大的，对于这样的高维度矩阵做奇异值分解是非常难的。<br>　　　　2） 主题值的选取对结果的影响非常大，很难选择合适的k值。<br>　　　　3） LSI得到的不是一个概率模型，缺乏统计基础，结果难以直观的解释。</p>
<h3 id="NMF非负矩阵分解"><a href="#NMF非负矩阵分解" class="headerlink" title="NMF非负矩阵分解"></a>NMF非负矩阵分解</h3><p>输入数据和输出数据的值都是非负的</p>
<p>没有“潜在语义空间的每一个维度都是正交的”这一约束条件</p>
<p>优点：可解释性强</p>
<p>V （n×d)= W(n×r)*H(r×d)</p>
<p>将W和H初始化为正值</p>
<p>将H视为常数，更新W</p>
<p>将W视为常数，更新H</p>
<p>当W和H收敛时，停止运算</p>
<h3 id="LDA隐含狄利克雷分布"><a href="#LDA隐含狄利克雷分布" class="headerlink" title="LDA隐含狄利克雷分布"></a>LDA隐含狄利克雷分布</h3><p>词袋模型</p>
<p>文本的主题分布</p>
<p>主题的单词分布</p>
<p>1.基于文本的主题分布为单词分配主题</p>
<p>2.基于分配的主题的单词分布确定单词</p>
<p>3.对所有文本中包含的单词执行步骤1和步骤2的操作。</p>
<h5 id="LDA算法步骤"><a href="#LDA算法步骤" class="headerlink" title="LDA算法步骤"></a>LDA算法步骤</h5><p>1.为各文本的单词随机分配主题</p>
<p>2.基于为单词分配的主题，计算每个文本的主题概率</p>
<p>3.基于为单词分配的主题，计算每个主题的单词概率</p>
<p>4.计算步骤2和步骤3中的概率的乘积，基于得到的概率，再次为各文本的单词分配主题。</p>
<p>5.重复步骤2~步骤4的计算，直到收敛。</p>
<h3 id="K-means算法"><a href="#K-means算法" class="headerlink" title="K-means算法"></a>K-means算法</h3><p>1.从数据点随机选择数量与簇的数量相同的数据点，作为这些簇的重心。</p>
<p>2.计算数据点与各个重心之间的距离，并将最近的重心所在的簇作为该数据点所属的簇。</p>
<p>3.计算每个簇的数据点的平均值，作为新的重心。</p>
<p>4.重复2，3，继续计算，直到所有数据点不改变所属的簇，或者达到最大计算步数。</p>
<h5 id="Elbow方法"><a href="#Elbow方法" class="headerlink" title="Elbow方法"></a>Elbow方法</h5><p>确定合适的簇的数量</p>
<h5 id="簇内平方和WCSS"><a href="#簇内平方和WCSS" class="headerlink" title="簇内平方和WCSS"></a>簇内平方和WCSS</h5><p>判断聚类结果的好坏</p>
<p>随着簇的数量增加，WCSS会变小</p>
<p>指对所有簇计算其所属的数据点与簇的重心之间距离的平方和，并将它们相加得到的值。值越小，说明聚类结果越好。</p>
<h3 id="混合高斯分布"><a href="#混合高斯分布" class="headerlink" title="混合高斯分布"></a>混合高斯分布</h3><h5 id="高斯分布"><a href="#高斯分布" class="headerlink" title="高斯分布"></a>高斯分布</h5><p>高斯分布（Gaussian distribution）有时也被称为正态分布（normal distribution），是一种在自然界大量的存在的、最为常见的分布形式。</p>
<p>1.初始化参数（各高斯分布的均值和方差）</p>
<p>2.对每个类别计算数据点的权重。</p>
<p>3.根据步骤2中计算出的权重重新计算参数。</p>
<p>4.重复2，3直到通过3更新前后的每个均值的变化足够小。</p>
<p>高斯分布：椭圆形分布数据</p>
<p>K-means：圆形分布数据</p>
<h3 id="LLE局部线性嵌入"><a href="#LLE局部线性嵌入" class="headerlink" title="LLE局部线性嵌入"></a>LLE局部线性嵌入</h3><p>流形学习</p>
<p>流形：可以将局部看作没有弯曲的空间。</p>
<p>在D维空间存在一个d维空间结构（d&lt;D)</p>
<p>1.找到数据点x<del>i</del>的近邻点(k个)。</p>
<p>2.求出能用k个近邻点的线性组合表示x<del>i</del>的权重w<del>ij</del>。</p>
<p>3.使用权重w<del>ij</del>计算低维（d维）的y<del>i</del>。</p>
<h3 id="t-SNE-t分布随机邻域嵌入"><a href="#t-SNE-t分布随机邻域嵌入" class="headerlink" title="t-SNE t分布随机邻域嵌入"></a>t-SNE t分布随机邻域嵌入</h3><p>将高维复杂数据降维为二维（或三维）算法，用于低维空间的可视化</p>
<p>在降维时使用自由度为1的t分布</p>
<p>原本很近的结构在低维空间更近，原本较远的结构变得更远。</p>
<p>1.对于所有的组i、j，使用高斯分布来表示x<del>i</del>和x<del>j</del>的相似度。</p>
<p>2.在低维空间中随机配置与x<del>i</del>相同数量的点y<del>i</del>，对于所有的组i、j，使用t分布表示y<del>i</del>和y<del>j</del>的相似度。</p>
<p>3.更新数据点y<del>i</del>，使得步骤1和步骤2中定义的相似度分布尽可能的相似。</p>
<p>4.重复步骤3，直到达到收敛条件。</p>
<h2 id="评估方法和各种数据处理"><a href="#评估方法和各种数据处理" class="headerlink" title="评估方法和各种数据处理"></a>评估方法和各种数据处理</h2><p>分类问题：混淆矩阵、正确率、精确率、召回率、F值、AUC</p>
<p>回归问题：均方误差、决定系数</p>
<h3 id="分类问题评估方法"><a href="#分类问题评估方法" class="headerlink" title="分类问题评估方法"></a>分类问题评估方法</h3><p>准确率：预测正确的结果占总预测结果的比例。accuracy_score(y,y_pred)</p>
<p>精确率：在所有被预测为阳性的数据中，被正确预测为阳性的数据所占的比例。precision_score(y,y_pred)</p>
<p>召回率：在实际为阳性的数据中，被正确预测为阳性的数据所占的比例。recall_score(y,y_pred)</p>
<p>F值：综合反映精确率，召回率两个趋势的指标。f1_score(y,y_pred)。精确率，召回率此消彼长，如果这俩个指标同等重要，可以观察F值。</p>
<p>预测概率：predict_proba，输出每个数据被分类为各标签的概率</p>
<p>(model_lor.predict_proba(X)[: , 1]&gt;0.1).astype(np.int)</p>
<p>应对数据不均衡问题指标：AUC，AUC指的是ROC曲线下的面积。roc_auc_score(y,probas[:, 1])</p>
<h3 id="回归问题评估方法"><a href="#回归问题评估方法" class="headerlink" title="回归问题评估方法"></a>回归问题评估方法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from sklearn.datasets import load_boston</span><br><span class="line"></span><br><span class="line">data = load_boston()</span><br><span class="line">#X x1取到的都是 二维数组</span><br><span class="line">X = data.data[:, [5, ]]</span><br><span class="line">x1 = data.data[:, [5]]</span><br><span class="line">#x2 取到的 是 一维数组</span><br><span class="line">x2 = data.data[:, 5]</span><br></pre></td></tr></table></figure>

<p>均方误差MSE，mean_squared_error(y,y_pred) 计算所有预测值与数据之间的误差的平方，并取平方的平均值</p>
<p>决定系数R^2^：越接近1说明预测越好 r2_score(y,y_pred)</p>
<h3 id="防止过拟合"><a href="#防止过拟合" class="headerlink" title="防止过拟合"></a>防止过拟合</h3><p>增加训练数据，减少特征值，正则化，Early Stopping ，集成学习</p>
<p>将数据分为训练数据和验证数据，train_test_split(X,y,test_size =0.3)</p>
<h5 id="交叉验证"><a href="#交叉验证" class="headerlink" title="交叉验证"></a>交叉验证</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cv = KFold(5,shuffle = true)</span><br><span class="line">model_rfc_1 = RandomForestClassifier()</span><br><span class="line">cross_val_score(model_rfc_1,X,y,cv=cv,scoring=&#x27;accuracy&#x27;)</span><br></pre></td></tr></table></figure>

<h5 id="搜索超参数"><a href="#搜索超参数" class="headerlink" title="搜索超参数"></a>搜索超参数</h5><p>网格搜索：一种自动搜索超参数方法</p>
<p>GridSearchCV(model,param_grid,cv=cv,scoring=’accuracy’)</p>
<h3 id="文本数据处理"><a href="#文本数据处理" class="headerlink" title="文本数据处理"></a>文本数据处理</h3><p>1.基于单词出现次数的转换</p>
<p>2.基于tf-idf的转换</p>
<p>tf词频，idf逆文本频率指数，tf是单词在文本中出现的频率，idf是一个包含该单词的文本越多，值就越小的值。</p>
<h3 id="图像数据处理"><a href="#图像数据处理" class="headerlink" title="图像数据处理"></a>图像数据处理</h3><p>1.直接将像素信息作为数值使用</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title>读书笔记|图解深度学习</title>
    <url>/2021/11/01/dian-zi-shu-yi-ji-bi-ji/tu-jie-shen-du-xue-xi/</url>
    <content><![CDATA[<h1 id="图解深度学习"><a href="#图解深度学习" class="headerlink" title="图解深度学习"></a>图解深度学习</h1><p>作者：山下隆义</p>
<p>深度学习的起源包括感知器和玻尔兹曼机，</p>
<p>起源于感知器的深度学习属实有监督学习，</p>
<p>起源于受限玻尔兹曼机的深度学习属于无监督学习 </p>
<h2 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h2><h3 id="M-P模型"><a href="#M-P模型" class="headerlink" title="M-P模型"></a>M-P模型</h3><p>需要人为设定参数，</p>
<h3 id="感知器"><a href="#感知器" class="headerlink" title="感知器"></a>感知器</h3><p>通过误差修正确定参数</p>
<h3 id="多层感知器"><a href="#多层感知器" class="headerlink" title="多层感知器"></a>多层感知器</h3><p>误差修正只能3层网络，修正中间层到输出层，不能修正输入层到中间层</p>
<h3 id="误差反向传播算法"><a href="#误差反向传播算法" class="headerlink" title="误差反向传播算法"></a>误差反向传播算法</h3><h4 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h4><p>梯度消失导致无法调整连接权重问题，需要在训练过程中调整学习率n，以防止梯度消失。</p>
<h3 id="误差函数和激活函数"><a href="#误差函数和激活函数" class="headerlink" title="误差函数和激活函数"></a>误差函数和激活函数</h3><h4 id="误差函数"><a href="#误差函数" class="headerlink" title="误差函数"></a>误差函数</h4><p>1多分类：交叉熵</p>
<p>2二分类：</p>
<p>3递归问题：最小二乘误差函数</p>
<p>等等</p>
<h4 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h4><p>对输入信号进行线性或非线性 变换</p>
<p>sigmoid </p>
<p>tanh</p>
<p>ReLU</p>
<h4 id="似然函数"><a href="#似然函数" class="headerlink" title="似然函数"></a>似然函数</h4><p>计算多层感知器的输出结果</p>
<p>多分类问题softmax作为似然函数</p>
<h3 id="随机梯度下降法"><a href="#随机梯度下降法" class="headerlink" title="随机梯度下降法"></a>随机梯度下降法</h3><p>根据训练样本的输入方式不同，有以下分类</p>
<p>1.批量学习算法 batch learning ，每次迭代计算时遍历全部训练样本</p>
<p>2.在线学习 sequential learning / online learning 每输入一个训练样本就进行一次迭代，可能会出现大幅变动</p>
<p>3.<strong>小批量梯度下降法mini-batch learning</strong>（随机梯度下降法）将训练集分成几个子集D，每次迭代使用一个子集</p>
<h4 id="学习率"><a href="#学习率" class="headerlink" title="学习率"></a>学习率</h4><p>首先设定一个较大值，然后慢慢减小</p>
<p>自适应调整学习率例如AdaGrad，AdaDelta，动量方法</p>
<h2 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h2><p>输入层、卷积层、池化层、全连接层、输出层</p>
<h3 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h3><p>卷积核的通道数必须跟输入层通道数保持一致，计算是各通道分别相乘然后相加。形成1个卷积后特征图</p>
<p>因此卷积后特征通道数跟卷积核的个数有关，卷积核有多少个，输出通道就有多少个</p>
<p>零填充</p>
<p>填充大小P=(F-1)/2,其中F是卷积核大小</p>
<p>卷积结果需要经过激活函数</p>
<h3 id="池化层"><a href="#池化层" class="headerlink" title="池化层"></a>池化层</h3><p>减少卷积层产生的特征图的尺寸。</p>
<p>最大池化，平均池化，Lp池化</p>
<h3 id="参数设定"><a href="#参数设定" class="headerlink" title="参数设定"></a>参数设定</h3><p>与神经网络有关主要参数</p>
<ul>
<li>卷积层的卷积核大小、个数</li>
<li>激活函数的种类</li>
<li>池化函数的种类</li>
<li>网络的层结构（卷积层的个数、全连接层的个数）</li>
<li>全连接层的个数</li>
<li>Dropout的概率</li>
<li>有无预处理</li>
<li>有无归一化</li>
</ul>
<p>与训练有关参数</p>
<ul>
<li>Mini-Batch大小</li>
<li>学习率</li>
<li>迭代次数</li>
<li>有无预训练</li>
</ul>
<blockquote>
<p>首先确定重要参数，然后再对其他参数微调</p>
</blockquote>
<h2 id="受限玻尔兹曼机"><a href="#受限玻尔兹曼机" class="headerlink" title="受限玻尔兹曼机"></a>受限玻尔兹曼机</h2><h3 id="Hopfield神经网络"><a href="#Hopfield神经网络" class="headerlink" title="Hopfield神经网络"></a>Hopfield神经网络</h3><p>神经网络两大类：1.多层神经网络。</p>
<p>2.相互连接型网络：网络不分层，单元之间相互连接，联想记忆，：通过对事物之间建立对应关系来记忆。</p>
<p>相互连接网络可以通过联想记忆去除输入数据的噪声。</p>
<p>Hopfield是最典型的相互连接网络</p>
<p>易出现串扰（相互干扰，不能准确记忆的情况），可以采用模式正交化，但也不能完全解决。要用 玻尔兹曼机</p>
<h3 id="玻尔兹曼机"><a href="#玻尔兹曼机" class="headerlink" title="玻尔兹曼机"></a>玻尔兹曼机</h3><p> 通过让每个单元按照一定的概率分布发生状态变化，来避免陷入局部最优解。</p>
<p>与Hopfield相比，两者最大的区别是Hopfield神经网络的输出是按照某种确定性决定的，而玻尔兹曼机的输出则如下所示，是按照某种概率分布决定的。</p>
<p>隐藏单元，可见单元</p>
<h3 id="受限玻尔兹曼机-1"><a href="#受限玻尔兹曼机-1" class="headerlink" title="受限玻尔兹曼机"></a>受限玻尔兹曼机</h3><p>含有隐藏变量的玻尔兹曼机训练十分困难，加入“层内单元之间无连接”提出受限玻尔兹曼机（由可见层和隐藏层构成的两层结构）</p>
<p>可见层与隐藏层相互连接，但相同层内单元无连接。</p>
<p>计算量过于庞大问题，提出对比散度算法</p>
<h3 id="对比散度算法"><a href="#对比散度算法" class="headerlink" title="对比散度算法"></a>对比散度算法</h3><p>与Gibbs采样一样，对比散度算法是一种近似算法，通过较少的迭代次数求出参数调整值。</p>
<h3 id="深度信念网络"><a href="#深度信念网络" class="headerlink" title="深度信念网络"></a>深度信念网络</h3><p>受限玻尔兹曼机堆叠形成，与多层神经网络最大区别是训练方法不同，采用对比散度算法，逐层调整连接权重和偏置。</p>
<p>即可生成模型来用，也可判别模型来用</p>
<p>生成模型：能够去除输入数据中含有的噪声，得到新的数据，进行输入数据压缩和特征表达。</p>
<p>判别模型：在模型顶层添加一层来达到分类功能</p>
<h2 id="自编码器"><a href="#自编码器" class="headerlink" title="自编码器"></a>自编码器</h2><h3 id="自编码器-1"><a href="#自编码器-1" class="headerlink" title="自编码器"></a>自编码器</h3><p>一种有效的数据维度压缩算法，主要应用在以下两个方面</p>
<ul>
<li>构建一种能够重构输入样本并进行特征表达的神经网络</li>
<li>训练多层神经网络时，通过自编码器训练样本得到参数初始值</li>
</ul>
<p>基于无监督学习的神经网络，通过不断调整参数，重构经过维度压缩的输入样本。</p>
<h3 id="降噪自编码器"><a href="#降噪自编码器" class="headerlink" title="降噪自编码器"></a>降噪自编码器</h3><p>向原本的训练样本中加入随机噪声再输入给输入层。</p>
<ul>
<li>保持输入样本不变条件下，提取能够更好反映样本属性的特征。</li>
<li>消除输入样本中包含的噪声</li>
</ul>
<h3 id="稀疏自编码器"><a href="#稀疏自编码器" class="headerlink" title="稀疏自编码器"></a>稀疏自编码器</h3><p>通过增加 正则化项，大部分单元的输出都变为了0，这样就能利用少数单元有效完成压缩或重构。</p>
<h3 id="栈式自编码器"><a href="#栈式自编码器" class="headerlink" title="栈式自编码器"></a>栈式自编码器</h3><p>逐层训练，</p>
<h2 id="提高泛化能力的方法"><a href="#提高泛化能力的方法" class="headerlink" title="提高泛化能力的方法"></a>提高泛化能力的方法</h2><h3 id="训练样本"><a href="#训练样本" class="headerlink" title="训练样本"></a>训练样本</h3><p>数据增强：当数据集包含的数据有限或者需要自己采集但采集到的数据量又不足时，</p>
<h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><ul>
<li>均值减法</li>
<li>均一化</li>
<li>白化</li>
</ul>
<h4 id="均值减法"><a href="#均值减法" class="headerlink" title="均值减法"></a>均值减法</h4><p>大规模物体识别</p>
<p><strong>x</strong>‘ = 1/n sum(<strong>x</strong>)</p>
<p>x~ = x - x’</p>
<p>各数据平均值变为0，图像整体亮度变化得到抑制。</p>
<h4 id="均一化"><a href="#均一化" class="headerlink" title="均一化"></a>均一化</h4><p>为样本的均值和方差添加约束的一种预处理方法。</p>
<p>先计算标准差，然后进行均值减法后，除以标准差，得到均值0，标准差1的标准化数据。</p>
<p>亮度差异更小</p>
<h4 id="白化"><a href="#白化" class="headerlink" title="白化"></a>白化</h4><p>消除数据间相关性方法。经过白化处理后，数据之间相关性较低，图像边缘增强。</p>
<p>（ZCA白化）</p>
<h3 id="激活函数-1"><a href="#激活函数-1" class="headerlink" title="激活函数"></a>激活函数</h3><p>sigmoid</p>
<p>maxout</p>
<p>ReLU衍生函数</p>
<p>Leaky ReLU</p>
<p>Parametric ReLU(PReLU)</p>
<p>Randomized leaky Rectified Linear Units(RPeLU)</p>
<h3 id="Dropout"><a href="#Dropout" class="headerlink" title="Dropout"></a>Dropout</h3><p>提高网络泛化能力方法，指：在网络的训练过程中，按照一定的概率将一部分中间层的单元暂时从网络中丢弃，通过把该单元的输出设置为0使其不工作，来避免过拟合</p>
<h3 id="DropConnect"><a href="#DropConnect" class="headerlink" title="DropConnect"></a>DropConnect</h3><p>Dropout是把单元的输出值设置为0，DropConnect是把一部分连接权重设置为0</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title>C++之vector</title>
    <url>/2019/07/14/ben-ke-bi-she-qi-jian-ji-lu-bi-ji/c-zhi-vector/</url>
    <content><![CDATA[<h1 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h1><span id="more"></span>

<h5 id="1-vector头文件"><a href="#1-vector头文件" class="headerlink" title="1.vector头文件"></a>1.vector头文件</h5><p><code>#include&quot;vector&quot;</code></p>
<h5 id="2-vector声明及初始化"><a href="#2-vector声明及初始化" class="headerlink" title="2.vector声明及初始化"></a>2.vector声明及初始化</h5><p>​    1)一维数组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; vec;        <span class="comment">//声明一个int型向量</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">vec</span><span class="params">(<span class="number">5</span>)</span></span>;     <span class="comment">//声明一个初始大小为5的int向量</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">vec</span><span class="params">(<span class="number">10</span>, <span class="number">1</span>)</span></span>; <span class="comment">//声明一个初始大小为10且值都是1的向量</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">vec</span><span class="params">(tmp)</span></span>;   <span class="comment">//声明并用tmp向量初始化vec向量</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">tmp</span><span class="params">(vec.begin(), vec.begin() + <span class="number">3</span>)</span></span>;  <span class="comment">//用向量vec的第0个到第2个值初始化tmp</span></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;   </span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">vec</span><span class="params">(arr, arr + <span class="number">5</span>)</span></span>;      <span class="comment">//将arr数组的元素用于初始化vec向量</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">vec</span><span class="params">(&amp;arr[<span class="number">1</span>], &amp;arr[<span class="number">4</span>])</span></span>; <span class="comment">//将arr[1]~arr[4]范围内的元素作为vec的初始值 </span></span><br></pre></td></tr></table></figure>

<p>​    2)二维数组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; vec;  <span class="comment">//声明一个二维int向量</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">vec</span>(n,vector&lt;<span class="keyword">int</span>&gt;(m,<span class="number">0</span>)); <span class="comment">//声明并初始一个n行m列值都是0的向量</span></span><br></pre></td></tr></table></figure>

<p><strong>如果初始化的为指针，那么所有的全都指向同一个地方,例如vector&lt;Node*&gt; arr(len,new Node(-1))</strong></p>
<h5 id="3-vector基本操作"><a href="#3-vector基本操作" class="headerlink" title="3.vector基本操作"></a>3.vector基本操作</h5><p>(1). 容量</p>
<ul>
<li>向量大小： vec.size();</li>
<li>向量最大容量： vec.max_size();</li>
<li>更改向量大小： vec.resize();</li>
<li>向量真实大小： vec.capacity();</li>
<li>向量判空： vec.empty();</li>
<li>减少向量大小到满足元素所占存储空间的大小： vec.shrink_to_fit(); //<a href="http://www.cplusplus.com/reference/vector/vector/shrink_to_fit/">shrink_to_fit</a></li>
</ul>
<p>(2). 修改</p>
<ul>
<li>多个元素赋值： vec.assign(); //类似于初始化时用数组进行赋值</li>
<li><u>末尾添加元素： vec.push_back();</u></li>
<li><u>末尾删除元素： vec.pop_back();</u></li>
<li>任意位置插入元素： vec.insert();</li>
<li>任意位置删除元素： vec.erase();</li>
<li>交换两个向量的元素： vec.swap();</li>
<li>清空向量元素： vec.clear();</li>
<li>去除相邻重复元素 :unique(); </li>
</ul>
<p>(3)迭代器</p>
<ul>
<li>开始指针：vec.begin();</li>
<li>末尾指针：vec.end(); //指向最后一个元素的下一个位置</li>
<li>指向常量的开始指针： vec.cbegin(); //意思就是不能通过这个指针来修改所指的内容，但还是可以通过其他方式修改的，而且指针也是可以移动的。</li>
<li>指向常量的末尾指针： vec.cend();</li>
</ul>
<p>(4)元素的访问</p>
<ul>
<li>下标访问： vec[1]; //并不会检查是否越界</li>
<li>at方法访问： vec.at(1); //以上两者的区别就是at会检查是否越界，是则抛出out of range异常</li>
<li>访问第一个元素： vec.front();</li>
<li>访问最后一个元素： vec.back();</li>
<li>返回一个指针： int* p = vec.data(); //可行的原因在于vector在内存中就是一个连续存储的数组，所以可以返回一个指针指向这个数组。这是是C++11的特性。</li>
</ul>
<h5 id="4-算法"><a href="#4-算法" class="headerlink" title="4.算法"></a>4.算法</h5><ul>
<li>遍历元素</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"><span class="keyword">for</span> (it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); it++)</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    cout &lt;&lt; vec.<span class="built_in">at</span>(i) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>元素翻转</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="built_in">reverse</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>

<ul>
<li>元素排序</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>()); <span class="comment">//采用的是从小到大的排序</span></span><br><span class="line"><span class="comment">//如果想从大到小排序，可以采用上面反转函数，也可以采用下面方法:</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Comp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; a, <span class="keyword">const</span> <span class="keyword">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), Comp);</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>工具|IDEA技巧</title>
    <url>/2021/04/11/ben-ke-bi-she-qi-jian-ji-lu-bi-ji/idea-ji-qiao/</url>
    <content><![CDATA[<h3 id="IDEA技巧"><a href="#IDEA技巧" class="headerlink" title="IDEA技巧"></a>IDEA技巧</h3><p>1.ctrl+shift+v 复制历史</p>
<p>2.alt+鼠标左键 纵向选择多行文本<strong>（⭐）</strong></p>
<p>3.ctrl+alt+L 格式化</p>
<span id="more"></span>

<p>4.ctrl+D 复制当前行</p>
<p>5.alt+shift+上/下 当前行向上/向下移动</p>
<p>6.shift+上 选中多行</p>
<p>7.home 行首 end 行尾 ctrl+左右 跳过一个词</p>
<p>8.ctrl+G 跳到指定行</p>
<p>9.ctrl+F 当前文件查找</p>
<p>10.ctrl+R 当前文件替换</p>
<p>11.ctrl+shift+N 查找文件</p>
<p>12.alt+enter 万能快捷键</p>
<p>​    见到红色报错就按</p>
<p>​    见到警告波浪线就按</p>
<p>13.重命名 shift+F6    <strong>（⭐）</strong></p>
<ol start="14">
<li>//todo todo窗口    </li>
</ol>
<p>15.ctrl+shift+/ 快速注释多行<strong>（⭐）</strong></p>
<h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><p>tab快捷补全</p>
<h5 id="1-登录界面"><a href="#1-登录界面" class="headerlink" title="1.登录界面"></a>1.登录界面</h5><p>存在跨域问题用token方式维持状态</p>
<p>不存在可以用cookie和session方式</p>
]]></content>
      <tags>
        <tag>工具</tag>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>后端|Java学习（慕课网）</title>
    <url>/2021/01/28/ben-ke-bi-she-qi-jian-ji-lu-bi-ji/java-xue-xi-mu-ke-wang/</url>
    <content><![CDATA[<h3 id="Java学习（慕课网）"><a href="#Java学习（慕课网）" class="headerlink" title="Java学习（慕课网）"></a>Java学习（慕课网）</h3><h4 id="Java入门第二季"><a href="#Java入门第二季" class="headerlink" title="Java入门第二季"></a>Java入门第二季</h4><span id="more"></span>

<h5 id="输入流"><a href="#输入流" class="headerlink" title="输入流"></a>输入流</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> i = scanner.nextInt();</span><br><span class="line">String str = scanner.next();</span><br></pre></td></tr></table></figure>

<h5 id="equals-方法-与-（⭐）"><a href="#equals-方法-与-（⭐）" class="headerlink" title="equals 方法 与 ==（⭐）"></a>equals 方法 与 ==<strong>（⭐）</strong></h5><p>1）对于==，</p>
<p>如果作用于基本数据类型的变量，则直接比较其存储的 “值”是否相等；</p>
<p>如果作用于引用类型的变量，则比较的是所指向的对象的地址  　　</p>
<p>2）对于equals方法，注意：equals方法不能作用于基本数据类型的变量  </p>
<p>如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址；</p>
<p>诸如String、Date等类对equals方法进行了重写的话，比较的是所指向的对象的内容。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s3=<span class="keyword">new</span> String(<span class="string">&quot;imooc&quot;</span>);</span><br><span class="line">String s4=<span class="keyword">new</span> String(<span class="string">&quot;imooc&quot;</span>); </span><br><span class="line"><span class="comment">//true java会判断如果是相同字符串 则自动指向同一地址</span></span><br><span class="line">System.out.println(s3.equals(s4));</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//false java不会对自定义的类对象进行优化使其指向同一地址</span></span><br><span class="line">Course cr1 = <span class="keyword">new</span> Course(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;C语言&quot;</span>);</span><br><span class="line">Course cr2 = <span class="keyword">new</span> Course(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;C语言&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(cr1.equals(cr2));</span><br></pre></td></tr></table></figure>



<h5 id="包的命名规范："><a href="#包的命名规范：" class="headerlink" title="包的命名规范："></a>包的命名规范：</h5><p>域名后缀.组织机构名.项目名[.模块名].包的职能</p>
<h5 id="修饰符："><a href="#修饰符：" class="headerlink" title="修饰符："></a>修饰符：</h5><p>private 只能在当前类中使用</p>
<p>(default) 只能被包中其他类访问</p>
<p>protected继承类可以访问</p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1610094788485.png" alt="1610094788485"></p>
<h5 id="封装："><a href="#封装：" class="headerlink" title="封装："></a>封装：</h5><p>封装即隐藏功能的实现细节</p>
<p>利用对象与方法是实现封装的直接途径</p>
<p>良好的封装让代码更容易阅读和维护</p>
<h5 id="继承："><a href="#继承：" class="headerlink" title="继承："></a>继承：</h5><p>default，protected，public 可以继承</p>
<p>final 关键字 表示该类型不可被继承</p>
<p>​    public final class  类名</p>
<p>super 子类访问父类属性和方法</p>
<p>方法重载 设计时多态</p>
<p>方法重写 运行时多态</p>
<p>抽象类</p>
<p>​    abstract</p>
<h5 id="多态：关键–接口-Interface"><a href="#多态：关键–接口-Interface" class="headerlink" title="多态：关键–接口(Interface)"></a>多态：关键–接口(Interface)</h5><p>设计时多态 （重载）</p>
<p>运行时多态（继承）</p>
<p>同一个行为具有多个不同的表现形式或形态的能力</p>
<h4 id="Java入门第三季"><a href="#Java入门第三季" class="headerlink" title="Java入门第三季"></a>Java入门第三季</h4><h5 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally:"></a>try-catch-finally:</h5><p>如果try catch finally 没有return 会调用最后的return</p>
<h5 id="String"><a href="#String" class="headerlink" title="String"></a>String</h5><p>String 具有不可变性</p>
<p><img src="http://img.mukewang.com/53d9f7d200010bb007780366.jpg" alt="img"> </p>
<p><img src="http://img.mukewang.com/53a9260b0001808e06540410.jpg" alt="img"> </p>
<p>StringBuilder </p>
<p>StingBuffer 线程安全</p>
<p><img src="http://img.mukewang.com/53a7d34300011c6005970125.jpg" alt="img"> </p>
<h5 id="Java包装类"><a href="#Java包装类" class="headerlink" title="Java包装类"></a>Java包装类</h5><p><img src="http://img.mukewang.com/53abd8450001911703630223.jpg" alt="img"> </p>
<h5 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h5><p>​    List -&gt;ArrayList,LinkedList</p>
<p>​    Queue -&gt;LinkedList</p>
<p>​    Set -&gt;HashSet</p>
<p>List</p>
<p>List&lt;&gt;   泛型 不能添加泛型规定的类型及其子类型以外的对象</p>
<p>1.泛型集合中的限定类型b不能使用基本数据类型</p>
<p>2.可以通过使用包装类限定允许存入的基本数据类型</p>
<h5 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h5><p>HashMap</p>
<p>遍历Map</p>
<p>​    通过keySet遍历  Set&lt;&gt; keySet = Map.keySet()</p>
<p>​    通过 entrySet方法遍历 返回Map所有键值对Set&lt;Entry&lt; , &gt;&gt; entrySet = Map.entrySet();</p>
<h5 id="Collections-Sort"><a href="#Collections-Sort" class="headerlink" title="Collections.Sort"></a>Collections.Sort</h5><p>对象进行sort要实现Comparable接口</p>
<p>Comparable —默认比较接口</p>
<p>​    其实现类需实现compareTo（）方法，compareTo（）方法返回正数表示大，负数表示小，0表示相等</p>
<p>Comparator —临时比较接口</p>
<p>​    其实现类要实现compare（）方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class StudentCompartor implements Comparator&lt;Student&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int compare(Student o1, Student o2) &#123;</span><br><span class="line">        return o1.getName().compareTo(o2.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Collections.sort(list,new StudentCompartor());</span><br></pre></td></tr></table></figure>

<h4 id="Maven项目依赖管理"><a href="#Maven项目依赖管理" class="headerlink" title="Maven项目依赖管理"></a>Maven项目依赖管理</h4><h5 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h5><p>端口8009 （不知道啥时候改成这个了！）<strong>（⭐）</strong></p>
<h4 id="Servlet基础"><a href="#Servlet基础" class="headerlink" title="Servlet基础"></a>Servlet基础</h4><h5 id="servlet-请求"><a href="#servlet-请求" class="headerlink" title="servlet 请求"></a>servlet 请求</h5><p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1610459806080.png" alt="1610459806080"></p>
<p>1.继承HttpServlet</p>
<p>2.重写doGet()方法或者doPost()方法</p>
<p>3.在web.xml中注册Servlet</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HttpServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>ujn.edu.servlet.Servlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span> //加载优先级</span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HttpServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/Servlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>或者直接在类上加注释@WebServlet(“/Servlet”)</strong></p>
<p>servlet类文件更新后 tomcat重新装载servlet</p>
<p><strong>jsp:useBean   class 属性必须有包名.类名</strong>（⭐）</p>
<h5 id="路径跳转"><a href="#路径跳转" class="headerlink" title="路径跳转"></a>路径跳转</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//请求重定向方式跳转到test.jsp,当前路径是(我猜的)maven01/ujn/edu/servlet/</span></span><br><span class="line">        <span class="comment">//使用request.getContextPath获得上下文对象</span></span><br><span class="line"><span class="comment">//        resp.sendRedirect(req.getContextPath()+&quot;/test.jsp&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//服务器内部跳转</span></span><br><span class="line">        req.getRequestDispatcher(<span class="string">&quot;/test.jsp&quot;</span>).forward(req,resp);</span><br><span class="line"><span class="comment">//        req.getRequestDispatcher(&quot;test.jsp&quot;).forward(req,resp);</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="获取初始化参数"><a href="#获取初始化参数" class="headerlink" title="获取初始化参数"></a>获取初始化参数</h5><p>web.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>username<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>password<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="MVC简介"><a href="#MVC简介" class="headerlink" title="MVC简介"></a>MVC简介</h5><p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1610542237584.png" alt="1610542237584"></p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1610546320068.png" alt="1610546320068"></p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1610708657913.png" alt="1610708657913"></p>
<p>dao层：baidao层叫数据访问层，全称为data access object，属于一种比较底层，比较基础的操作，具体到对于某个表、某个实体的增删改查<br>service层：service层叫服务层，被称为服务，肯定是相比之下比较高层次的一层结构，相当于将几种操作封装起来。</p>
<h4 id="Servlet报表"><a href="#Servlet报表" class="headerlink" title="Servlet报表"></a>Servlet报表</h4><p>（⭐）Tomcat中 部署DBCP 相对路径 有问题 （TODO）</p>
<h4 id="Java注解"><a href="#Java注解" class="headerlink" title="Java注解"></a>Java注解</h4><h5 id="Java中常见注解"><a href="#Java中常见注解" class="headerlink" title="Java中常见注解"></a>Java中常见注解</h5><p>java中自带注解</p>
<p>​    @Override 表示继承的父类方法</p>
<p>​    @Deprecated 表示方法过时 </p>
<p>​    @SuppressWarnings(“deprecation”) 忽略过时方法</p>
<p>第三方注解</p>
<p>Spring</p>
<p>​    @Autowired</p>
<p>​    @Service</p>
<p>​    @Repository</p>
<p>Mybatis</p>
<p>​    @InsertProvider</p>
<p>​    @UpdateProvider</p>
<p>​    @Options</p>
<h5 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h5><p>1.使用@interface 关键字定义注解</p>
<p>2.成员以无参无异常方式声明</p>
<p>3.可以用default为成员指定一个默认值</p>
<p>4.如果注解只有一个成员，则成员名必须取名为value(),在使用时可以忽略成员名和赋值号(=)</p>
<p>5.注解可以没有任何成员，这样就成为了标识注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD,ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Description &#123;</span><br><span class="line">    <span class="function">String <span class="title">desc</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">author</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">()</span> <span class="keyword">default</span> 18</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>//注意Inherited 继承父类 但不能继承接口 </p>
<p>解析注解</p>
<p>Test.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> zhujie;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Description(desc = &quot;I am class annotation&quot;,author = &quot;fanko&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Description(desc = &quot;I am method annotation&quot;,author = &quot;fanko&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ParseAnn.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParseAnn</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.使用类加载器加载类</span></span><br><span class="line">            Class c = Class.forName(<span class="string">&quot;zhujie.Test&quot;</span>);</span><br><span class="line">            <span class="comment">//2.找到类上面的注解</span></span><br><span class="line">            <span class="keyword">boolean</span> isExist = c.isAnnotationPresent(Description.class);</span><br><span class="line">            <span class="keyword">if</span>(isExist)&#123;</span><br><span class="line">                <span class="comment">//3.拿到注解实例</span></span><br><span class="line">                Description d = (Description) c.getAnnotation(Description.class);</span><br><span class="line">                System.out.println(d.desc());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//4.找到方法上的注解</span></span><br><span class="line">            Method[] ms = c.getMethods();</span><br><span class="line">            <span class="keyword">for</span>(Method m: ms)&#123;</span><br><span class="line">                <span class="keyword">boolean</span> isMExist = m.isAnnotationPresent(Description.class);</span><br><span class="line">                <span class="keyword">if</span>(isMExist)&#123;</span><br><span class="line">                    Description d = (Description) m.getAnnotation(Description.class);</span><br><span class="line">                    System.out.println(d.desc());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//另外一种解析方法</span></span><br><span class="line">            <span class="keyword">for</span> (Method m : ms) &#123;</span><br><span class="line">                Annotation[] as =m.getAnnotations();</span><br><span class="line">                <span class="keyword">for</span> (Annotation a : as) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(a <span class="keyword">instanceof</span> Description)&#123;</span><br><span class="line">                        Description d = (Description)a;</span><br><span class="line">                        System.out.println(d.desc());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h4><h5 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h5><p>porm.xml</p>
<p>用5.1.6版本，注意用高版本会出现不知名错误<strong>（⭐）</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>DBUtil.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DBUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String URL=<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/imooc&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String USER=<span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PASSWORD=<span class="string">&quot;123456&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Connection conn = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.加载驱动程序</span></span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">            <span class="comment">//2.获得数据库的连接</span></span><br><span class="line">            conn = DriverManager.getConnection(URL, USER, PASSWORD);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> conn;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>//3.实现增删改查</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PreparedStatement preparedStatement = connection.prepareStatement(sql);</span><br><span class="line">preparedStatement.execute();</span><br><span class="line">ResultSet resultSet = preparedStatement.executeQuery();</span><br></pre></td></tr></table></figure>

<h5 id="JDBC存储过程的调用"><a href="#JDBC存储过程的调用" class="headerlink" title="JDBC存储过程的调用"></a>JDBC存储过程的调用</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.调用无参存储过程</span></span><br><span class="line">Connection connection = DBUtil.getConnection();</span><br><span class="line">CallableStatement cs = conn.prepareCall(<span class="string">&quot;call sp_select_nofilter()&quot;</span>);</span><br><span class="line">cs.execute();</span><br><span class="line">ResultSet rs = cs.getResultSet();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.调用带输入参数的存储过程</span></span><br><span class="line"><span class="comment">//....</span></span><br><span class="line">CallableStatement cs = conn.prepareCall(<span class="string">&quot;call sp_select_filter(?)&quot;</span>);</span><br><span class="line">cs.setString(<span class="number">1</span>,sp_name);</span><br><span class="line"><span class="comment">//....</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.调用带输出参数的存储过程</span></span><br><span class="line"><span class="comment">//....</span></span><br><span class="line">CallableStatement cs = conn.prepareCall(<span class="string">&quot;call sp_select_count(?)&quot;</span>);</span><br><span class="line">cs.registerOutParameter(<span class="number">1</span>,Types.INTEGER);</span><br><span class="line"><span class="comment">//cs.execute();</span></span><br><span class="line">count = cs.getInt(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h5 id="JDBC事务管理"><a href="#JDBC事务管理" class="headerlink" title="JDBC事务管理"></a>JDBC事务管理</h5><p>事务（TRANSACTION）是作为单个逻辑工作单元执行的一系列操作，这些操作作为一个整体一起向系统提交，要么都执行，要么都不执行。</p>
<p>1.原子性(Atomicity):事务是一个完整的操作。</p>
<p>2.一致性(Consistency):当事务完成时，数据必须处于一致状态。</p>
<p>3.隔离性(Isolation):对数据进行修改的所有并发事务是彼此隔离的。</p>
<p>4.永久性(Durability):事务完成后，它对数据库的修改被永久保持。</p>
<p>JDBC对事务管理的支持</p>
<p>1.通过提交commit() 或 回退rollback() </p>
<p>2.事务操作默认是自动提交</p>
<p>3.可以通过调用setAutoCommit(false)来禁止自动提交</p>
<h5 id="JDBC连接池"><a href="#JDBC连接池" class="headerlink" title="JDBC连接池"></a>JDBC连接池</h5><p>为解决频繁的数据库连接压力</p>
<p>常用开源连接池</p>
<p>一、dbcp<strong>（⭐）</strong></p>
<p>​    commons-dbcp2-2.1.1.jar</p>
<p>​    commons-pool2-2.4.2.jar</p>
<p>​    commons-logging-1.2.jar</p>
<p>2.在项目根目录增加配置文件     <em>IDEA中要放在resources文件下</em></p>
<p>​    dbcp.properties</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">driverClassName=com.mysql.jdbc.Driver</span><br><span class="line">url=jdbc:mysql://localhost:3306/lab2?characterEncoding=UTF-8</span><br><span class="line">username=root</span><br><span class="line">password=123456</span><br><span class="line">maxTotal=30</span><br><span class="line">maxIdle=10</span><br><span class="line">initialSize=5</span><br><span class="line">//！！！前面不要加jdbc。。。</span><br></pre></td></tr></table></figure>

<p>二、c3p0</p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1610808375246.png" alt="1610808375246"></p>
<h4 id="JAVA反射"><a href="#JAVA反射" class="headerlink" title="JAVA反射"></a>JAVA反射</h4><p>1)静态成员，普通数据类型不是对象</p>
<p>2)类是对象，类是java.long,Class类的实例对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Foo foo1 = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="comment">//任何一个类都是Class的实例对象，三种表示方式</span></span><br><span class="line"><span class="comment">//1.实际告诉我们任何一个类都有一个隐含的静态成员变量class</span></span><br><span class="line">Class c1 = Foo.class;</span><br><span class="line"><span class="comment">//2.已知该类的对象通过getClass方法</span></span><br><span class="line">Class c2 = foo1.getClass();</span><br><span class="line"><span class="comment">/* c1,c2 表示l了Foo类的类类型（class type）*/</span></span><br><span class="line"><span class="comment">//3.</span></span><br><span class="line">Class c3 = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">c3 = Class.forName(<span class="string">&quot;com.imooc.reflect.Foo&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(Expection e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//c1 == c2 == c3  true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//我们可以通过类的类类型创建该类的实例对象---&gt;</span></span><br><span class="line">Foo foo = (Foo) c1.newInstance()<span class="comment">//需要有无参的构造方法</span></span><br></pre></td></tr></table></figure>

<h5 id="Class-类"><a href="#Class-类" class="headerlink" title="Class 类"></a>Class 类</h5><p>3)编译时刻加载类是静态加载类、运行时刻加载类是动态加载类</p>
<p>//new 创建对象 是 静态加载类， 在编译时刻就需要加载所有可能使用到的类。</p>
<p>//通过动态加载类 解决</p>
<p>Class  c = Class.forName(“类的全称”);</p>
<p>4)基本数据类型，void关键字 都存在类类型</p>
<p>5）Class类的基本API操作</p>
<p>c.getName();</p>
<p>Method[] ms = c.getMethods();//获取所有的public的方法，包括父类继承而来的</p>
<p>c.getDeclaredMethods(); //获取所有该类自己声明的方法，不问访问权限</p>
<p>Class returnType = ms[i].getReturnType();//得到返回值类型的类类型</p>
<p>Class[] paramTypes = ms[i].getParameterTypes();//获取参数类型—&gt;得到的是参数列表的类型的类类型</p>
<p>Field[] fs = c.getFields();//获取所有public 成员变量</p>
<p>c.getDeclaredFields();//获取自己声明的成员变量</p>
<p>Constructor[] cs = c.getConstructors();//获取所有public构造方法</p>
<p>Constructor[] cs = c.getDeclaredConstructors();</p>
<h5 id="方法的反射"><a href="#方法的反射" class="headerlink" title="方法的反射"></a>方法的反射</h5><p>方法的名称和方法的参数列表唯一决定某个方法</p>
<p>method.invoke(对象,参数列表)</p>
<p>Method m = c.getMethod(“print”,new Class[]{int.class,int.class});</p>
<p>Method m = c.getMethod(“print”,int.class,int.class);</p>
<p>方法的反射操作：用m对象来进行方法调用和a1.print调用效果完全相同</p>
<p>//方法如果没有返回值返回null,有返回值返回具体返回值</p>
<p>Object o =m.invoke(a1,new Object[]{10,20});</p>
<p>Object o = m.invoke(a1,10,20);</p>
<h5 id="通过Class，Method-来认识泛型的本质"><a href="#通过Class，Method-来认识泛型的本质" class="headerlink" title="通过Class，Method 来认识泛型的本质"></a>通过Class，Method 来认识泛型的本质</h5><p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1610872983917.png" alt="1610872983917"></p>
<p>验证：我们可以通过方法的反射来操作，绕过编译</p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1610873205553.png" alt="1610873205553"></p>
<h4 id="Java-Web过滤器（Servlet-2-5）已过时"><a href="#Java-Web过滤器（Servlet-2-5）已过时" class="headerlink" title="Java Web过滤器（Servlet 2.5）已过时"></a>Java Web过滤器（Servlet 2.5）已过时</h4><p>过滤用户请求</p>
<p>过滤器是一个服务器端的组件，它可以截取用户端的请求与响应信息，并对这些信息过滤。</p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1610965357869.png" alt="1610965357869"></p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1610965420060.png" alt="1610965420060"></p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1610971348411.png" alt="1610971348411"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//重定向  地址会改变</span></span><br><span class="line">response2.sendRedirect(req.getContextPath()+<span class="string">&quot;/main.jsp&quot;</span>);</span><br><span class="line"><span class="comment">//转发    地址不变</span></span><br><span class="line">req.getRequestDispatcher(<span class="string">&quot;main.jsp&quot;</span>).forward(request, response);</span><br></pre></td></tr></table></figure>

<p>过滤器的分类</p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1610974176443.png" alt="1610974176443"></p>
<h5 id="Servlet-3-0-直接注释"><a href="#Servlet-3-0-直接注释" class="headerlink" title="Servlet (3.0) 直接注释"></a>Servlet (3.0) 直接注释</h5><p>@WebFilter(filterName = “FirstFilter”,value = {“/index.jsp”},dispatcherTypes = {DispatcherType.ASYNC,DispatcherType.REQUEST})</p>
]]></content>
      <tags>
        <tag>后端</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>后端|Mybatis</title>
    <url>/2021/02/03/ben-ke-bi-she-qi-jian-ji-lu-bi-ji/mybatis/</url>
    <content><![CDATA[<p>1.添加Mybatis坐标</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>2.创建user数据表</p>
<p>3.编写User实体类</p>
<p>4.编写映射文件UserMapper.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;userMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;domain.User&quot;</span>&gt;</span></span><br><span class="line">        select * from user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>5.编写核心文件SqlMapConfig.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配数据源环境--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/user?characterEncoding=utf-8&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--加载映射文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mapper/UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>6.编写测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//获得核心配置文件</span></span><br><span class="line">    InputStream resourceAsStream = Resources.getResourceAsStream(<span class="string">&quot;sqlMapConfig.xml&quot;</span>);</span><br><span class="line">    <span class="comment">//获得session工厂对象</span></span><br><span class="line">    SqlSessionFactory sessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(resourceAsStream);</span><br><span class="line">    <span class="comment">//获得session回话对象</span></span><br><span class="line">    SqlSession sqlSession = sessionFactory.openSession();</span><br><span class="line">    <span class="comment">//执行操作 参数：namespace + id</span></span><br><span class="line">    List&lt;User&gt; userList = sqlSession.selectList(<span class="string">&quot;userMapper.findAll&quot;</span>);</span><br><span class="line">    <span class="comment">//打印数据</span></span><br><span class="line">    System.out.println(userList);</span><br><span class="line">    <span class="comment">//释放资源</span></span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="插入操作注意问题·插入语句使用insert标签"><a href="#插入操作注意问题·插入语句使用insert标签" class="headerlink" title="插入操作注意问题·插入语句使用insert标签"></a>插入操作注意问题·插入语句使用insert标签</h5><p>在映射文件中使用parameterType属性指定要插入的数据类型.</p>
<p> Sql语句中使用#{实体属性名}方式引用实体中的属性值</p>
<p>插入操作使用的API是sqlSession.insert(“命名空间.id”,实体对象);</p>
<p>插入操作涉及数据库数据变化，所以要使用sqISession对象显示的提交事务，</p>
<p>即sqlSession.commit()</p>
<h4 id="Mybatis核心配置文件"><a href="#Mybatis核心配置文件" class="headerlink" title="Mybatis核心配置文件"></a>Mybatis核心配置文件</h4><p>1.environments标签<br>其中，事务管理器(transactionManager)类型有两种:<br>JDBC:这个配置就是直接使用了JDBC的提交和回滚设置，它依赖于从数据源得到的连接来管理事务作用域。<br>MANAGED:这个配置几乎没做什么。它从来不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（(比如JEE应用服务器的上下文)。默认情况下它会关闭连接，然而一些容器并不希望这样，因此需要将closeConnection属性设置为false来阻止它默认的关闭行为。</p>
<p>其中，数据源(dataSource）类型有三种:<br>UNPOOLED:这个数据源的实现只是每次被请求时打开和关闭连接。<br>POOLED:这种数据源的实现利用“池”的概念将JDBC连接对象组织起来。<br>JNDI:这个数据源的实现是为了能在如EJB或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个JNDI上下文的引用。</p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1612086812105.png" alt="1612086812105"></p>
<p>3.properties</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--通过properties标签加载外部properties文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;jdbc.properties&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>4.typeAliases标签</p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1612087121874.png" alt="1612087121874"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--自定义别名--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">&quot;domain.User&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;user&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="Mabatis-的dao层实现"><a href="#Mabatis-的dao层实现" class="headerlink" title="Mabatis 的dao层实现"></a>Mabatis 的dao层实现</h4><p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1612090972324.png" alt="1612090972324"></p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1612098382935.png" alt="1612098382935"></p>
<h4 id="动态sql"><a href="#动态sql" class="headerlink" title="动态sql"></a>动态sql</h4><h5 id="if"><a href="#if" class="headerlink" title="if"></a>if</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findByCondition&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    select * from user</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;id!=0&quot;</span>&gt;</span></span><br><span class="line">            and id = #&#123;id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username!=null&quot;</span>&gt;</span></span><br><span class="line">            and username = #&#123;username&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;password!=null&quot;</span>&gt;</span></span><br><span class="line">            and password = #&#123;password&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findByIds&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">    select * from user</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span> <span class="attr">open</span>=<span class="string">&quot;id in (&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">            #&#123;id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="sql语句抽取"><a href="#sql语句抽取" class="headerlink" title="sql语句抽取"></a>sql语句抽取</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--sql语句抽取--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;selectUser&quot;</span>&gt;</span>select * from user<span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findByCondition&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;selectUser&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="Mybatis核心配置文件-1"><a href="#Mybatis核心配置文件-1" class="headerlink" title="Mybatis核心配置文件"></a>Mybatis核心配置文件</h4><p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1612184130364.png" alt="1612184130364"></p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1612185599369.png" alt="1612185599369"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;3.7.5&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;com.github.jsqlparser&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;jsqlparser&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;0.9.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h4 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;orderMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;order&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--手动指定字段与实体属性的映射关系</span></span><br><span class="line"><span class="comment">        column : 数据表的字段名称</span></span><br><span class="line"><span class="comment">        property: 实体的属性名称</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;oid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;ordertime&quot;</span> <span class="attr">property</span>=<span class="string">&quot;ordertime&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;total&quot;</span> <span class="attr">property</span>=<span class="string">&quot;total&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;result column=&quot;uid&quot; property=&quot;user.id&quot;&gt;&lt;/result&gt;</span></span><br><span class="line"><span class="comment">    &lt;result column=&quot;username&quot; property=&quot;user.username&quot;&gt;&lt;/result&gt;</span></span><br><span class="line"><span class="comment">    &lt;result column=&quot;Password&quot; property=&quot;user.password&quot;&gt;&lt;/result&gt;</span></span><br><span class="line"><span class="comment">    &lt;result column=&quot;birthday&quot; property=&quot;user.birthday&quot;&gt;&lt;/result&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        property：当前实体(order)中的属性名称(private User user)</span></span><br><span class="line"><span class="comment">        javaType: 当前实体(order)中的属性的类型(User)</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;user&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;domain.User&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;uid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;username&quot;</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;Password&quot;</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;birthday&quot;</span> <span class="attr">property</span>=<span class="string">&quot;birthday&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;orderMap&quot;</span> &gt;</span></span><br><span class="line">    select * ,o.id oid from orders o ,user u where o.uid = u.id</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;userMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;uid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;username&quot;</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;Password&quot;</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;birthday&quot;</span> <span class="attr">property</span>=<span class="string">&quot;birthday&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置集合信息</span></span><br><span class="line"><span class="comment">        property:集合名称</span></span><br><span class="line"><span class="comment">        ofType:当前集合中的数据类型</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;orderList&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;order&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--封装order的数据--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;oid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;ordertime&quot;</span> <span class="attr">property</span>=<span class="string">&quot;ordertime&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;total&quot;</span> <span class="attr">property</span>=<span class="string">&quot;total&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;userMap&quot;</span> &gt;</span></span><br><span class="line">    select *,o.id oid from user u,orders o where u.id = o.uid</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;userRoleMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--user的信息--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;userId&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;username&quot;</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;password&quot;</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--user内部的roleList的信息--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;roleList&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;domain.Role&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;roleId&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;roleName&quot;</span> <span class="attr">property</span>=<span class="string">&quot;roleName&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;roleDesc&quot;</span> <span class="attr">property</span>=<span class="string">&quot;roleDesc&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findUserAndRoleAll&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;userRoleMap&quot;</span>&gt;</span></span><br><span class="line">    select * from sys_user u,sys_user_role ur ,sys_role r where u.id = ur.userId AND ur.roleId=r.id</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="注解开发"><a href="#注解开发" class="headerlink" title="注解开发"></a>注解开发</h3><p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1612341706528.png" alt="1612341706528"></p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1612344455486.png" alt="1612344455486"></p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1612344473894.png" alt="1612344473894"></p>
]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>后端</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>后端|Spring|SpringAOP</title>
    <url>/2021/01/24/ben-ke-bi-she-qi-jian-ji-lu-bi-ji/springaop/</url>
    <content><![CDATA[<h3 id="SpringAOP"><a href="#SpringAOP" class="headerlink" title="SpringAOP"></a>SpringAOP</h3><p>Aspect Oriented Programming <strong>面向切面编程</strong>，是通过预编译方式和运行期间动态代理实现程序功能的统一维护的一种技术。</p>
<span id="more"></span>

<p>作用：在程序运行期间，在不修改源码的情况下对方法进行功能增强</p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1611462949509.png" alt="1611462949509"></p>
<p>JDKProxy</p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1611477433382.png" alt="1611477433382"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//目标对象</span></span><br><span class="line">    <span class="keyword">final</span> TargetInterfaceImpl target = <span class="keyword">new</span> TargetInterfaceImpl();</span><br><span class="line">    <span class="comment">//增强对象</span></span><br><span class="line">    <span class="keyword">final</span> Advice advice = <span class="keyword">new</span> Advice();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回值 就是动态生成的代理对象</span></span><br><span class="line">    TargetInterface proxy = (TargetInterface) Proxy.newProxyInstance(</span><br><span class="line">            target.getClass().getClassLoader(),<span class="comment">//目标对象类加载器</span></span><br><span class="line">            target.getClass().getInterfaces(),<span class="comment">//目标对象相同的接口字节码对象数组</span></span><br><span class="line">            <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//调用代理对象的任何方法 实质执行的都是invoke方法</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                    advice.before();<span class="comment">//前置增强</span></span><br><span class="line">                    Object invoke = method.invoke(target, args);<span class="comment">//执行目标方法</span></span><br><span class="line">                    advice.afterReturning();<span class="comment">//后置增强</span></span><br><span class="line">                    <span class="keyword">return</span> invoke;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用代理对象的方法</span></span><br><span class="line">    proxy.save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>CglibProxy</p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1611477443403.png" alt="1611477443403"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//目标对象</span></span><br><span class="line">    <span class="keyword">final</span> Target target = <span class="keyword">new</span> Target();</span><br><span class="line">    <span class="comment">//增强对象</span></span><br><span class="line">    <span class="keyword">final</span> Advice advice = <span class="keyword">new</span> Advice();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回值 就是动态生成的代理对象 基于cglib</span></span><br><span class="line">    <span class="comment">//1.创建增强器</span></span><br><span class="line">    Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">    <span class="comment">//2.设置父类（目标）</span></span><br><span class="line">    enhancer.setSuperclass(Target.class);</span><br><span class="line">    <span class="comment">//3.设置回调</span></span><br><span class="line">    enhancer.setCallback(<span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            advice.before();<span class="comment">//前置增强</span></span><br><span class="line">            Object invoke = method.invoke(target, args);<span class="comment">//执行目标方法</span></span><br><span class="line">            advice.afterReturning();<span class="comment">//后置增强</span></span><br><span class="line">            <span class="keyword">return</span> invoke;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//4.创建代理对象</span></span><br><span class="line">    Target proxy = (Target) enhancer.create();</span><br><span class="line">    proxy.save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="AOP相关概念"><a href="#AOP相关概念" class="headerlink" title="AOP相关概念"></a>AOP相关概念</h5><p>Target(目标对象)︰代理的目标对象</p>
<p>Proxy(代理):一个类被AOP织入增强后，就产生一个结果代理类</p>
<p>Joinpoint(连接点)∶所谓连接点是指那些被拦截到的点。在spring中,这些点指的是方法，因为spring只支持方法类型的连接点。<strong>可以被增强的方法叫连接点</strong></p>
<p>Pointcut(切入点)︰所谓切入点是指我们要对哪些Joinpoint进行拦截的定义。<strong>真正被增强了</strong></p>
<p>Advice (通知/增强)︰所谓通知是指拦截到Joinpoint之后所要做的事情就是通知</p>
<p>Aspect(切面)︰是切入点和通知(引介)的结合</p>
<p>Weaving (织入)︰是指把增强应用到目标对象来创建新的代理对象的过程。spring采用动态代理织入，而AspectU采用编译期织入和类装载期织入 。 （将切点和通知连接的过程就是织入）</p>
<h5 id="AOP开发明确的事项"><a href="#AOP开发明确的事项" class="headerlink" title="AOP开发明确的事项"></a>AOP开发明确的事项</h5><p>1.需要编写的内容</p>
<p>编写核心业务代码(目标类的目标方法)</p>
<p>编写切面类，切面类中有通知(增强功能方法)</p>
<p>在配置文件中，配置织入关系，即将哪些通知与哪些连接点进行结合</p>
<p>2.AOP技术实现的内容</p>
<p>Spring框架监控切入点方法的执行。一旦监控到切入点方法被运行，使用代理机制，动态创建目标对象的代理对</p>
<p>象，根据通知类别，在代理对象的对应位置，将通知对应的功能织入，完成完整的代码逻辑运行。</p>
<p>3.AOP底层使用哪种代理方式</p>
<p>在spring中，框架会根据目标类是否实现了接口来决定采用哪种动态代理的方式。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>aop:面向切面编程</p>
<p>aop底层实现:基于JDK的动态代理和基于Cglib的动态代理</p>
<p>aop的重点概念：<br>Pointcut(切入点)：被增强的方法</p>
<p>Advice(通知/增强)：封装增强业务逻辑的方法</p>
<p>Aspect(切面)：切点+通知</p>
<p>Weaving(织入)：将切点与通知结合的过程</p>
<p>开发明确事项:<br>谁是切点(切点表达式配置)<br>谁是通知(切面类中的增强方法)<br>将切点和通知进行织入配置</p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1611492063573.png" alt="1611492063573"></p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1611492162810.png" alt="1611492162810"></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>后端</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>后端|Spring Boot|Spring Boot入门</title>
    <url>/2021/03/06/ben-ke-bi-she-qi-jian-ji-lu-bi-ji/springboot-ru-men/</url>
    <content><![CDATA[<h2 id="1-Spring-Boot概述"><a href="#1-Spring-Boot概述" class="headerlink" title="1.Spring Boot概述"></a>1.Spring Boot概述</h2><p>目的：了解Spring Boot是什么，有什么作用</p>
<p>小结:</p>
<p>Spring Boot 是一个便捷搭建基于Spring工程的脚手架；作用是帮助开发人员快速搭建大型java项目。简化工程配置，依赖管理；实现开发人员把时间都集中在业务开发上。</p>
<span id="more"></span>

<h2 id="2-Spring-Boot入门"><a href="#2-Spring-Boot入门" class="headerlink" title="2.Spring Boot入门"></a>2.Spring Boot入门</h2><p>目的:能够使用Spring Boot搭建项目</p>
<p>分析:</p>
<p>需求：可以在浏览器访问<a href="http://localhost:8080/hello">http://localhost:8080/hello</a> 输出一串字符</p>
<p>实现步骤：</p>
<p>1.创建工程；</p>
<p>2.添加依赖(启动器依赖，spring-boot-starter-web)；</p>
<p>3.创建启动类；</p>
<p>4.创建处理器Controller；</p>
<p>5.测试</p>
<p>注意：程序默认只加载Application.java所在包及其子包下的内容，所以，编写的controller类需要和Application.java在同一个包里面才行，把文件移动到相应的包里面就可以成功了 </p>
<p>小结：</p>
<p>Spring Boot工程可以通过添加启动器依赖和创建启动引导类实现快速创建web工程。</p>
<blockquote>
<p>spring-boot-starter-web默认的应用服务器端口是8080</p>
</blockquote>
<h2 id="3-Java代码方式配置"><a href="#3-Java代码方式配置" class="headerlink" title="3.Java代码方式配置"></a>3.Java代码方式配置</h2><p>目标：可以使用@Value获取配置文件配置项并结合@Bean注册组件到Spring</p>
<p>分析：</p>
<p>需求：使用Java代码配置数据库连接池，并可在处理器中注入并使用</p>
<p>步骤：</p>
<p>1.添加依赖；</p>
<p>2.创建数据库；</p>
<p>3.创建数据库连接参数的配置文件jdbc.properties;</p>
<p>4.创建配置类；</p>
<p>5.改造处理器类注入数据源并使用</p>
<p>小结：</p>
<p>JdbcConfig.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> itheima.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.PropertySource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    String url;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span></span><br><span class="line">    String driver;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">    String username;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="line">    String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        DruidDataSource dataSource = <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">        dataSource.setDriverClassName(driver);</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        dataSource.setUsername(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-Spring-Boot属性注入方式"><a href="#4-Spring-Boot属性注入方式" class="headerlink" title="4.Spring Boot属性注入方式"></a>4.Spring Boot属性注入方式</h2><p>目标：能够使用@ConfigurationProperties实现SpringBoot配置文件配置项读取和应用</p>
<p>分析：</p>
<p>需求：将配置文件中的配置项读取到一个对象中；</p>
<p>实现：可以使用Spring Boot提供的注解@ConfigurationProperties，该注解可以将SpringBoot的配置文件（默认必须为application.properties或application.yml)中的配置项读取到一个对象中。</p>
<p>实现步骤：</p>
<p>1.创建配置项类JdbcProperties类，在该类名上添加@ConfigurationProperties；</p>
<p>2.将jdbc.properties修改名称为application.properties;</p>
<p>3.将JdbcProperties对象注入到JdbcConfig；</p>
<p>4.测试</p>
<p>小结：</p>
<ul>
<li><p>使用@ConfigurationProperties编写配置项类将配置文件中的配置项设置到对象中</p>
<p>JdbcProperties.java</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ConfigurationProperties 从application配置文件中读取配置项</span></span><br><span class="line"><span class="comment"> * prefix 表示配置项前缀</span></span><br><span class="line"><span class="comment"> * 配置项类中的类变量名必须要与配置前缀之后的配置项名称保存 松散绑定（相同）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;jdbc&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcProperties</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUrl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUrl</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDriver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> driver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDriver</span><span class="params">(String driver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.driver = driver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JdbcConfig.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableConfigurationProperties(JdbcProperties.class)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>使用@ConfigurationProperties在方法上面使用</p>
<p>  @Bean<br>  @ConfigurationProperties(prefix = “jdbc”)<br>  public DataSource dataSource() {<br>  return new DruidDataSource();<br>  }<br>注意：要保证application.properties与数据源的set方法字段符合 松散绑定</p>
</li>
</ul>
<h2 id="5-多个yml配置文件"><a href="#5-多个yml配置文件" class="headerlink" title="5.多个yml配置文件"></a>5.多个yml配置文件</h2><p>目标：可以将多个yml文件在application.yml文件中配置激活</p>
<p>分析：</p>
<p>yaml与properties配置文件除了展示形式不相同之外，其他功能和作用都是一样的；在项目中原路的读取方式不变。</p>
<p>1）yml配置文件的特征：</p>
<p>​    1.树状层级结构展示配置项；</p>
<p>​    2.配置项之间如果有关系的话需要分行空两格；</p>
<p>​    3.配置项如果有值的话，那么需要在 ： 后空一格再写配置项值；</p>
<p>将application.properties 配置文件修改为application.yml的话:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">jdbc:</span></span><br><span class="line">  <span class="attr">driverClassName:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/springboot?characterEncoding=utf-8</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">  <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">key:</span></span><br><span class="line">  <span class="attr">abc:</span> <span class="string">cba</span></span><br><span class="line">  <span class="attr">def:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="string">g</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">h</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">j</span></span><br></pre></td></tr></table></figure>



<p>2）多个yml配置文件；在spring boot中是被允许的。这些配置文件的名称必须为application-***.yml，并且这些配置文件b必须要在application.yml配置文件中激活之后才能使用。</p>
<p>3）如果properties文件和yml配置文件同时存在spring boot 项目中；那么这两类配置文件都有效。在两个配置文件中如果存在同名配置项会以properites文件的为主。</p>
<p>小结：</p>
<p>在多个配置文件时，需要将这些文件在application.yml中进行激活：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#激活配置文件 ;需要指定其他的配置文件名称</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">abc,def</span></span><br></pre></td></tr></table></figure>

<h2 id="6-自动配置原理"><a href="#6-自动配置原理" class="headerlink" title="6.自动配置原理"></a>6.自动配置原理</h2><p>目标：了解Spring Boot项目的配置加载流程</p>
<p>小结：</p>
<ul>
<li>在META-INF\spring.fatories文件中定义了很多自动配置类；可以根据pom.xml文件中添加的启动器依赖 自动配置组件<ul>
<li>通过如下流程可以去修改application配置文件，改变自动配置的组件默认参数</li>
<li><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1615012601846.png" alt="1615012601846"></li>
</ul>
</li>
</ul>
<h2 id="7-lombok应用"><a href="#7-lombok应用" class="headerlink" title="7.lombok应用"></a>7.lombok应用</h2><p>目标:使用lombok的注解实现pojo类的简化</p>
<p>分析：</p>
<p>使用Spring Boot整合SSM工程；需要使用到数据库数据。</p>
<ul>
<li><p>将数据库表数据导入到数据库中（springboot)</p>
</li>
<li><p>编写数据库表对应的实体类；一般情况下需要编写get/set/toString等这些方法会耗时并且会让实体类看起来比较臃肿。可以使用lombok插件对实体类进行简化。</p>
<p>lombok是一个插件工具类包；提供了一些注解@Data、@Getter等这些注解去简化实体类中的构造方法、get/set等方法的编写。</p>
<p>1.在IDEA中安装lombok插件；</p>
<p>2.添加lombok对应的依赖到项目pom.xml文件；</p>
<p>3.改造实体类使用lombok注解。</p>
</li>
</ul>
<p>小结：</p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1615013867741.png" alt="1615013867741"></p>
<h2 id="8-Spring-Boot整合-SpringMVC端口和静态资源"><a href="#8-Spring-Boot整合-SpringMVC端口和静态资源" class="headerlink" title="8.Spring Boot整合-SpringMVC端口和静态资源"></a>8.Spring Boot整合-SpringMVC端口和静态资源</h2><p>目标：可以修改tomcat端口和访问项目中的静态资源</p>
<p>分析:</p>
<ul>
<li><p>修改tomcat端口</p>
<p>查询**Properties，设置配置项(前缀+类变量名)到application配置文件中</p>
</li>
<li><p>访问项目的静态资源</p>
<p>静态资源放置的位置；放置静态资源并访问这些资源</p>
</li>
</ul>
<p>小结:</p>
<p>修改项目tomcat端口：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#tomcat端口修改</span><br><span class="line">server:</span><br><span class="line">  port: 8009</span><br></pre></td></tr></table></figure>

<p>在Spring boot项目中静态资源  可以放置在 如下目录：</p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1615016869658.png" alt="1615016869658"></p>
<h2 id="9-Spring-Boot整合-SpringMVC拦截器"><a href="#9-Spring-Boot整合-SpringMVC拦截器" class="headerlink" title="9.Spring Boot整合-SpringMVC拦截器"></a>9.Spring Boot整合-SpringMVC拦截器</h2><p>目标：可以在Spring Boot项目中配置自定义SpringMVC    拦截器</p>
<p>分析：</p>
<p>​    1.编写拦截器（实现HandlerInterceptor）；</p>
<p>​    2.编写配置类WebMvcConfigurer，在该类中添加各种组件</p>
<p>​    3.测试</p>
<p>小结：</p>
<p>可以在Spring Boot项目中 通过配置类添加各种组件；如果要添加拦截器的话</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MvcConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//注册拦截器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyInterceptor <span class="title">myInterceptor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyInterceptor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加拦截器到spring mvc拦截器链</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addInterceptor(myInterceptor()).addPathPatterns(<span class="string">&quot;/*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-Spring-Boot整合-事务和连接池"><a href="#10-Spring-Boot整合-事务和连接池" class="headerlink" title="10.Spring Boot整合-事务和连接池"></a>10.Spring Boot整合-事务和连接池</h2><p>目标：配置Spring Boot自带默认的hikari数据库连接池和使用@Transactional注解进行事务配置</p>
<p>分析：</p>
<ul>
<li><p>事务配置</p>
<p>1.添加事务相关的启动器依赖，mysql相关依赖；</p>
<p>2.编写业务类UserService使用事务注解@Transactional</p>
</li>
<li><p>数据库连接池hikari配置</p>
<p>只需要在application配置文件中指定数据库相关参数</p>
</li>
</ul>
<p>小结：</p>
<ul>
<li>事务配置只需要添加jdbc启动器依赖</li>
<li>数据库连接池使用默认的hikari,在配置文件中配置如下：</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/springboot?characterEncoding=utf-8</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br></pre></td></tr></table></figure>

<h2 id="11-Spring-Boot整合-Mybatis"><a href="#11-Spring-Boot整合-Mybatis" class="headerlink" title="11.Spring Boot整合-Mybatis"></a>11.Spring Boot整合-Mybatis</h2><p>目标：配置Mybatis在Spring Boot工程中的整合包，设置Mybatis的实体类别名，输出执行sql语句配置项</p>
<p>分析：</p>
<p>1.添加启动器依赖；</p>
<p>2.配置Mybatis：实体类别名包，日志，映射文件等；</p>
<p>3.配置MapperScan</p>
<p>小结：</p>
<ul>
<li>添加Mybatis官方对 Spring Boot的一个启动器</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.0.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>配置Mybatis</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mybatis:</span><br><span class="line">  # 实体类别名包路径</span><br><span class="line">  type-aliases-package: itheima.pojo</span><br><span class="line">#  映射文件路径</span><br><span class="line">#  mapper-locations: classpath:mappers/*.xml</span><br><span class="line">  configuration:</span><br><span class="line">    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl</span><br></pre></td></tr></table></figure>

<ul>
<li>设置启动器类中的Mapper扫描</li>
</ul>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1615019452544.png" alt="1615019452544"></p>
<h2 id="12-Spring-Boot整合-通用Mapper"><a href="#12-Spring-Boot整合-通用Mapper" class="headerlink" title="12.Spring Boot整合-通用Mapper"></a>12.Spring Boot整合-通用Mapper</h2><p>目标：配置通用Mapper组件到Spring Boot项目中并使用Mapper&lt;T&gt;接口</p>
<p>分析：</p>
<p>通用Mapper：可以实现自动拼接sql语句；所有的mapper都不需要编写任何方法也就是不用编写sql语句。可以提高开发效率。</p>
<p>1.添加启动器依赖；</p>
<p>2.改造UserMapper继承Mapper&lt;User&gt;；</p>
<p>3.修改启动引导类Application中的Mapper扫描注解;</p>
<p>4.修改User实体类添加jpa注解；</p>
<p>5.改造UserService实现业务功能；</p>
<p>小结：</p>
<p>在启动引导类上面的mapper扫描注解 一定要修改为 通用mapper的扫描注解</p>
<h2 id="13-Spring-Boot整合测试"><a href="#13-Spring-Boot整合测试" class="headerlink" title="13.Spring Boot整合测试"></a>13.Spring Boot整合测试</h2><p>目标：可以访问处理器对应路径将数据库中的数据根据id查询</p>
<p>分析：</p>
<p>1.改造HelloController，注入UserService利用其方法实现查询</p>
<p>2.启动项目进行测试 <a href="http://localhost:8009/user/%E7%94%A8%E6%88%B7id">http://localhost:8009/user/用户id</a></p>
<p>小结：</p>
<p>修改了HelloController：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">queryById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> userService.queryById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="14-Spring-Boot整合-Junit"><a href="#14-Spring-Boot整合-Junit" class="headerlink" title="14.Spring Boot整合-Junit"></a>14.Spring Boot整合-Junit</h2><p>目标：在Spring Boot项目中使用Junit进行单元测试UserService的方法</p>
<p>分析：</p>
<p>1.添加启动器依赖spring-boot-starter-test;</p>
<p>2.编写测试类</p>
<p>小结：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queryById</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = userService.queryById(<span class="number">2L</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;user = &quot;</span> + user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setUserName(<span class="string">&quot;test2&quot;</span>);</span><br><span class="line">        user.setName(<span class="string">&quot;test2&quot;</span>);</span><br><span class="line">        user.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        user.setAge(<span class="number">18</span>);</span><br><span class="line">        user.setSex(<span class="number">2</span>);</span><br><span class="line">        user.setCreated(<span class="keyword">new</span> Date());</span><br><span class="line">        userService.saveUser(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在Spring Boot项目中如果编写测试类则必须要在类上面添加@SpringBootTest</p>
</blockquote>
<h2 id="15-Spring-Boot整合-redis"><a href="#15-Spring-Boot整合-redis" class="headerlink" title="15.Spring Boot整合-redis"></a>15.Spring Boot整合-redis</h2><p>目标：在Spring Boot项目中使用Junit进行测试RedisTemplate</p>
<p>分析：</p>
<p>1.添加启动器依赖spring-boot-starter-data-redis;</p>
<p>2.配置application.yml中修改redis的连接参数;(redis需要启动)</p>
<p>3.编写测试类应用RedisTemplate操作redis中的5种数据类型（string/hash/list/set/sorted set）</p>
<p>小结：</p>
<h2 id="15-Spring-Boot项目部署"><a href="#15-Spring-Boot项目部署" class="headerlink" title="15.Spring Boot项目部署"></a>15.Spring Boot项目部署</h2><p>目标：将Spring Boot项目使用Maven指令打成jar包并运行测试</p>
<p>分析：</p>
<p>1.添加打包组件将项目中资源、配置、依赖包打到一个jar包中；可以使用maven的 package ；</p>
<p>2.部署：java -jar 包名</p>
<p>小结：</p>
<ul>
<li>添加打包组件</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 打jar 包时如果不配置该插件，打出来的jar包没有清单文件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>部署运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -jar 包名</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>后端</tag>
        <tag>Spring</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>后端|SpringMVC</title>
    <url>/2021/03/06/ben-ke-bi-she-qi-jian-ji-lu-bi-ji/springmvc/</url>
    <content><![CDATA[<h3 id="Spring集成Web环境"><a href="#Spring集成Web环境" class="headerlink" title="Spring集成Web环境"></a>Spring集成Web环境</h3><p>1.配置ContextLoaderListener监听器</p>
<span id="more"></span>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--全局初始化参数--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置监听器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.使用WebApplicationContextUtils获得应用上下文</p>
<h3 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h3><p><em><strong><u>F:\java_code\heima_SpringMVC</u></strong></em></p>
<p>SpringMVC开发步骤</p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1611656050360.png" alt="1611656050360"></p>
<p>需求:客户端发起请求，服务器端接受请求，执行逻辑并进行试图跳转。</p>
<p>1.导入SpringMVC相关坐标</p>
<p>2.配置SpringMVC核心控制器DispatcherServlet<strong>（⭐）</strong></p>
<p>web.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring-mvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>3.创建Controller类和视图界面</p>
<p>4.使用注解配置Controller类中业务方法的映射地址</p>
<p>5.配置SpringMVC核心文件spring-mvc.xml</p>
<p>6.客户端发起请求测试 </p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1611737421344.png" alt="1611737421344"></p>
<p>1.用户发送请求至前端控制器DispatcherServlet。</p>
<p>2.DispatcherServlet收到请求调用HandlerMapping处理器映射器。</p>
<p>3.处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果</p>
<p>有则生成)一并返回给DispatcherServlet.</p>
<p>4.DispatcherServlet调用HandlerAdapter处理器适配器。</p>
<p>5.HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。</p>
<p>6.Controller执行完成返回ModelAndView。</p>
<p>7.HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet.</p>
<p>8.DispatcherServlet将ModelAndView传给ViewReslover视图解析器。</p>
<p>9.ViewReslover解析后返回具体View。</p>
<p>10.DispatcherServlet根据View进行渲染视图(即将模型数据填充至视图中)。DispatcherServlet响应用户。</p>
<h4 id="xml试图解析器"><a href="#xml试图解析器" class="headerlink" title="xml试图解析器"></a>xml试图解析器</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置内部资源视图解析器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;viewResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--/jsp/success.jsp--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/jsp/&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>重定向前缀：redirect:</p>
<p>转发前缀(默认值)：forward:</p>
<h4 id="SpringMVC的数据响应方式"><a href="#SpringMVC的数据响应方式" class="headerlink" title="SpringMVC的数据响应方式"></a>SpringMVC的数据响应方式</h4><h5 id="1）页面跳转"><a href="#1）页面跳转" class="headerlink" title="1）页面跳转"></a>1）页面跳转</h5><p>直接返回字符串</p>
<p>同上</p>
<p>Controller 层 部分代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/quick&quot;,method = RequestMethod.GET)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">save</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;UserController.save&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过ModelAndView对象返回</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/quick2&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">save2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Model:模型 封装数据</span></span><br><span class="line"><span class="comment">        View:视图 展示数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ModelAndView modelAndView = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">    <span class="comment">//设置模型数据</span></span><br><span class="line">    modelAndView.addObject(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">    <span class="comment">//设置视图名称</span></span><br><span class="line">    modelAndView.setViewName(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> modelAndView;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/quick3&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">save3</span><span class="params">(ModelAndView modelAndView)</span></span>&#123;</span><br><span class="line">    modelAndView.addObject(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;itheima&quot;</span>);</span><br><span class="line">    modelAndView.setViewName(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> modelAndView;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/quick4&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">save4</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">    model.addAttribute(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;save4&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4.    不建议。不常用</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/quick5&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">save5</span><span class="params">(HttpServletRequest request)</span></span>&#123;</span><br><span class="line">    request.setAttribute(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;save5&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2）回写数据"><a href="#2）回写数据" class="headerlink" title="2）回写数据"></a>2）回写数据</h5><p>直接返回字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/quick6&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save6</span><span class="params">(HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    response.getWriter().println(<span class="string">&quot;hello itcast&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/quick7&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span><span class="comment">//告知SpringMVC框架 该方法不进行视图跳转，直接进行数据响应</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">save7</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello save7&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/quick8&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span><span class="comment">//告知SpringMVC框架 该方法不进行视图跳转，直接进行数据响应</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">save8</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&#123;\&quot;username\&quot;:\&quot;zhangsan\&quot;,\&quot;age\&quot;:18&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/quick9&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span><span class="comment">//告知SpringMVC框架 该方法不进行视图跳转，直接进行数据响应</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">save9</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setName(<span class="string">&quot;lili&quot;</span>);</span><br><span class="line">    user.setAge(<span class="number">30</span>);</span><br><span class="line">    <span class="comment">//使用JSON的转换工具，将对象转换成JSON格式字符串 再返回</span></span><br><span class="line">    ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">    String json = objectMapper.writeValueAsString(user);</span><br><span class="line">    <span class="keyword">return</span> json;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回对象和集合</p>
<p>pom.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Controller</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/quick10&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span><span class="comment">//告知SpringMVC框架 该方法不进行视图跳转，直接进行数据响应</span></span><br><span class="line"><span class="comment">//期望SpringMVC自动将User转换成一个JSON格式的字符串 (配置)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">save10</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setName(<span class="string">&quot;lili&quot;</span>);</span><br><span class="line">    user.setAge(<span class="number">30</span>);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>spring-mvc.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置处理器映射器--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;bean id=&quot;&quot; class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;&gt;</span></span><br><span class="line"><span class="comment">     &lt;property name=&quot;messageConverters&quot;&gt;</span></span><br><span class="line"><span class="comment">         &lt;list&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">             &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;/&gt;</span></span><br><span class="line"><span class="comment">         &lt;/list&gt;</span></span><br><span class="line"><span class="comment">     &lt;/property&gt;</span></span><br><span class="line"><span class="comment"> &lt;/bean&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!--mvc注解驱动--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br></pre></td></tr></table></figure>


<h4 id="SpringMVC获得请求参数"><a href="#SpringMVC获得请求参数" class="headerlink" title="SpringMVC获得请求参数"></a>SpringMVC获得请求参数</h4><h5 id="基本类型参数"><a href="#基本类型参数" class="headerlink" title="基本类型参数"></a>基本类型参数</h5><p>Controller中的业务方法的参数名称与请求参数的name一致，参数值会自动映射匹配</p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1611820502814.png" alt="1611820502814"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/quick11&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span><span class="comment">//告知SpringMVC框架 该方法不进行视图跳转，直接进行数据响应</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save11</span><span class="params">(String username,Integer age)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;username = &quot;</span> + username);</span><br><span class="line">    System.out.println(<span class="string">&quot;age = &quot;</span> + age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="POJO类型参数-简单JavaBean"><a href="#POJO类型参数-简单JavaBean" class="headerlink" title="POJO类型参数(简单JavaBean)"></a>POJO类型参数(简单JavaBean)</h5><p>Controller中的业务方法的POJO参数与请求参数的name一致，参数值会自动映射匹配</p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1611820747248.png" alt="1611820747248"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/quick12&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span><span class="comment">//告知SpringMVC框架 该方法不进行视图跳转，直接进行数据响应</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save12</span><span class="params">(User user)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;user = &quot;</span> + user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="数组类型参数"><a href="#数组类型参数" class="headerlink" title="数组类型参数"></a>数组类型参数</h5><p>Controller中的业务方法的数组名称与请求参数的name一致，参数值会自动映射匹配</p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1611820916874.png" alt="1611820916874"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/quick13&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span><span class="comment">//告知SpringMVC框架 该方法不进行视图跳转，直接进行数据响应</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save13</span><span class="params">(String[] strings)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Arrays.asList(strings) = &quot;</span> + Arrays.asList(strings));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="集合类型参数（1）"><a href="#集合类型参数（1）" class="headerlink" title="集合类型参数（1）"></a>集合类型参数（1）</h5><p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1611821783523.png" alt="1611821783523"></p>
<p>Controller</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/quick14&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span><span class="comment">//告知SpringMVC框架 该方法不进行视图跳转，直接进行数据响应</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save14</span><span class="params">(VO vo)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;vo = &quot;</span> + vo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>VO.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;User&gt; userList;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getUserList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserList</span><span class="params">(List&lt;User&gt; userList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userList = userList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;VO&#123;&quot;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;userList=&quot;</span>).append(userList);</span><br><span class="line">        sb.append(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="集合类型参数（2）"><a href="#集合类型参数（2）" class="headerlink" title="集合类型参数（2）"></a>集合类型参数（2）</h5><p>当使用ajax提交时，可以指定contentType为json形式，那么在方法参数位置使用@RequestBody可以直接接收集合数据而无需使用POJO进行包装。</p>
<p>ajax.jsp</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/js/jquery-3.3.1.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">   <span class="keyword">var</span> userList = <span class="keyword">new</span> Array();</span><br><span class="line">   userList.push(&#123;username:<span class="string">&quot;zhangsan&quot;</span>,age:<span class="number">18</span>&#125;);</span><br><span class="line">   userList.push(&#123;username:<span class="string">&quot;lisi&quot;</span>,age:<span class="number">28</span>&#125;);</span><br><span class="line"></span><br><span class="line">   $.ajax(&#123;</span><br><span class="line">      type:<span class="string">&quot;POST&quot;</span>,</span><br><span class="line">      url:<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/user/quick15&quot;</span>,</span><br><span class="line">      data:JSON.stringify(userList),</span><br><span class="line">      contentType:<span class="string">&quot;application/json;charset=utf-8&quot;</span> </span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>Controller</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/quick15&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span><span class="comment">//告知SpringMVC框架 该方法不进行视图跳转，直接进行数据响应</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save15</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;User&gt; userList)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;userList = &quot;</span> + userList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>spring-mvc.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/js/**&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/js/&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="静态资源访问的开启（⭐）"><a href="#静态资源访问的开启（⭐）" class="headerlink" title="静态资源访问的开启（⭐）"></a>静态资源访问的开启<strong>（⭐）</strong></h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--开放资源的访问  1.--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;mvc:resources mapping=&quot;/js/**&quot; location=&quot;/js/&quot;/&gt;</span></span><br><span class="line"><span class="comment">&lt;mvc:resources mapping=&quot;/img/**&quot; location=&quot;/img/&quot;/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--              2. --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="请求数据乱码问题"><a href="#请求数据乱码问题" class="headerlink" title="请求数据乱码问题"></a>请求数据乱码问题</h4><p>web.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置全局过滤filter--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="参数绑定注解-RequestParam"><a href="#参数绑定注解-RequestParam" class="headerlink" title="参数绑定注解@RequestParam"></a>参数绑定注解@RequestParam</h4><p>当请求的参数名称与Controller的业务方法参数名称不一致时，就需要通过@RequestParam注解显式的绑定</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/quick16&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span><span class="comment">//告知SpringMVC框架 该方法不进行视图跳转，直接进行数据响应</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save16</span><span class="params">(<span class="meta">@RequestParam(value = &quot;name&quot;)</span> String username)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;username = &quot;</span> + username);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//localhost:8009/heima_Spring_MVC/user/quick17/zhangsan</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/quick17/&#123;username&#125;&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span><span class="comment">//告知SpringMVC框架 该方法不进行视图跳转，直接进行数据响应</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save17</span><span class="params">(<span class="meta">@PathVariable(value = &quot;username&quot;)</span> String username)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;username = &quot;</span> + username);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="获取Restful风格的参数"><a href="#获取Restful风格的参数" class="headerlink" title="获取Restful风格的参数"></a>获取Restful风格的参数</h4><p>Restful是一种软件架构风格、设计风格，而不是标准，只是提供了一组设计原则和约束条件。主要用于客户端和服务器交互类的软件，基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存机制等。</p>
<p>Restful风格的请求是使用“url+请求方式”表示一次请求目的的，HTTP协议里面四个表示操作方式的动词如下:</p>
<p>GET:用于获取资源</p>
<p>POST:用于新建资源</p>
<p>PUT:用于更新资源</p>
<p>DELETE:用于删除资源</p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1611830382522.png" alt="1611830382522"></p>
<h4 id="自定义类型转换器"><a href="#自定义类型转换器" class="headerlink" title="自定义类型转换器"></a>自定义类型转换器</h4><p>SpringMVC默认已经提供了一些常用的类型转换器，例客户端提交的字符串转换成int型进行参数设置。</p>
<p>但不是所有的数据类型都提供了转换器，没有提供的就需要自定义转换器，例如:日期类型的数据就需要自定义转换器。</p>
<p>自定义类型转换器的开发步骤:</p>
<p>定义转换器类实现Converter接口</p>
<p>在配置文件中声明转换器</p>
<p>在&lt; annotation-driven &gt;中引用转换器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.core.convert.converter.Converter;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>, <span class="title">Date</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">convert</span><span class="params">(String datestr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将日期字符串转换成真正的日期对象， 返回</span></span><br><span class="line">        SimpleDateFormat format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">        Date parse = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            parse = format.parse(datestr);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parse;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>spring-mvc.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--声明自定义转换器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;ConversionService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;converters&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;converter.DateConverter&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--mvc注解驱动--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">conversion-service</span>=<span class="string">&quot;ConversionService&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="获得请求头"><a href="#获得请求头" class="headerlink" title="获得请求头"></a>获得请求头</h4><p>@RequestHeader</p>
<p>使用@RequestHeader可以获得请求头信息，相当于web阶段学习的request.getHeader(name)</p>
<p>@RequestHeader注解的属性如下:<br>value:请求头的名称<br>required:是否必须携带此请求头</p>
<p>@CookieValue<br>使用@CookieValue可以获得指定Cookie的值@CookieValue注解的属性如下:<br>value:指定cookie的名称·<br>required:是否必须携带此cookie</p>
<h4 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h4><p>1.三要素</p>
<p>表单项type = “file”</p>
<p>表单的提交方式post</p>
<p>表单的enctype属性是多部分表单形式，及enctype= “multipart/form-data”</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/user/quick22&quot;</span> </span><br><span class="line">   method=<span class="string">&quot;post&quot;</span> enctype=<span class="string">&quot;multipart/form-data&quot;</span> &gt;</span><br><span class="line">名称&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;username&quot;</span>&gt;&lt;br/&gt;</span><br><span class="line">文件&lt;input type=<span class="string">&quot;file&quot;</span> name=<span class="string">&quot;upload&quot;</span>&gt;&lt;br/&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;提交&quot;</span>&gt;</span><br><span class="line">  &lt;/form&gt;</span><br></pre></td></tr></table></figure>

<p>2.文件上传原理<br>当form表单修改为多部分表单时，request.getParameter0将失效。<br>enctype= “application/x-www-form-urlencoded”时，form表单的正文内容格式是:key=value&amp;key=value&amp;key=value<br>当form表单的enctype取值为Mutilpart/form-data时，请求正文内容就变成多部分形式:</p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1611842915192.png" alt="1611842915192"></p>
<h5 id="单文件上传步骤"><a href="#单文件上传步骤" class="headerlink" title="单文件上传步骤"></a>单文件上传步骤</h5><p>1.导入fileupload和io坐标</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.配置文件上传解析器</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置文件上传解析器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;multipartResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultEncoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;utf-8&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxUploadSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;5242800&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>3.编写文件上传代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/quick22&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span><span class="comment">//告知SpringMVC框架 该方法不进行视图跳转，直接进行数据响应</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save22</span><span class="params">(String username, MultipartFile upload)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;username = &quot;</span> + username);</span><br><span class="line">    <span class="comment">//获得上传文件名称</span></span><br><span class="line">    String filename = upload.getOriginalFilename();</span><br><span class="line">    upload.transferTo(<span class="keyword">new</span> File(<span class="string">&quot;F:\\java_code\\&quot;</span>+filename));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="多文件上传"><a href="#多文件上传" class="headerlink" title="多文件上传"></a>多文件上传</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/quick22&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span><span class="comment">//告知SpringMVC框架 该方法不进行视图跳转，直接进行数据响应</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save22</span><span class="params">(String username, MultipartFile upload,MultipartFile upload2)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;username = &quot;</span> + username);</span><br><span class="line">    <span class="comment">//获得上传文件名称</span></span><br><span class="line">    String filename = upload.getOriginalFilename();</span><br><span class="line">    upload.transferTo(<span class="keyword">new</span> File(<span class="string">&quot;F:\\java_code\\&quot;</span>+filename));</span><br><span class="line"></span><br><span class="line">    String filename2 = upload2.getOriginalFilename();</span><br><span class="line">    upload.transferTo(<span class="keyword">new</span> File(<span class="string">&quot;F:\\java_code\\&quot;</span>+filename2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可for循环   —–&gt;MultipartFile[] upload</p>
<h4 id="SpringMVC拦截器"><a href="#SpringMVC拦截器" class="headerlink" title="SpringMVC拦截器"></a>SpringMVC拦截器</h4><p><em><strong><u>F:\java_code\heima_SpringMVC_interceptor</u></strong></em></p>
<p>拦截器（interceptor）的作用</p>
<p>SpringMVC类似于Servlet开发中的过滤器Filter，用于对处理器进行预处理和后处理。</p>
<p>将拦截器按一定的顺序联结成一条链，这条链称为拦截器链(Interceptor Chain)。在访问被拦截的方法或字段时，拦截器链中的拦截器就会按其之前定义的顺序被调用。拦截器也是AOP思想的具体实现。</p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1611890837649.png" alt="1611890837649"></p>
<p>步骤</p>
<p>1.创建拦截器类实现HandlerInterceptor接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptor1</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//在目标方法执行之前 执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyInterceptor1.preHandle&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//在目标方法执行之后 视图返回之前执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyInterceptor1.postHandle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//在整个流程都执行完毕后 执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyInterceptor1.afterCompletion&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.配置拦截器</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置拦截器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--对哪些资源执行拦截操作--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;interceptor.MyInterceptor1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>3.测试拦截器的拦截结果</p>
<p>拦截器方法说明</p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1611904726727.png" alt="1611904726727"></p>
<h4 id="SpringMVC异常处理"><a href="#SpringMVC异常处理" class="headerlink" title="SpringMVC异常处理"></a>SpringMVC异常处理</h4><p>方法1.使用SpringMVC提供的简单异常处理器SimpleMappingExceptionResolver</p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1612017877468.png" alt="1612017877468"></p>
<p>方法2.实现Spring的异常处理接口HandlerExceptionResolver自定义自己的异常处理器</p>
<p>1.创建异常处理器实现HandlerExceptionResolver接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyExceptionResolver</span> <span class="keyword">implements</span> <span class="title">HandlerExceptionResolver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        参数Exception :异常对象</span></span><br><span class="line"><span class="comment">        返回值ModelAndView     ： 跳转到错误视图信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">resolveException</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e)</span> </span>&#123;</span><br><span class="line">        ModelAndView modelAndView = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">        <span class="keyword">if</span>(e <span class="keyword">instanceof</span> MyException)&#123;</span><br><span class="line">            modelAndView.addObject(<span class="string">&quot;info&quot;</span>,<span class="string">&quot;自定义异常&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(e <span class="keyword">instanceof</span> ClassCastException)&#123;</span><br><span class="line">            modelAndView.addObject(<span class="string">&quot;info&quot;</span>,<span class="string">&quot;类转换异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        modelAndView.setViewName(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> modelAndView;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.配置异常处理器</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置自定义异常处理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;resolver.MyExceptionResolver&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>3.编写异常页面</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>后端</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>后端|Spring|Spring JdbcTemplate</title>
    <url>/2021/01/25/ben-ke-bi-she-qi-jian-ji-lu-bi-ji/springjdbctemplate/</url>
    <content><![CDATA[<h5 id="JdbcTemplate开发步骤"><a href="#JdbcTemplate开发步骤" class="headerlink" title="JdbcTemplate开发步骤"></a>JdbcTemplate开发步骤</h5><p>导入spring-jdbc和spring-tx坐标</p>
<p>创建数据库表和实体</p>
<p>创建JdbcTemplate对象</p>
<p>执行数据库操作</p>
<span id="more"></span>

<p>xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--加载外部的properties文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--数据源对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.commons.dbcp2.BasicDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxTotal&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.maxTotal&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxIdle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.maxIdle&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;initialSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.initialSize&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--jdbc模板对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>jdbc.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">jdbc.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="meta">jdbc.url</span>=<span class="string">jdbc:mysql://localhost:3306/imooc?characterEncoding=utf-8</span></span><br><span class="line"><span class="meta">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">jdbc.password</span>=<span class="string">123456</span></span><br><span class="line"><span class="comment">#最大连接数</span></span><br><span class="line"><span class="meta">jdbc.maxTotal</span>=<span class="string">30</span></span><br><span class="line"><span class="comment">#最大空闲连接</span></span><br><span class="line"><span class="meta">jdbc.maxIdle</span>=<span class="string">10</span></span><br><span class="line"><span class="comment">#初始化连接数</span></span><br><span class="line"><span class="meta">jdbc.initialSize</span>=<span class="string">5</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>后端</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>后端|Spring事务控制</title>
    <url>/2021/01/28/ben-ke-bi-she-qi-jian-ji-lu-bi-ji/spring-shi-wu-kong-zhi/</url>
    <content><![CDATA[<p>事务控制</p>
<span id="more"></span>

<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1611580188412.png" alt="1611580188412"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置平台事务管理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--通知 事务的增强--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置事务的属性信息--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;transfer&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置事务的aop织入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* service.impl.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>





<h4 id="Annotation配置"><a href="#Annotation配置" class="headerlink" title="Annotation配置"></a>Annotation配置</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置平台事务管理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--事务注解驱动--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>@Transactional 可以在类上也可以在方法上， 就近原则</p>
]]></content>
      <tags>
        <tag>后端</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>后端|Spring入门</title>
    <url>/2021/01/28/ben-ke-bi-she-qi-jian-ji-lu-bi-ji/spring-ru-men/</url>
    <content><![CDATA[<h3 id="Spring入门"><a href="#Spring入门" class="headerlink" title="Spring入门"></a>Spring入门</h3><h4 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h4><p>IoC概念：Inversion of Control ，控制反转、依赖注入</p>
<p>1.控制什么?</p>
<p>控制对象的创建及销毁（生命周期） </p>
<p>2.反转什么?</p>
<p>将对象的控制权交给IoC容器 </p>
<span id="more"></span>

<p>自己的IoC容器</p>
<p>约定</p>
<ol>
<li>所有的Bean的生命周期交由IoC容器管理</li>
<li>所有被依赖的Bean通过构造方法执行注入</li>
<li>被依赖的Bean需要优先创建</li>
</ol>
<p>Spring实例化Bean</p>
<p>SpringIoC 工程</p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1611044567216.png" alt="1611044567216"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">//1.</span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bean1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;springbean.Bean&quot;</span> <span class="attr">name</span>=<span class="string">&quot;bean1_1,bean1_2&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">&quot;bean1&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;bean1_3&quot;</span>/&gt;</span></span><br><span class="line">//2.</span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;springbean.Bean2Factory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getBean2&quot;</span> <span class="attr">id</span>=<span class="string">&quot;bean2&quot;</span>/&gt;</span></span><br><span class="line">//3.</span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bean3Factory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;springbean.Bean3Factory&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bean3&quot;</span> <span class="attr">class</span>=<span class="string">&quot;springbean.Bean3&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;bean3Factory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getBean3&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="注入Bean"><a href="#注入Bean" class="headerlink" title="注入Bean"></a>注入Bean</h4><p>SpringIoC_02 工程</p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1611050134411.png" alt="1611050134411"></p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1611063818486.png" alt="1611063818486"></p>
<p>简单方法</p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1611063846539.png" alt="1611063846539"></p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1611063860986.png" alt="1611063860986"></p>
<p><strong>（⭐）</strong>name 名字不是 成员变量名称，而是set方法 除set 外 把第一个字母大写变小写</p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1611063904269.png" alt="1611063904269"></p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1611063922157.png" alt="1611063922157"></p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1611063999533.png" alt="1611063999533"></p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1611064005534.png" alt="1611064005534"></p>
<h5 id="分模块开发（引入其他配置文件"><a href="#分模块开发（引入其他配置文件" class="headerlink" title="分模块开发（引入其他配置文件"></a>分模块开发（引入其他配置文件</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt; import resource=&quot;xxxx.xml&quot;/ &gt;</span><br></pre></td></tr></table></figure>



<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1611323221721.png" alt="1611323221721"></p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1611323636056.png" alt="1611323636056"></p>
<h4 id="Bean作用域"><a href="#Bean作用域" class="headerlink" title="Bean作用域"></a>Bean作用域</h4><p>scope</p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1611064393704.png" alt="1611064393704"></p>
<p>单例模式singleton :在一个Spring上下文环境中，只存在一个实例</p>
<p>多例模式prototype: 每次向Spring上下文请求实例，拿到的都是全新的实例</p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1611126498717.png" alt="1611126498717"></p>
<p>希望每次    调用Bean1的某个方法时，该方法拿到的Bean2都是一个新的实例</p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1611126604527.png" alt="1611126604527"></p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1611126998531.png" alt="1611126998531"></p>
<p>Web环境作用域</p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1611127294421.png" alt="1611127294421"></p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1611127330213.png" alt="1611127330213"></p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1611127365137.png" alt="1611127365137"></p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1611128872835.png" alt="1611128872835"></p>
<p>自定义作用域</p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1611134243311.png" alt="1611134243311"></p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1611134268479.png" alt="1611134268479"></p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1611134287854.png" alt="1611134287854"></p>
<h4 id="Bean懒加载"><a href="#Bean懒加载" class="headerlink" title="Bean懒加载"></a>Bean懒加载</h4><p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1611134759453.png" alt="1611134759453"></p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1611134835669.png" alt="1611134835669"></p>
<p>如果某个Bean在程序整个运行周期都可能不会被使用，那么可以考虑懒加载</p>
<p>优点：尽可能的节省了资源</p>
<p>缺点：可能会导致某个操作响应时间增加</p>
<h5 id="Bean初始化"><a href="#Bean初始化" class="headerlink" title="Bean初始化"></a>Bean初始化</h5><p>1.使用init-method</p>
<p>2.让Bean实现InitializingBean接口</p>
<h5 id="Bean销毁"><a href="#Bean销毁" class="headerlink" title="Bean销毁"></a>Bean销毁</h5><p>1.使用destroy-method</p>
<p>2.让Bean实现DisposableBean接口</p>
<h5 id="Bean-属性继承"><a href="#Bean-属性继承" class="headerlink" title="Bean 属性继承"></a>Bean 属性继承</h5><p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1611136536611.png" alt="1611136536611"></p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1611136555071.png" alt="1611136555071"></p>
<h4 id="Spring注解（⭐）"><a href="#Spring注解（⭐）" class="headerlink" title="Spring注解（⭐）"></a>Spring注解<strong>（⭐）</strong></h4><p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1611385413198.png" alt="1611385413198"></p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1611393844834.png" alt="1611393844834"></p>
<p>xml</p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1611147451399.png" alt="1611147451399"></p>
<p>annotation</p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1611147551325.png" alt="1611147551325"></p>
<p>简化</p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1611149484897.png" alt="1611149484897"></p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1611149598565.png" alt="1611149598565"></p>
<h5 id="Bean取别名"><a href="#Bean取别名" class="headerlink" title="Bean取别名"></a>Bean取别名</h5><p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1611149710827.png" alt="1611149710827"></p>
<h5 id=""><a href="#" class="headerlink" title=""></a></h5><h5 id="通过注解注入Bean"><a href="#通过注解注入Bean" class="headerlink" title="通过注解注入Bean"></a>通过注解注入Bean</h5><p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1611205600710.png" alt="1611205600710"></p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1611205813703.png" alt="1611205739708"></p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1611205881001.png" alt="1611205881001"></p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1611205913594.png" alt="1611205913594"></p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1611206122916.png" alt="1611206122916"></p>
<p>简单类型直接赋值：@Value(“aaaa”)直接将aaaa注入到string</p>
<p>private String string;</p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1611206262577.png" alt="1611206262577"></p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1611216849636.png" alt="1611216849636"></p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1611216888776.png" alt="1611216888776"></p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1611217405098.png" alt="1611217405098"></p>
<p>初始化和销毁</p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1611217945625.png" alt="1611217945625"></p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1611217894842.png" alt="1611217894842"></p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1611217920925.png" alt="1611217920925"></p>
<h5 id="Spring集成Junit"><a href="#Spring集成Junit" class="headerlink" title="Spring集成Junit"></a>Spring集成Junit</h5><p>导入spring集成Junit的坐标,<br>使用@Runwith注解替换原来的运行期<br>使用@contextconfiguration指定配置文件或配置类<br>使用@Autowired注入需要测试的对象<br>创建测试方法进行测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">jdbcTemplateCRUDTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JdbcTemplate jdbcTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>后端</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>后端|Spring整合Mybatis</title>
    <url>/2021/02/08/ben-ke-bi-she-qi-jian-ji-lu-bi-ji/spring-zheng-he-mybatis/</url>
    <content><![CDATA[<p>AccountServiceImpl.java</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;accountService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        InputStream resourceAsStream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            resourceAsStream = Resources.getResourceAsStream(<span class="string">&quot;sqlMapConfig.xml&quot;</span>);</span><br><span class="line">            SqlSessionFactory build = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(resourceAsStream);</span><br><span class="line">            SqlSession sqlSession = build.openSession(<span class="keyword">true</span>);</span><br><span class="line">            AccountMapper mapper = sqlSession.getMapper(AccountMapper.class);</span><br><span class="line">            mapper.save(account);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Account&gt; <span class="title">findAll</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">        InputStream resourceAsStream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            resourceAsStream = Resources.getResourceAsStream(<span class="string">&quot;sqlMapConfig.xml&quot;</span>);</span><br><span class="line">            SqlSessionFactory build = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(resourceAsStream);</span><br><span class="line">            SqlSession sqlSession = build.openSession(<span class="keyword">true</span>);</span><br><span class="line">            AccountMapper mapper = sqlSession.getMapper(AccountMapper.class);</span><br><span class="line">            List&lt;Account&gt; all = mapper.findAll();</span><br><span class="line">            <span class="keyword">return</span> all;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1612427203943.png" alt="1612427203943"></p>
<p>applicationContext.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--加载properties文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置数据源--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.commons.dbcp2.BasicDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxTotal&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.maxTotal&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxIdle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.maxIdle&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;initialSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.initialSize&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置sessionFactory--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--加载mybatis核心文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sqlMapConfig-spring.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--扫描mapper所在的包 为mapper创建实现类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>AccountServiceImpl.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;accountService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountMapper accountMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        accountMapper.save(account);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Account&gt; <span class="title">findAll</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">        List&lt;Account&gt; all = accountMapper.findAll();</span><br><span class="line">        <span class="keyword">return</span> all;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>后端</tag>
        <tag>Mybatis</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>前端|element入门</title>
    <url>/2021/02/01/ben-ke-bi-she-qi-jian-ji-lu-bi-ji/element-ru-men/</url>
    <content><![CDATA[<p><strong>当值为数字要在属性前加:</strong></p>
<span id="more"></span>

<p>1.新建vue-cli项目</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vue init webpack element-ui-test </span><br></pre></td></tr></table></figure>

<p>2.在新项目中添加element-ui库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd element-ui-test</span><br><span class="line">npm install element-ui --save</span><br></pre></td></tr></table></figure>

<p>3.在main.js中配置element-ui</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The Vue build version to load with the `import` command</span></span><br><span class="line"><span class="comment">// (runtime-only or standalone) has been set in webpack.base.conf with an alias.</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span></span><br><span class="line"><span class="comment">//以下为新增内容</span></span><br><span class="line">引入ElementUI</span><br><span class="line"><span class="keyword">import</span> ElementUI <span class="keyword">from</span> <span class="string">&#x27;element-ui&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;element-ui/lib/theme-chalk/index.css&#x27;</span></span><br><span class="line"></span><br><span class="line">配置ElementUI</span><br><span class="line">Vue.use(ElementUI)</span><br><span class="line"><span class="comment">//-----------------------</span></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* eslint-disable no-new */</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  router,</span><br><span class="line">  <span class="attr">components</span>: &#123; App &#125;,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;&lt;App/&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>4.启动vue</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure>



<h2 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;el-container&gt;</span><br><span class="line">    &lt;el-header&gt;header&lt;/el-header&gt;</span><br><span class="line">    &lt;el-container&gt;</span><br><span class="line">    &lt;el-aside&gt;aside&lt;/el-aside&gt;</span><br><span class="line">    &lt;el-main&gt;main&lt;/el-main&gt;</span><br><span class="line">    &lt;/el-container&gt;</span><br><span class="line">    &lt;el-footer&gt;footer&lt;/el-footer&gt;</span><br><span class="line">  &lt;/el-container&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>



<p>elcontainer内有el-header或者el-footer子元素，全部子元素呈垂直上下排列</p>
<p>需要水平左右排列时，需要再定义el-container包含水平左右排列的子元素</p>
<h2 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h2><p>通过基础的 24 分栏，迅速简便地创建布局。 </p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1616894450089.png" alt="1616894450089"></p>
<h2 id="表单系列"><a href="#表单系列" class="headerlink" title="表单系列"></a>表单系列</h2>]]></content>
      <tags>
        <tag>前端</tag>
        <tag>element</tag>
      </tags>
  </entry>
  <entry>
    <title>二分法-浅析</title>
    <url>/2019/09/04/suan-fa/er-fen-fa/</url>
    <content><![CDATA[<h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><h4 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h4><p>1.确定左右边界的范围，明确应在什么范围内进行查找是例如一个数组长为n，范围应该是[0,n]还是[0,n-1]</p>
<p>2.选择中间元素和什么值进行比较，</p>
<p>3.然后选择是左中位数还是右中位数</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(对中位数的判断条件)</span><br><span class="line">&#123;</span><br><span class="line">    right=mid<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    left=mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这种就是右边界收缩，因为right=mid-1，left=mid那么我们就必须要选择右中位数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(对中位数的判断条件)</span><br><span class="line">&#123;</span><br><span class="line">    left=mid+1;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">    right=mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种则是左边界收缩，我们就必须选择左中位数</p>
<p>4.最后我们考虑是否要进行left 后处理以获得最终结果</p>
<h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><p>​    1.mid的取值有3种取法（以左中位数取为例）</p>
<p>​        1）mid=（left+right）/2            //右中位数mid=（left+right+1）/2</p>
<p>​        最普通的一种取法，不建议大家用，很有可能会造成int溢出</p>
<p>​        2）mid=left+（right-left）/2        //右中位数mid=left+（right-left+1）/2</p>
<p>​        一般用这种做法不会造成溢出，但若数据很大的时候也会造成溢出</p>
<p>​        3）mid=（left+right）&gt;&gt;1;            //右中位数mid=(left+right+1)&gt;&gt;1</p>
<p>​        推荐用这种写法，这种不会造成溢出</p>
]]></content>
      <tags>
        <tag>Leetcode</tag>
        <tag>算法</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>前端|Vue入门</title>
    <url>/2021/03/07/ben-ke-bi-she-qi-jian-ji-lu-bi-ji/vue-ru-men/</url>
    <content><![CDATA[<h2 id="1-Vue概述"><a href="#1-Vue概述" class="headerlink" title="1.Vue概述"></a>1.Vue概述</h2><p>目标：MVVM模式应用特点，Vue概念</p>
<p>小结:</p>
<p>MVVM通过视图与模型的双向绑定，简化前端操作。Vue是一款前端渐进式框架，可以提高前端开发效率。</p>
<span id="more"></span>

<h2 id="2-搭建示例工程"><a href="#2-搭建示例工程" class="headerlink" title="2.搭建示例工程"></a>2.搭建示例工程</h2><p>目标：使用IDEA创建示例工程并在工程中通过npm安装下载vue.js</p>
<p>分析：</p>
<p>vue是一款前端框架，也是其实是一个js文件；下载vue.js文件并在页面中引用该js文件。</p>
<p>vue.js的下载方式：</p>
<ul>
<li>可以引用在线的vue.js</li>
<li>可以离线下载vue.js</li>
<li>npm包资源管理器，可以下载vue.js</li>
</ul>
<p>小结:</p>
<p>使用npm方式安装vue模块：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#初始化</span></span><br><span class="line">npm init -y</span><br><span class="line"></span><br><span class="line"><span class="comment">#下载vue 模块</span></span><br><span class="line">npm install vue --save</span><br></pre></td></tr></table></figure>

<h2 id="3-演示双向绑定与事件处理"><a href="#3-演示双向绑定与事件处理" class="headerlink" title="3.演示双向绑定与事件处理"></a>3.演示双向绑定与事件处理</h2><p>目标：创建01-demo.html页面并初始化Vue实例，通过console修改Vue数据实现双向绑定效果和创建按钮实现点击即自增</p>
<p>分析:</p>
<blockquote>
<p>1.创建页面，初始化Vue；</p>
<ol start="2">
<li>  {  { } } 获取显示数据；</li>
</ol>
<p>3.v-model实现双向绑定；</p>
<p>4.v-on演示事件处理</p>
</blockquote>
<p>小结:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Vuejs 测试<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;node_modules/vue/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;num&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;num++&quot;</span>&gt;</span>点我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;name&#125;&#125; 非常酷！有&#123;&#123;num&#125;&#125;个学科.<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">name</span>:<span class="string">&quot;黑马&quot;</span>,</span></span><br><span class="line"><span class="javascript">            <span class="attr">num</span>:<span class="number">1</span></span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="4-Vue实例生命周期及钩子函数"><a href="#4-Vue实例生命周期及钩子函数" class="headerlink" title="4.Vue实例生命周期及钩子函数"></a>4.Vue实例生命周期及钩子函数</h2><p>目标：了解Vue实例生命周期，生命周期的钩子函数及created函数常用场景</p>
<p>分析:</p>
<p>在创建vue实例的时候可以指定模板id、数据和方法；而如果要在实例化、模板渲染的过程中需要执行一些其他操作的话，那么可以使用钩子函数。</p>
<p>小结:</p>
<p>钩子函数会在Vue实例的各个生命周期阶段自动调用；具体可以有beforeCreate,created,beforeMount,mounted,updated,beforeUpdate,destroyed,beforeDestroy</p>
<p>created钩子函数常用场景：用于初始化数据</p>
<blockquote>
<p>钩子函数不要使用    箭头函数的方式编写</p>
</blockquote>
<h2 id="5-插值、v-text和v-html"><a href="#5-插值、v-text和v-html" class="headerlink" title="5.插值、v-text和v-html"></a>5.插值、v-text和v-html</h2><p>目标：插值使用场景和要求；v-text和v-html的作用</p>
<p>小结:</p>
<p>插值可以使用在有需要显示vue实例数据的地方，可以在插值表达式中调用实例的数据属性和函数。</p>
<p>v-text和v-html的作用：可以将数据在模板中进行显示；区别：v-html对内容中出现的html标签进行渲染，而v-text会将内容当作普通文本输出到元素里面。</p>
<h2 id="6-指令-v-model使用"><a href="#6-指令-v-model使用" class="headerlink" title="6.指令-v-model使用"></a>6.指令-v-model使用</h2><p>目标：使用v-model指令实现复选框的双向绑定</p>
<p>小结:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Vuejs 测试<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;node_modules/vue/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Java&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;language&quot;</span>&gt;</span>Java<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Python&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;language&quot;</span>&gt;</span>Python<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Swift&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;language&quot;</span>&gt;</span>Swift<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span></span><br><span class="line">        你选择了:&#123;&#123;language.join(&quot;,&quot;)&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">language</span>:[]</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>多个checkbox对应一个model时，model的类型是一个数组，单个checkbox值是boolean类型</p>
<p>radio对应的值是input的value值</p>
<p>input和textarea默认对应的model是字符串</p>
<p>select单选对应字符串，多选对应也是数组</p>
</blockquote>
<h2 id="7-指令-v-on使用"><a href="#7-指令-v-on使用" class="headerlink" title="7.指令-v-on使用"></a>7.指令-v-on使用</h2><p>目标：了解v-on指令的语法实现按钮点击后的递增和递减</p>
<p>分析:</p>
<p>在没有使用vue之前；页面标签可以通过设置onXXX响应事件；在vue中可以通过v-on指令响应事件。</p>
<p>小结:</p>
<p>v-on的使用</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;num++&quot;</span>&gt;</span>增加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;decrement&quot;</span>&gt;</span>减少<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span></span><br><span class="line">        num = &#123;&#123;num&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">    事件冒泡测试<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;background-color: lightblue; width:100px;height: 100px&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;print(&#x27;点击了div&#x27;)&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.stop</span>=<span class="string">&quot;print(&#x27;点击了button&#x27;)&quot;</span>&gt;</span>点我试试<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span>阻止默认事件<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.itcast.cn&quot;</span> @<span class="attr">click.prevent</span>=<span class="string">&quot;print(&#x27;点击了超链接&#x27;)&quot;</span>&gt;</span>传智播客<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">num</span>:<span class="number">1</span></span></span><br><span class="line"><span class="javascript">        &#125;,</span></span><br><span class="line"><span class="javascript">        <span class="attr">methods</span>:&#123;</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">decrement</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">this</span>.num--;</span></span><br><span class="line"><span class="javascript">            &#125;,</span></span><br><span class="line"><span class="javascript">            <span class="comment">//打印</span></span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">print</span>(<span class="params">str</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(str);</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>事件修饰符：语法v-on:xxxx.修饰符，常用的修饰符有：</p>
<p>.stop:阻止事件冒泡</p>
<p>.prevent:阻止默认事件发生</p>
<p>.capture:使用事件捕获模式</p>
<p>.self:只有元素自身触发事件才执行。(冒泡或捕获的都不执行)</p>
<p>.once:只执行一次</p>
<h2 id="8-指令v-for使用"><a href="#8-指令v-for使用" class="headerlink" title="8.指令v-for使用"></a>8.指令v-for使用</h2><p>目标：了解v-for指令语法实现对数组、对象的遍历</p>
<p>分析:</p>
<p>实现：可以在vue实例化的时候指定要遍历的数据，然后通过v-for指令在模板中遍历显示数据。一般情况下，要遍历的数据可以通过钩子函数created发送异步请求获取数据。</p>
<p>小结:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(user,index) in users&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span>&gt;</span></span><br><span class="line">           &#123;&#123;index&#125;&#125;--&#123;&#123;user.name&#125;&#125;--&#123;&#123;user.age&#125;&#125;--&#123;&#123;user.gender&#125;&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(value,key,index) in person&quot;</span>&gt;</span></span><br><span class="line">            &#123;&#123;index&#125;&#125; -- &#123;&#123;key&#125;&#125; -- &#123;&#123;value&#125;&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">users</span>:[</span></span><br><span class="line"><span class="javascript">                &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;黑马1&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">13</span>,<span class="string">&quot;gender&quot;</span>:<span class="string">&quot;男&quot;</span>&#125;,</span></span><br><span class="line"><span class="javascript">                &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;黑马2&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">15</span>,<span class="string">&quot;gender&quot;</span>:<span class="string">&quot;男&quot;</span>&#125;,</span></span><br><span class="line"><span class="javascript">                &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;黑马3&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>,<span class="string">&quot;gender&quot;</span>:<span class="string">&quot;女&quot;</span>&#125;,</span></span><br><span class="line"><span class="javascript">            ],</span></span><br><span class="line"><span class="javascript">            <span class="attr">person</span>:&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;对象&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">13</span>,<span class="string">&quot;gender&quot;</span>:<span class="string">&quot;男&quot;</span>,<span class="string">&quot;address&quot;</span>:<span class="string">&quot;中国&quot;</span>&#125;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果遍历的时候需要使用到索引号，可以在循环变量的位置，添加一个参数；该索引号是从0开始的</p>
</blockquote>
<h2 id="9-指令-v-if和v-show使用"><a href="#9-指令-v-if和v-show使用" class="headerlink" title="9.指令-v-if和v-show使用"></a>9.指令-v-if和v-show使用</h2><p>目标：说出v-if与v-show的区别；通过一个按钮的点击，实现遍历数组结果的显示存在与否并在遍历过程中使用v-if对数据进行判断处理；实现文本内容的隐藏</p>
<p>分析:</p>
<ul>
<li>v-if：通过一个按钮的点击，实现遍历数组结果的显示存在与否并在遍历过程中使用v-if对数据进行判断处理</li>
<li>v-show：实现文本内容的隐藏</li>
</ul>
<p>小结:</p>
<p>v-if 在条件不满足时，元素不会存在；</p>
<p>v-show条件不满足时，只是对元素进行隐藏。</p>
<h2 id="10-指令-v-bind使用"><a href="#10-指令-v-bind使用" class="headerlink" title="10.指令-v-bind使用"></a>10.指令-v-bind使用</h2><p>目标：了解v-bind语法和作用；实现点击不同按钮切换不同的属性值；使用class属性中的特殊用法实现一个按钮切换背景色</p>
<p>分析:</p>
<p><img src="" height=" "/> 其中src 和 height 的值如果不想写死，而是项获取vue实例中的数据属性值的话；那可以通过使用v-bind实现：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">v-bind:</span> <span class="attr">src</span>=<span class="string">&quot;vue实例中的数据属性名&quot;</span> <span class="attr">:height</span>=<span class="string">&quot;vue实例中的数据属性名&quot;</span>/&gt;</span> </span><br></pre></td></tr></table></figure>

<p>小结:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;color=&#x27;red&#x27;&quot;</span>&gt;</span>红色<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;color=&#x27;blue&#x27;&quot;</span>&gt;</span>蓝色<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">&quot;color&quot;</span>&gt;</span></span><br><span class="line">        点击按钮改变背景颜色</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;bool=!bool&quot;</span>&gt;</span>点我改变下面色块 yans<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">&quot;&#123;red:bool, blue:!bool&#125;&quot;</span>&gt;</span></span><br><span class="line">        点击按钮改变背景颜色</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">color</span>: <span class="string">&quot;red&quot;</span>,</span></span><br><span class="line"><span class="javascript">            <span class="attr">bool</span>: <span class="literal">true</span></span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>v-bind的作用：可以对所有元素的属性设置vue实例的数据。</p>
</blockquote>
<h2 id="11-计算属性的使用"><a href="#11-计算属性的使用" class="headerlink" title="11.计算属性的使用"></a>11.计算属性的使用</h2><p>目标：计算属性的应用场景，实现将一个日期时间值转换为yyyy-MM-dd格式字符串</p>
<p>分析:</p>
<p>一个日期的毫秒值要显示为格式化（yyyy-MM-dd）的日期字符串的话；可以使用computed计算属性里面的方法进行处理。</p>
<p>小结:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span></span><br><span class="line">        你的生日是：</span><br><span class="line">        &#123;&#123;new Date(birthday).getFullYear()&#125;&#125;-&#123;&#123;new Date(birthday).getMonth()+1&#125;&#125;-&#123;&#123;new Date(birthday).getDay()&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span></span><br><span class="line">        你的生日是：</span><br><span class="line">        &#123;&#123;birth&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">birthday</span>:<span class="number">1429032123201</span></span></span><br><span class="line"><span class="javascript">        &#125;,</span></span><br><span class="line"><span class="javascript">        <span class="attr">computed</span>:&#123;</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">birth</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">const</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">this</span>.birthday);</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> date.getFullYear()+<span class="string">&quot;-&quot;</span>+(date.getMonth()+<span class="number">1</span>)+<span class="string">&quot;-&quot;</span>+date.getDay();</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>computed计算属性的应用场景：可以应用在插值或者指令表达式复杂的时候。可以将一些属性数据 经过方法处理之后返回。</p>
<h2 id="12-watch基本和深度监控"><a href="#12-watch基本和深度监控" class="headerlink" title="12.watch基本和深度监控"></a>12.watch基本和深度监控</h2><p>目标：watch的使用场景；并使用其监听简单属性值及其对象中属性值的变化</p>
<p>分析:</p>
<p>在vue实例中数据属性；因为在页面中修改而产生了变化；可以通过watch监控其改变前后的值。</p>
<p>如果是修改的对象数据属性，可以开启深度监控获取修改后最新的对象数据。如：person.name</p>
<p>小结：</p>
<p>可以如下使用watch进行数据属性的监控：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;person.name&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;person.age&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;person.age++&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>姓名为：&#123;&#123;person.name&#125;&#125;;年龄为:&#123;&#123;person.age&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">message</span>:<span class="string">&quot;黑马&quot;</span>,</span></span><br><span class="line"><span class="javascript">            <span class="attr">person</span>:&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;heima&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>&#125;</span></span><br><span class="line"><span class="javascript">        &#125;,</span></span><br><span class="line"><span class="javascript">        <span class="attr">watch</span>:&#123;</span></span><br><span class="line"><span class="javascript">          <span class="function"><span class="title">message</span>(<span class="params">newValue,oldValue</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">              <span class="built_in">console</span>.log(<span class="string">&quot;新值:&quot;</span>+newValue+<span class="string">&quot;;旧值:&quot;</span>+oldValue);</span></span><br><span class="line"><span class="javascript">          &#125;,</span></span><br><span class="line"><span class="javascript">          <span class="attr">person</span>:&#123;</span></span><br><span class="line"><span class="javascript">              <span class="comment">//开启深度监控；监控对象中的属性值变化</span></span></span><br><span class="line"><span class="javascript">              <span class="attr">deep</span>:<span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">              <span class="comment">//可以获取最新的对象属性数据</span></span></span><br><span class="line"><span class="javascript">              <span class="function"><span class="title">handler</span>(<span class="params">obj</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                  <span class="built_in">console</span>.log(<span class="string">&quot;name = &quot;</span>+obj.name + <span class="string">&quot; ;age = &quot;</span>+obj.age);</span></span><br><span class="line"><span class="javascript">              &#125;</span></span><br><span class="line"><span class="javascript">          &#125;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>watch使用场景：可以监控视图中数据的变化而做出响应；如：下拉框列表中，当选择了对应的下拉框之后，要根据最新的值去加载一些其他数据的话。</p>
<h2 id="13-组件使用"><a href="#13-组件使用" class="headerlink" title="13.组件使用"></a>13.组件使用</h2><p>目标：了解组件的使用场景；定义点击则计数的组件并使用全局注册和局部注册的方式</p>
<p>分析:</p>
<p>可以将通用或者公用的页面模块抽取成vue模块，在vue实例中引用。 </p>
<p>小结：在页面中可以如下使用组件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    使用组件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">counter</span>&gt;</span><span class="tag">&lt;/<span class="name">counter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">counter</span>&gt;</span><span class="tag">&lt;/<span class="name">counter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">counter</span>&gt;</span><span class="tag">&lt;/<span class="name">counter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">//定义组件</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> counter = &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">template</span>:<span class="string">&quot;&lt;button @click=&#x27;num++&#x27;&gt;你点击了&#123;&#123;num&#125;&#125;次&lt;/button&gt;&quot;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> &#123;<span class="attr">num</span>:<span class="number">0</span>&#125;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript">    <span class="comment">//全局注册组件：在所有的vue实例中都可以使用组件</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//参数1：组件名称，参数2：具体的组件</span></span></span><br><span class="line"><span class="javascript">   <span class="comment">// Vue.component(&quot;counter&quot;,counter);</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">components</span>:&#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">counter</span>:counter</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>组件使用场景：在项目中需要重用某个模块（头部、尾部、新闻。。。）的时候，可以将模块抽取成组件，其他页面中注册组件并引用。</p>
<ul>
<li>全局注册：在任何vue实例中都可以引用，如：一般网站的头部导航菜单</li>
<li>局部注册：可以在有需要的页面引入组件，如：商城网站首页页面中各种活动模块</li>
</ul>
<h2 id="14-父组件向子组件通信"><a href="#14-父组件向子组件通信" class="headerlink" title="14.父组件向子组件通信"></a>14.父组件向子组件通信</h2><p>目标：父组件与子组件通信的意义；实现父组件将简单字符串和对象更新到子组件</p>
<p>小结：</p>
<p>组件通信的意义：父子组件之间数据的交换，能够及时更新组件内容。</p>
<ul>
<li>父组件将简单字符串更新传递到子组件</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    使用组件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">introduce</span> <span class="attr">:title</span>=<span class="string">&quot;msg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">introduce</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">//定义组件</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> introduce = &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">template</span>:<span class="string">&quot;&lt;h2&gt;&#123;&#123;title&#125;&#125;&lt;/h2&gt;&quot;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="comment">//定义接受父组件的属性</span></span></span><br><span class="line"><span class="javascript">        <span class="attr">props</span>:[<span class="string">&quot;title&quot;</span>]</span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript">    <span class="comment">//全局注册组件：在所有的vue实例中都可以使用组件</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//参数1：组件名称，参数2：具体的组件</span></span></span><br><span class="line"><span class="javascript">   Vue.component(<span class="string">&quot;introduce&quot;</span>,introduce);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">msg</span>:<span class="string">&quot;父组件的 msg属性数据内容&quot;</span></span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>父组件将数组更新传递到子组件</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    使用组件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">my-list</span> <span class="attr">:items</span>=<span class="string">&quot;lessons&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">my-list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">//定义组件</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> myList = &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">template</span>:<span class="string">&#x27;&lt;ul&gt;&#x27;</span> +</span></span><br><span class="line"><span class="javascript">            <span class="string">&#x27;&lt;li v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;&#123;&#123;item.id&#125;&#125;--&#123;&#123;item.name&#125;&#125;&lt;/li&gt; &#x27;</span> +</span></span><br><span class="line"><span class="javascript">            <span class="string">&#x27;&lt;/ul&gt;&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="comment">//定义接受父组件的属性</span></span></span><br><span class="line"><span class="javascript">        <span class="attr">props</span>:&#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">items</span>:&#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">//数据类型，如果是数组则是Array,如果是对象则是Object</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">Array</span>,</span></span><br><span class="line"><span class="javascript">                <span class="comment">//默认值</span></span></span><br><span class="line"><span class="javascript">                <span class="attr">default</span>:[]</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">msg</span>:<span class="string">&quot;父组件的 msg属性数据内容&quot;</span>,</span></span><br><span class="line"><span class="javascript">            <span class="attr">lessons</span>:[</span></span><br><span class="line"><span class="javascript">                &#123;<span class="string">&quot;id&quot;</span>:<span class="number">1</span>,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;Java&quot;</span>&#125;,</span></span><br><span class="line"><span class="javascript">                &#123;<span class="string">&quot;id&quot;</span>:<span class="number">2</span>,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;Php&quot;</span>&#125;,</span></span><br><span class="line"><span class="javascript">                &#123;<span class="string">&quot;id&quot;</span>:<span class="number">3</span>,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;C#&quot;</span>&#125;</span></span><br><span class="line"><span class="javascript">            ]</span></span><br><span class="line"><span class="javascript">        &#125;,</span></span><br><span class="line"><span class="javascript">        <span class="attr">components</span>:&#123;</span></span><br><span class="line"><span class="javascript">            myList</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="15-子组件向父组件通信"><a href="#15-子组件向父组件通信" class="headerlink" title="15.子组件向父组件通信"></a>15.子组件向父组件通信</h2><p>目标：在子组件中点击对应按钮实现父组件中属性输出的改变</p>
<p>小结：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    使用组件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>num == &#123;&#123;num&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">counter</span> @<span class="attr">plus</span>=<span class="string">&quot;numPlus()&quot;</span> @<span class="attr">reduce</span>=<span class="string">&quot;numReduce&quot;</span>  <span class="attr">:snum</span> = <span class="string">&quot;num&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">counter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">//定义组件</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> counter = &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">template</span>:<span class="string">&#x27;&lt;div&gt;&#x27;</span> +</span></span><br><span class="line"><span class="javascript">            <span class="string">&#x27;&lt;button @click=\&#x27;incrNum\&#x27;&gt;+&lt;/button&gt;&#x27;</span> +</span></span><br><span class="line"><span class="javascript">            <span class="string">&#x27;&lt;button @click=\&#x27;decrNum\&#x27;&gt;-&lt;/button&gt;&#x27;</span> +</span></span><br><span class="line"><span class="javascript">            <span class="string">&#x27;&lt;/div&gt;&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">props</span>:[<span class="string">&quot;snum&quot;</span>],</span></span><br><span class="line"><span class="javascript">        <span class="attr">methods</span>:&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">//递增</span></span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">incrNum</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">//调用父组件中的方法</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> <span class="built_in">this</span>.$emit(<span class="string">&quot;plus&quot;</span>);</span></span><br><span class="line"><span class="javascript">            &#125;,</span></span><br><span class="line"><span class="javascript">            <span class="comment">//递减</span></span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">decrNum</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">//调用父组件中的方法</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> <span class="built_in">this</span>.$emit(<span class="string">&quot;reduce&quot;</span>);</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript">    <span class="comment">//全局注册组件：在所有的vue实例中都可以使用组件</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//参数1：组件名称，参数2：具体的组件</span></span></span><br><span class="line"><span class="javascript">   <span class="comment">// Vue.component(&quot;counter&quot;,counter);</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">components</span>:&#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">counter</span>:counter</span></span><br><span class="line"><span class="javascript">        &#125;,</span></span><br><span class="line"><span class="javascript">        <span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">num</span>:<span class="number">0</span></span></span><br><span class="line"><span class="javascript">        &#125;,</span></span><br><span class="line"><span class="javascript">        <span class="attr">methods</span>:&#123;</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">numPlus</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">this</span>.num++;</span></span><br><span class="line"><span class="javascript">            &#125;,</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">numReduce</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">              <span class="built_in">this</span>.num--;</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="16-axios"><a href="#16-axios" class="headerlink" title="16.axios"></a>16.axios</h2><p>目标：axios的用途及了解常见方法</p>
<p>cnpm install axios –save</p>
<p>然后在main.js中全局引入axios</p>
<p>import axios from ‘axios’</p>
<p>Vue.prototype.$axios = axios //</p>
<p>小结：</p>
<p>axios的作用：发送异步请求获取数据。常见的方法：<strong>get、post</strong>；在发送的时候可以指定参数（地址、请求方式和请求头部信息）；返回数据结构（<strong>data</strong>/status/statusText/headers/config）</p>
<h2 id="17-axios方法及get、post方法使用"><a href="#17-axios方法及get、post方法使用" class="headerlink" title="17.axios方法及get、post方法使用"></a>17.axios方法及get、post方法使用</h2><p>目标：使用axios方法获取数据并在页面中将数据遍历显示；切换改为get/post方法实现数据加载</p>
<p>小结：</p>
<p>可以使用axios获取对应服务器数据；如果不是同一个服务器的数据则可能出现跨域请求；需要在响应的服务器上配置跨域。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(user,index) in users&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span>&gt;</span></span><br><span class="line">           &#123;&#123;index&#125;&#125;--&#123;&#123;user.name&#125;&#125;--&#123;&#123;user.age&#125;&#125;--&#123;&#123;user.gender&#125;&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">users</span>:[],</span></span><br><span class="line"><span class="javascript">        &#125;,</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">//初始化加载数据</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            axios.post(<span class="string">&quot;data.json&quot;</span>).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(res);</span></span><br><span class="line"><span class="javascript">                <span class="comment">//将数据赋值到vue实例中的数据属性users;</span></span></span><br><span class="line"><span class="javascript">                <span class="comment">//不能使用this,在axios回调函数中表示窗口，不是vue实例</span></span></span><br><span class="line"><span class="javascript">                app.users=res.data;</span></span><br><span class="line"><span class="javascript">            &#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>alert(err));</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            axios.get(<span class="string">&quot;http://localhost:8009/user/2&quot;</span>).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(res.data);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">                app.users=res.data;</span></span><br><span class="line"><span class="javascript">            &#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>alert(err));</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="javascript">            axios.get(&quot;data.json&quot;).then(res=&gt;&#123;</span></span></span><br><span class="line"><span class="comment"><span class="javascript">                console.log(res);</span></span></span><br><span class="line"><span class="comment"><span class="javascript">                //将数据赋值到vue实例中的数据属性users;</span></span></span><br><span class="line"><span class="comment"><span class="javascript">                //不能使用this,在axios回调函数中表示窗口，不是vue实例</span></span></span><br><span class="line"><span class="comment"><span class="javascript">                app.users=res.data;</span></span></span><br><span class="line"><span class="comment"><span class="javascript">            &#125;).catch(err=&gt;alert(err));</span></span></span><br><span class="line"><span class="comment"><span class="javascript">*/</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="javascript">            axios(&#123;</span></span></span><br><span class="line"><span class="comment"><span class="javascript">                url:&quot;data.json&quot;,</span></span></span><br><span class="line"><span class="comment"><span class="javascript">                method:&quot;get&quot;</span></span></span><br><span class="line"><span class="comment"><span class="javascript">            &#125;).then(res=&gt;&#123;</span></span></span><br><span class="line"><span class="comment"><span class="javascript">                console.log(res);</span></span></span><br><span class="line"><span class="comment"><span class="javascript">                //将数据赋值到vue实例中的数据属性users;</span></span></span><br><span class="line"><span class="comment"><span class="javascript">                //不能使用this,在axios回调函数中表示窗口，不是vue实例</span></span></span><br><span class="line"><span class="comment"><span class="javascript">                app.users=res.data;</span></span></span><br><span class="line"><span class="comment"><span class="javascript">            &#125;).catch(err=&gt;alert(err));</span></span></span><br><span class="line"><span class="comment"><span class="javascript">*/</span></span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>跨域：在前端js中如果发送异步请求的话，请求的地址与当前服务器的ip或者端口号不同都是跨域请求，可以使用如下方式在服务器端进行配置：</p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1615190862233.png" alt="1615190862233"></p>
</blockquote>
<h2 id="18-store"><a href="#18-store" class="headerlink" title="18.store"></a>18.store</h2>]]></content>
      <tags>
        <tag>前端</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划</title>
    <url>/2019/08/19/suan-fa/dong-tai-gui-hua/</url>
    <content><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h4 id="1-什么情况下用动态规划"><a href="#1-什么情况下用动态规划" class="headerlink" title="1.什么情况下用动态规划"></a>1.什么情况下用动态规划</h4><p>动态规划是针对一类求最优解的问题的算法， 其核心是将一个问题分解成为若干个子问题（这里对应下文的子问题使用条件）， 部分类似于分治的思想（不懂得可以参考归并排序）， 通过求每一次的最优决策， 来得到一个最优解。在这里最重要的就是子问题的思想。 </p>
<span id="more"></span>

<h4 id="2-子问题解决法的适用条件"><a href="#2-子问题解决法的适用条件" class="headerlink" title="2.子问题解决法的适用条件"></a>2.子问题解决法的适用条件</h4><p>1.具有相同的子问题：我们必须保证我们分割成的子问题也能按照相同的方法分割成更小的自问题， 并这些自问题的最终分割情况是可以解决的。</p>
<p>2.满足最优子结构：一道DP问题其实就是一个递推问题，假设当前决策结果是f[n]，则最优子结构就是要让f[n-k]最优，最优子结构性质就是能让转移到n的状态是最优的，并且与后面的决策没有关系，即让后面的决策安心地使用前面的局部最优解的一种性质。</p>
<p>3.无后效性：他要求每个子问题的决策不能对后面其他未解决的问题产影响， 如果产生就无法保证决策的最优性， 这就是无后效性。往往需要我们找到一个合适的状态。 </p>
<h4 id="3-解题步骤"><a href="#3-解题步骤" class="headerlink" title="3.解题步骤"></a>3.解题步骤</h4><p>1.确定子问题</p>
<p>2.推出状态转移方程</p>
<p>3.确定边界条件（状态初始化）</p>
<p>4.确定实现方法</p>
<p>5.（确定优化方法）</p>
]]></content>
      <tags>
        <tag>Leetcode</tag>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>滑动窗口</title>
    <url>/2019/08/19/suan-fa/hua-dong-chuang-kou/</url>
    <content><![CDATA[<h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><h3 id="1-什么是滑动窗口"><a href="#1-什么是滑动窗口" class="headerlink" title="1.什么是滑动窗口"></a>1.什么是滑动窗口</h3><p>1）滑动窗口是一个队列， </p>
<p>2）先移动右指针，</p>
<p>3）当满足条件时，移动左指针，直到不满足条件，</p>
<p>4）重复2，3步，直到右指针到末位。</p>
<span id="more"></span>

<p><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">leetcode 3.无重复字符的最长子串</a> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        unordered_set&lt;<span class="keyword">char</span>&gt; lookup;</span><br><span class="line">        <span class="keyword">int</span> maxStr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">while</span> (lookup.<span class="built_in">find</span>(s[i]) != lookup.<span class="built_in">end</span>())&#123;</span><br><span class="line">                lookup.<span class="built_in">erase</span>(s[left]);</span><br><span class="line">                left ++;</span><br><span class="line">            &#125;</span><br><span class="line">            maxStr = <span class="built_in">max</span>(maxStr,i-left+<span class="number">1</span>);</span><br><span class="line">            lookup.<span class="built_in">insert</span>(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> maxStr;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode-cn.com/problems/minimum-window-substring/">leetcode 76. 最小覆盖子串</a> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>,minlen=INT_MAX,left=<span class="number">0</span>,right=<span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; window;</span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; need;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:t) need[c]++;</span><br><span class="line">        <span class="keyword">int</span> match=<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(right&lt;s.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> c1=s[right];</span><br><span class="line">            <span class="keyword">if</span>(need.<span class="built_in">count</span>(c1))</span><br><span class="line">            &#123;</span><br><span class="line">                window[c1]++;</span><br><span class="line">                <span class="keyword">if</span>(window[c1]==need[c1])</span><br><span class="line">                &#123;</span><br><span class="line">                    match++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">            <span class="keyword">while</span>(match==need.<span class="built_in">size</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(right-left&lt;minlen)</span><br><span class="line">                &#123;</span><br><span class="line">                    start=left;</span><br><span class="line">                    minlen=right-left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">char</span> c2=s[left];</span><br><span class="line">                <span class="keyword">if</span>(need.<span class="built_in">count</span>(c2))</span><br><span class="line">                &#123;</span><br><span class="line">                    window[c2]--;</span><br><span class="line">                    <span class="keyword">if</span>(window[c2]&lt;need[c2])</span><br><span class="line">                        match--;</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minlen == INT_MAX ? <span class="string">&quot;&quot;</span> : s.<span class="built_in">substr</span>(start, minlen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Leetcode</tag>
        <tag>算法</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-101.对称二叉树</title>
    <url>/2019/08/24/leetcode/101-200/101.dui-cheng-er-cha-shu/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote>
<p>给定一个二叉树，检查它是否是镜像对称的。</p>
<p>例如，二叉树 <code>[1,2,2,3,4,4,3]</code> 是对称的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   2</span><br><span class="line"> / \ / \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure>

<p>但是下面这个 <code>[1,2,2,null,3,null,3]</code> 则不是镜像对称的:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line"> 3    3</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<p>如果你可以运用递归和迭代两种方法解决这个问题，会很加分。</p>
</blockquote>
<span id="more"></span>

<h4 id="解法1：递归"><a href="#解法1：递归" class="headerlink" title="解法1：递归"></a>解法1：递归</h4><p>如果一个树的左子树与右子树镜像对称，那么这个树是对称的。 </p>
<p>因此，该问题可以转化为：两个树在什么情况下互为镜像？</p>
<p>如果同时满足下面的条件，两个树互为镜像：</p>
<ol>
<li>它们的两个根结点具有相同的值。</li>
<li>每个树的右子树都与另一个树的左子树镜像对称。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isMirror</span>(root-&gt;left,root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMirror</span><span class="params">(TreeNode *t1,TreeNode *t2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t1==<span class="literal">NULL</span>&amp;&amp;t2==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t1==<span class="literal">NULL</span>||t2==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in"><span class="keyword">return</span></span> (t1-&gt;val==t2-&gt;val)&amp;&amp;<span class="built_in">isMirror</span>(t1-&gt;left,t2-&gt;right)&amp;&amp;<span class="built_in">isMirror</span>(t1-&gt;right,t2-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="解法2：迭代"><a href="#解法2：迭代" class="headerlink" title="解法2：迭代"></a>解法2：迭代</h4><p>除了递归的方法外，我们也可以利用队列进行迭代。队列中每两个连续的结点应该是相等的，而且它们的子树互为镜像。最初，队列中包含的是 root 以及 root。该算法的工作原理类似于 BFS，但存在一些关键差异。每次提取两个结点并比较它们的值。然后，将两个结点的左右子结点按相反的顺序插入队列中。当队列为空时，或者我们检测到树不对称（即从队列中取出两个不相等的连续结点）时，该算法结束。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* t1 = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            TreeNode* t2 = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(t1==<span class="literal">NULL</span> &amp;&amp; t2==<span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(t1==<span class="literal">NULL</span> || t2==<span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(t1-&gt;val != t2-&gt;val)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(t1-&gt;left);</span><br><span class="line">            q.<span class="built_in">push</span>(t2-&gt;right);</span><br><span class="line">            q.<span class="built_in">push</span>(t1-&gt;right);</span><br><span class="line">            q.<span class="built_in">push</span>(t2-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>101-200</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>树</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-102.二叉树的层次遍历</title>
    <url>/2019/08/25/leetcode/101-200/102.er-cha-shu-de-ceng-ci-bian-li/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote>
<p>给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。</p>
<p>例如:<br>给定二叉树: [3,9,20,null,null,15,7],</p>
<pre><code>    3
   / \
  9  20
    /  \
   15   7
</code></pre>
<p>返回其层次遍历结果：</p>
<p>[<br>  [3],<br>  [9,20],<br>  [15,7]<br>]</p>
</blockquote>
<span id="more"></span>

<h4 id="解法1：递归"><a href="#解法1：递归" class="headerlink" title="解法1：递归"></a>解法1：递归</h4><p>最简单的解法就是递归，首先确认树非空，然后调用递归函数 helper(node, level)，参数是当前节点和节点的层次。程序过程如下：</p>
<p>输出列表称为 levels，当前最高层数就是列表的长度 len(levels)。比较访问节点所在的层次 level 和当前最高层次 len(levels) 的大小，如果前者更大就向 levels 添加一个空列表。<br>将当前节点插入到对应层的列表 levels[level] 中。<br>递归非空的孩子节点：helper(node.left / node.right, level + 1)。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">levelfind</span>(root,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">levelfind</span><span class="params">(TreeNode *root,<span class="keyword">int</span> height)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(height&gt;=res.<span class="built_in">size</span>())</span><br><span class="line">                res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">            res[height].<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">            <span class="built_in">levelfind</span>(root-&gt;left,height+<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">levelfind</span>(root-&gt;right,height+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="解法2：迭代"><a href="#解法2：迭代" class="headerlink" title="解法2：迭代"></a>解法2：迭代</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        queue&lt;TreeNode *&gt;q;</span><br><span class="line">        TreeNode *p;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">            <span class="keyword">int</span> n=q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                p=q.<span class="built_in">front</span>();</span><br><span class="line">                temp.<span class="built_in">push_back</span>(p-&gt;val);</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(p-&gt;left!=<span class="literal">NULL</span>)   q.<span class="built_in">push</span>(p-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(p-&gt;right!=<span class="literal">NULL</span>)  q.<span class="built_in">push</span>(p-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>101-200</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>树</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-103.二叉树的锯齿形层次遍历</title>
    <url>/2019/08/30/leetcode/101-200/103.er-cha-shu-de-ju-chi-xing-ceng-ci-bian-li/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p>
<span id="more"></span>

<p>例如：<br>给定二叉树 [3,9,20,null,null,15,7],</p>
<pre><code>    3
   / \
  9  20
    /  \
   15   7    
</code></pre>
<p>返回锯齿形层次遍历如下：</p>
<p>[<br>  [3],<br>  [20,9],<br>  [15,7]<br>]</p>
<h4 id="解法1：双端队列deque"><a href="#解法1：双端队列deque" class="headerlink" title="解法1：双端队列deque"></a>解法1：双端队列deque</h4><p>与101题类似。但每层扫描方向不同，所以可以采用双端队列，用heght变量明确当前层数，确定扫描方向。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">zigzagLevelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        deque&lt;TreeNode *&gt; que;</span><br><span class="line">        que.<span class="built_in">push_back</span>(root);</span><br><span class="line">        <span class="keyword">int</span> hight=<span class="number">0</span>;</span><br><span class="line">        TreeNode *p=<span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">            <span class="keyword">int</span> n=que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(hight%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    p=que.<span class="built_in">front</span>();</span><br><span class="line">                    que.<span class="built_in">pop_front</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    p=que.<span class="built_in">back</span>();</span><br><span class="line">                    que.<span class="built_in">pop_back</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                temp.<span class="built_in">push_back</span>(p-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(hight%<span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(p-&gt;right!=<span class="literal">NULL</span>)    que.<span class="built_in">push_front</span>(p-&gt;right);</span><br><span class="line">                    <span class="keyword">if</span>(p-&gt;left!=<span class="literal">NULL</span>)   que.<span class="built_in">push_front</span>(p-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(p-&gt;left!=<span class="literal">NULL</span>)    que.<span class="built_in">push_back</span>(p-&gt;left);</span><br><span class="line">                    <span class="keyword">if</span>(p-&gt;right!=<span class="literal">NULL</span>)   que.<span class="built_in">push_back</span>(p-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">            hight++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>101-200</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-104.二叉树的最大深度</title>
    <url>/2019/08/30/leetcode/101-200/104.er-cha-shu-de-zui-da-shen-du/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<span id="more"></span>

<p>示例：<br>给定二叉树 [3,9,20,null,null,15,7]，</p>
<pre><code>    3
   / \
  9  20
    /  \
   15   7
</code></pre>
<p>返回它的最大深度 3 。</p>
<h4 id="解法1：递归"><a href="#解法1：递归" class="headerlink" title="解法1：递归"></a>解法1：递归</h4><p>DFS深度扫描</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> max;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        max=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">frontfind</span>(root,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">frontfind</span><span class="params">(TreeNode *root,<span class="keyword">int</span> height)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(max&lt;height)</span><br><span class="line">                max=height;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">frontfind</span>(root-&gt;left,height+<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">frontfind</span>(root-&gt;right,height+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="解法2：迭代"><a href="#解法2：迭代" class="headerlink" title="解法2：迭代"></a>解法2：迭代</h4><p>队列实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        queue&lt;TreeNode *&gt;que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        TreeNode *p=<span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> height=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> n=que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                p=que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(p-&gt;left) que.<span class="built_in">push</span>(p-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(p-&gt;right)    que.<span class="built_in">push</span>(p-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            height++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>101-200</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>队列</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-106.从中序与前序遍历序列构造二叉树</title>
    <url>/2019/09/01/leetcode/101-200/106.cong-zhong-xu-yu-hou-xu-bian-li-xu-lie-gou-zao-er-cha-shu/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>根据一棵树的中序遍历与后序遍历构造二叉树。</p>
<p>注意:<br>你可以假设树中没有重复的元素。</p>
<p>例如，给出</p>
<p>中序遍历 inorder = [9,3,15,20,7]<br>后序遍历 postorder = [9,15,7,20,3]</p>
<span id="more"></span>

<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal">https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法1：递归"><a href="#解法1：递归" class="headerlink" title="解法1：递归"></a>解法1：递归</h4><p>该题与105题类似，与上题一样思想，换为中序与后序即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; inorders;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; postorders;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; inorder, vector&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;inorders=inorder;</span><br><span class="line">        <span class="keyword">this</span>-&gt;postorders=postorder;</span><br><span class="line">        <span class="keyword">int</span> n=inorder.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(<span class="number">0</span>,n<span class="number">-1</span>,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode *<span class="title">find</span><span class="params">(<span class="keyword">int</span> pol,<span class="keyword">int</span> por,<span class="keyword">int</span> inl,<span class="keyword">int</span> inr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pol&gt;por||inl&gt;inr)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> val=postorders[por];</span><br><span class="line">        <span class="keyword">while</span>(inorders[l]!=val)</span><br><span class="line">            l++;</span><br><span class="line">        </span><br><span class="line">        TreeNode *root=<span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">        </span><br><span class="line">        root-&gt;left=<span class="built_in">find</span>(pol,l<span class="number">-1</span>-inl+pol,inl,l<span class="number">-1</span>);   <span class="comment">// po 和 in 区间长度相等</span></span><br><span class="line">        root-&gt;right=<span class="built_in">find</span>(por-inr+l,por<span class="number">-1</span>,l+<span class="number">1</span>,inr);  <span class="comment">// po 和 in 区间长度应相等</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>101-200</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-105.从前序与中序遍历序列构造二叉树</title>
    <url>/2019/09/01/leetcode/101-200/105.cong-qian-xu-yu-zhong-xu-bian-li-xu-lie-gou-zao-er-cha-shu/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>根据一棵树的前序遍历与中序遍历构造二叉树。</p>
<p>注意:<br>你可以假设树中没有重复的元素。</p>
<p>例如，给出</p>
<p>前序遍历 preorder = [3,9,20,15,7]<br>中序遍历 inorder = [9,3,15,20,7]</p>
<span id="more"></span>

<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal">https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法1：递归"><a href="#解法1：递归" class="headerlink" title="解法1：递归"></a>解法1：递归</h4><p>通过二叉树前序遍历，中序遍历性质可知，当前二叉树的根总在前序遍历的第一位，</p>
<p>通过中序遍历找到该节点的位置，在中序数组中，该节点左侧即为该节点的左子树，该节点的右侧为该节点的右子树，循环递归，则构成了一颗二叉树</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; preorders;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; inorders;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; preorder, vector&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;preorders=preorder;</span><br><span class="line">        <span class="keyword">this</span>-&gt;inorders=inorder;</span><br><span class="line">        <span class="keyword">int</span> n=preorder.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> m=inorder.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(preorder.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(<span class="number">0</span>,n<span class="number">-1</span>,<span class="number">0</span>,m<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode *<span class="title">find</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> ni,<span class="keyword">int</span> j,<span class="keyword">int</span> mj)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;ni||j&gt;mj)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> rootval=preorders[i];</span><br><span class="line">        <span class="keyword">int</span> l=j;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=mj&amp;&amp;inorders[l]!=rootval)</span><br><span class="line">        &#123;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode *root=<span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootval);</span><br><span class="line">        root-&gt;left=<span class="built_in">find</span>(i+<span class="number">1</span>,i+l-j,j,l<span class="number">-1</span>);		<span class="comment">//pre ino 区间长度要相等</span></span><br><span class="line">        root-&gt;right=<span class="built_in">find</span>(i+l-j+<span class="number">1</span>,ni,l+<span class="number">1</span>,mj);	</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>101-200</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-107.二叉树的层次遍历II</title>
    <url>/2019/09/04/leetcode/101-200/107.er-cha-shu-de-ceng-ci-bian-li-ii/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p>
<span id="more"></span>

<p>例如：<br>给定二叉树 [3,9,20,null,null,15,7],</p>
<pre><code>    3
   / \
  9  20
    /  \
   15   7
</code></pre>
<p>返回其自底向上的层次遍历为：</p>
<p>[<br>  [15,7],<br>  [9,20],<br>  [3]<br>]</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii">https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法1：队列"><a href="#解法1：队列" class="headerlink" title="解法1：队列"></a>解法1：队列</h4><p>与二叉树层次遍历一样，最后reverse一下，或者直接在头insert插入（但这样速度明显要慢下来）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">levelOrderBottom</span>(TreeNode* root) &#123;</span><br><span class="line">        queue&lt;TreeNode *&gt; que;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        </span><br><span class="line">        TreeNode *p=<span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> n=que.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                p=que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                temp.<span class="built_in">push_back</span>(p-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(p-&gt;left!=<span class="literal">NULL</span>)   que.<span class="built_in">push</span>(p-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(p-&gt;right!=<span class="literal">NULL</span>)   que.<span class="built_in">push</span>(p-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>101-200</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-108.将有序数组转换为二叉搜索树</title>
    <url>/2019/09/04/leetcode/101-200/108.jiang-you-xu-shu-zu-zhuan-huan-wei-er-cha-sou-suo-shu/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</p>
<p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p>
<span id="more"></span>

<p>示例:</p>
<p>给定有序数组: [-10,-3,0,5,9],</p>
<p>一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：</p>
<pre><code>      0
     / \
    -3   9
   /   /
 -10  5
</code></pre>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree">https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法1：递归-二分"><a href="#解法1：递归-二分" class="headerlink" title="解法1：递归+二分"></a>解法1：递归+二分</h4><p>思路：</p>
<p>1.若对一个有序数组建一个相对平衡的二叉搜索树，那么根节点一定是中间元素，中间元素的左边肯定是左子树，右边是右子树，同样对于左子树，根节点一定是中间元素。。。。。。类推下去，发现符合递归特性</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; numsa;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">this</span>-&gt;numsa=nums;</span><br><span class="line">        <span class="keyword">int</span> lefts=<span class="number">0</span>,rights=n<span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bulid</span>(lefts,rights);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode *<span class="title">bulid</span><span class="params">(<span class="keyword">int</span> lefts,<span class="keyword">int</span> rights)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lefts&gt;rights)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> mid=lefts+(rights-lefts)/<span class="number">2</span>;</span><br><span class="line">        TreeNode *root=<span class="keyword">new</span> <span class="built_in">TreeNode</span>(numsa[mid]);</span><br><span class="line">        root-&gt;left=<span class="built_in">bulid</span>(lefts,mid<span class="number">-1</span>);</span><br><span class="line">        root-&gt;right=<span class="built_in">bulid</span>(mid+<span class="number">1</span>,rights);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>101-200</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>二分</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-109.有序链表转换为二叉搜索树</title>
    <url>/2019/09/05/leetcode/101-200/109.you-xu-lian-biao-zhuan-huan-wei-er-cha-sou-suo-shu/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。</p>
<p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p>
<span id="more"></span>

<p>示例:</p>
<p>给定的有序链表： [-10, -3, 0, 5, 9],</p>
<p>一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：</p>
<pre><code>      0
     / \
    -3   9
   /   /
 -10  5
</code></pre>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree">https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法1：快慢指针"><a href="#解法1：快慢指针" class="headerlink" title="解法1：快慢指针"></a>解法1：快慢指针</h4><p>由于是链表我们不能直接获得中间数所在的位置，所以我们创建一个快慢指针，前指针移动两次，后指针移动一次，后指针也就能刚好到中间位置，其余与108题解题思路一样，同样是递归，二分</p>
<p>注意代码中的一些小细节，特殊处理一下当前后指针没有动的情况</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedListToBST</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(head,head);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode *<span class="title">find</span><span class="params">(ListNode *p1,ListNode *head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p1==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode *lefts=p1;</span><br><span class="line">        ListNode *p2=p1-&gt;next;</span><br><span class="line">        ListNode *p=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">while</span>(p2!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p=p1;</span><br><span class="line">            p1=p1-&gt;next;</span><br><span class="line">            </span><br><span class="line">            p2=p2-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(p2==<span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            p2=p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode *root=<span class="keyword">new</span> <span class="built_in">TreeNode</span>(p1-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(p1==lefts)</span><br><span class="line">            lefts=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        root-&gt;left=<span class="built_in">find</span>(lefts,head);</span><br><span class="line">        root-&gt;right=<span class="built_in">find</span>(p1-&gt;next,head);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(nlogn)</p>
<h4 id="解法2：转换为数组"><a href="#解法2：转换为数组" class="headerlink" title="解法2：转换为数组"></a>解法2：转换为数组</h4><p>直接遍历一遍链表创建一个新的数组，对数组进行操作，也就与108题完全一样了</p>
]]></content>
      <categories>
        <category>101-200</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>递归</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-110. 平衡二叉树</title>
    <url>/2021/10/26/leetcode/101-200/110.ping-heng-er-cha-shu/</url>
    <content><![CDATA[<p>题目链接：<a href="https://leetcode-cn.com/problems/balanced-binary-tree/">https://leetcode-cn.com/problems/balanced-binary-tree/</a> </p>
<h4 id="解法1：递归"><a href="#解法1：递归" class="headerlink" title="解法1：递归"></a>解法1：递归</h4><p>思路：</p>
<p>判断每一个节点的左子树和右子树高度，若左右高度差大于1直接返回false</p>
<span id="more"></span>

<p>按照这个思路我们能写出下面两个代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="built_in">highbool</span>(root-&gt;left,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> r=<span class="built_in">highbool</span>(root-&gt;right,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(l-r)&lt;=<span class="number">1</span>&amp;&amp;<span class="built_in">isBalanced</span>(root-&gt;left)&amp;&amp;<span class="built_in">isBalanced</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">highbool</span><span class="params">(TreeNode *root,<span class="keyword">int</span> height)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> height;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">highbool</span>(root-&gt;left,height+<span class="number">1</span>),<span class="built_in">highbool</span>(root-&gt;right,height+<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们还可加一个私有变量，全局保存res的返回值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> res;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        res=<span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">highbool</span>(root,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">highbool</span><span class="params">(TreeNode *root,<span class="keyword">int</span> height)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> height;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="built_in">highbool</span>(root-&gt;left,height+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> r=<span class="built_in">highbool</span>(root-&gt;right,height+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(l-r)&gt;<span class="number">1</span>)  res=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(l,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>101-200</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-111. 二叉树的最小深度</title>
    <url>/2021/10/26/leetcode/101-200/111.er-cha-shu-de-zui-xiao-shen-du/</url>
    <content><![CDATA[<p>题目链接：<a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/</a> </p>
<h4 id="解法1：递归"><a href="#解法1：递归" class="headerlink" title="解法1：递归"></a>解法1：递归</h4><p>判断每个节点左右节点</p>
<p>1.若没有左右子树，则这是个叶子节点返回其高度值</p>
<p>2.若没有左子树，返回右子树的高度值</p>
<p>3.若没有右子树，返回左子树的高度值</p>
<p>4.若左右子树都有，返回左右子树的较少值</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">low</span>(root,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">low</span><span class="params">(TreeNode *root,<span class="keyword">int</span> lows)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">NULL</span>&amp;&amp;root-&gt;right==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> lows+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">low</span>(root-&gt;right,lows+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">low</span>(root-&gt;left,lows+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(<span class="built_in">low</span>(root-&gt;left,lows+<span class="number">1</span>),<span class="built_in">low</span>(root-&gt;right,lows+<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>101-200</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-112. 路径总和</title>
    <url>/2021/10/26/leetcode/101-200/112.lu-jing-zong-he/</url>
    <content><![CDATA[<p>题目链接：<a href="https://leetcode-cn.com/problems/path-sum/">https://leetcode-cn.com/problems/path-sum/</a> </p>
<h4 id="解法1：dfs"><a href="#解法1：dfs" class="headerlink" title="解法1：dfs"></a>解法1：dfs</h4><p>思路：</p>
<p>dfs扫描树，没到一个节点sum-=root-&gt;val</p>
<p>若sum==0且这个点为叶子节点，则直接返回true</p>
<span id="more"></span>

<p>遍历整棵树</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ok</span>(root,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">ok</span><span class="params">(TreeNode *root,<span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        sum-=root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(sum==<span class="number">0</span>&amp;&amp;root-&gt;left==<span class="literal">NULL</span>&amp;&amp;root-&gt;right==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ok</span>(root-&gt;left,sum)||<span class="built_in">ok</span>(root-&gt;right,sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>101-200</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-113. 路径总和 II</title>
    <url>/2021/10/26/leetcode/101-200/113.lu-jing-zong-he-ii/</url>
    <content><![CDATA[<p>题目链接：<a href="https://leetcode-cn.com/problems/path-sum-ii/solution/">https://leetcode-cn.com/problems/path-sum-ii/solution/</a> </p>
<h4 id="解法1：回溯"><a href="#解法1：回溯" class="headerlink" title="解法1：回溯"></a>解法1：回溯</h4><p>与112题一样的思路，这次记录下走过的节点</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">pathSum</span>(TreeNode* root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">        <span class="built_in">ok</span>(root,sum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ok</span><span class="params">(TreeNode *root,<span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        temp.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(sum-root-&gt;val==<span class="number">0</span>&amp;&amp;root-&gt;left==<span class="literal">NULL</span>&amp;&amp;root-&gt;right==<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">ok</span>(root-&gt;left,sum-(root-&gt;val));</span><br><span class="line">            temp.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">ok</span>(root-&gt;right,sum-(root-&gt;val));</span><br><span class="line">            temp.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>101-200</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-114. 二叉树展开为链表</title>
    <url>/2021/10/26/leetcode/101-200/114.er-cha-shu-zhan-kai-wei-lian-biao/</url>
    <content><![CDATA[<p>题目描述：<a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/">https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/</a> </p>
<h4 id="解法1：递归"><a href="#解法1：递归" class="headerlink" title="解法1：递归"></a>解法1：递归</h4><p>采用后序遍历，对二叉树进行展开操作</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">flatten</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">flatten</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> pre=root-&gt;left;</span><br><span class="line">            <span class="keyword">while</span>(pre-&gt;right!=<span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                pre=pre-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            pre-&gt;right=root-&gt;right;</span><br><span class="line">            root-&gt;right=root-&gt;left;</span><br><span class="line">            root-&gt;left=<span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="解法2：非递归"><a href="#解法2：非递归" class="headerlink" title="解法2：非递归"></a>解法2：非递归</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">while</span>(root!=<span class="literal">NULL</span>)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">if</span>(root-&gt;left!=<span class="literal">NULL</span>)</span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="keyword">auto</span> pre=root-&gt;left;</span><br><span class="line">                  <span class="keyword">while</span>(pre-&gt;right!=<span class="literal">NULL</span>)</span><br><span class="line">                  &#123;</span><br><span class="line">                      pre=pre-&gt;right;</span><br><span class="line">                  &#125;</span><br><span class="line">                  pre-&gt;right=root-&gt;right;</span><br><span class="line">                  root-&gt;right=root-&gt;left;</span><br><span class="line">                  root-&gt;left=<span class="literal">NULL</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//移动根节点</span></span><br><span class="line">              root=root-&gt;right;</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>101-200</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-115. 不同的子序列</title>
    <url>/2021/10/26/leetcode/101-200/115.bu-tong-de-zi-xu-lie/</url>
    <content><![CDATA[<p>题目：<a href="https://leetcode-cn.com/problems/distinct-subsequences/">https://leetcode-cn.com/problems/distinct-subsequences/</a> </p>
<h4 id="解法1：动态规划"><a href="#解法1：动态规划" class="headerlink" title="解法1：动态规划"></a>解法1：动态规划</h4><p>t为目标字符串，s为查找字符串</p>
<span id="more"></span>

<p>思路：</p>
<p>1.dp[i][j]表示t的前i字符串与s的前j字符串能形成符合要求的不同子序列的个数</p>
<p>2.dp[0][j]=1;即t为空字符串时的情况</p>
<p>3.状态转移方程：</p>
<p>​    s[j]!=t[i]时,dp[i][j]=dp[i][j-1]，即当前最多子序列个数，与j-1时的子序列个数相同</p>
<p>​    s[j]=t[i]时,dp[i][j]=dp[i][j-1]+dp[i-1][j-1]，即当前最多子序列个数，由j-1时子序列个数和s，t各减少一个字符的子序列个数组成</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=s.<span class="built_in">length</span>(),m=t.<span class="built_in">length</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt; <span class="built_in">dp</span>(m+<span class="number">1</span>,vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(n+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j]=dp[i][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">if</span>(s[j<span class="number">-1</span>]==t[i<span class="number">-1</span>])</span><br><span class="line">                    dp[i][j]+=dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>101-200</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-116. 填充每个节点的下一个右侧节点指针</title>
    <url>/2021/10/26/leetcode/101-200/116.tian-chong-mei-ge-jie-dian-de-xia-yi-ge-you-ce-jie-dian-zhi-zhen/</url>
    <content><![CDATA[<p>题目：<a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/">https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/</a> </p>
<h4 id="解法1：BFS"><a href="#解法1：BFS" class="headerlink" title="解法1：BFS"></a>解法1：BFS</h4><p>思路：</p>
<p>额外空间复杂度O（n）</p>
<p>bfs广度优先搜索</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        queue&lt;Node *&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        Node *p=<span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> n=que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                p=que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(i==n<span class="number">-1</span>)</span><br><span class="line">                &#123;&#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    p-&gt;next=que.<span class="built_in">front</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(p-&gt;left!=<span class="literal">NULL</span>)   que.<span class="built_in">push</span>(p-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(p-&gt;right!=<span class="literal">NULL</span>)  que.<span class="built_in">push</span>(p-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="解法2：递归"><a href="#解法2：递归" class="headerlink" title="解法2：递归"></a>解法2：递归</h4><p>前序遍历，判断其每个节点的左孩子以及若有next节点，使其右孩子的next链到next的左孩子</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;left-&gt;next=root-&gt;right;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                root-&gt;right-&gt;next=root-&gt;next-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">connect</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">connect</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="解法3：迭代"><a href="#解法3：迭代" class="headerlink" title="解法3：迭代"></a>解法3：迭代</h4><p>思考：</p>
<p>每一次都是从最左边的左孩子开始，每向下一层都将上面的全部链接好</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> pre=root;</span><br><span class="line">        <span class="keyword">while</span>(pre!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> cur=pre;</span><br><span class="line">            <span class="keyword">while</span>(cur!=<span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;left!=<span class="literal">NULL</span>)</span><br><span class="line">                    cur-&gt;left-&gt;next=cur-&gt;right;</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;right!=<span class="literal">NULL</span>&amp;&amp;cur-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    cur-&gt;right-&gt;next=cur-&gt;next-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">                cur=cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            pre=pre-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>101-200</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>递归</tag>
        <tag>迭代</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-117. 填充每个节点的下一个右侧节点指针 II</title>
    <url>/2021/10/26/leetcode/101-200/117.tian-chong-mei-ge-jie-dian-de-xia-yi-ge-you-ce-jie-dian-zhi-zhen-ii/</url>
    <content><![CDATA[<p>题目：<a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/">https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/</a> </p>
<h4 id="解法1：迭代"><a href="#解法1：迭代" class="headerlink" title="解法1：迭代"></a>解法1：迭代</h4><p>与116题类似</p>
<p>加一个指针变量存当前位置指针</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> pre=root;</span><br><span class="line">        <span class="keyword">while</span>(pre!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//注意这里，由于不是完美二叉树，有些同一层节点有的是叶子节点，而有的还有孩子节点</span></span><br><span class="line">            <span class="keyword">while</span>(pre&amp;&amp;pre-&gt;left==<span class="literal">NULL</span>&amp;&amp;pre-&gt;right==<span class="literal">NULL</span>)   pre=pre-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(pre==<span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">auto</span> temp=pre;</span><br><span class="line">            Node *cur=<span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">while</span>(temp!=<span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;left!=<span class="literal">NULL</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(cur!=<span class="literal">NULL</span>)</span><br><span class="line">                        cur-&gt;next=temp-&gt;left;</span><br><span class="line">                    cur=temp-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;right!=<span class="literal">NULL</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(cur!=<span class="literal">NULL</span>)</span><br><span class="line">                        cur-&gt;next=temp-&gt;right;</span><br><span class="line">                    cur=temp-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                temp=temp-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            pre=pre-&gt;left!=<span class="literal">NULL</span>?pre-&gt;left:pre-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>101-200</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>迭代</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-118. 杨辉三角</title>
    <url>/2021/10/26/leetcode/101-200/118.yang-hui-san-jiao/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/pascals-triangle/">https://leetcode-cn.com/problems/pascals-triangle/</a> </p>
<h4 id="解法1-迭代"><a href="#解法1-迭代" class="headerlink" title="解法1:迭代"></a>解法1:迭代</h4><p>思路：</p>
<p>每一行的第一列和最后一列为1，其余列都是上一行对应列和上一行对应列-1之和</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">generate</span>(<span class="keyword">int</span> numRows) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">res</span>(numRows);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numRows;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res[i].<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i+<span class="number">1</span>;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j==i)</span><br><span class="line">                &#123;</span><br><span class="line">                    res[i].<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    res[i].<span class="built_in">push_back</span>(res[i<span class="number">-1</span>][j<span class="number">-1</span>]+res[i<span class="number">-1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>101-200</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>迭代</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-120. 三角形最小路径和</title>
    <url>/2021/10/26/leetcode/101-200/120.san-jiao-xing-zui-xiao-lu-jing-he/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/triangle/">https://leetcode-cn.com/problems/triangle/</a> </p>
<h4 id="解法1：动态规划"><a href="#解法1：动态规划" class="headerlink" title="解法1：动态规划"></a>解法1：动态规划</h4><p>题目要求O（n）的空间复杂度</p>
<p>所以我们要对状态转移方程进行压缩</p>
<span id="more"></span>

<p>我们首先写二维的状态转移方程dp[i][j]表示从第i行第j列走到底部要的路径和</p>
<p>dp[i][j]=min(dp[i+1][j],dp[i+1][j+1])+triangle[i][j];</p>
<p>现在我们对状态转移方程进行压缩</p>
<p>我们用一维的状态转移方程dp2[j]表示从当前行的j列走到底部要的路径和</p>
<p>我们发现可以将状态转移方程改写为dp[j]=min(dp[j],dp[j+1])+triangle[i][j];</p>
<p>我们从底部向上进行dp转移</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=triangle.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;triangle[i].<span class="built_in">size</span>();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i&lt;n<span class="number">-1</span>)</span><br><span class="line">                    dp[j]=<span class="built_in">min</span>(dp[j],dp[j+<span class="number">1</span>])+triangle[i][j];</span><br><span class="line">                <span class="keyword">else</span> dp[j]+=triangle[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>101-200</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-119. 杨辉三角II</title>
    <url>/2021/10/26/leetcode/101-200/119.yang-hui-san-jiao-ii/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/pascals-triangle-ii/">https://leetcode-cn.com/problems/pascals-triangle-ii/</a> </p>
<h4 id="解法1：迭代"><a href="#解法1：迭代" class="headerlink" title="解法1：迭代"></a>解法1：迭代</h4><p>要求空间复杂度为k</p>
<p>将118题压缩成只保留当前行</p>
<p>当前行对应元素从右往左更新，当前列=当前列+（当前列-1）对应元素之和</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=rowIndex;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i<span class="number">-1</span>;j&gt;<span class="number">0</span>;j--)</span><br><span class="line">            &#123;</span><br><span class="line">                res[j]+=res[j<span class="number">-1</span>];   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>101-200</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>迭代</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-122. 买卖股票的最佳时机 II</title>
    <url>/2021/10/26/leetcode/101-200/122.mai-mai-gu-piao-de-zui-jia-shi-ji-ii/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/</a> </p>
<h4 id="解法1：贪心"><a href="#解法1：贪心" class="headerlink" title="解法1：贪心"></a>解法1：贪心</h4><p>与121题不同，这题可以多次买卖没有对交易次数限制，所以我们可以采用贪心策略，只要赚钱，我们就将股票出售</p>
<p>buyday记录购买日期，i遍历数组，若第i天大于buyday时的价格就让结果值加上这个利润，且更新buyday=i</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> buyday=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i]&lt;prices[buyday])</span><br><span class="line">                buyday=i;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(prices[i]&gt;prices[buyday])</span><br><span class="line">            &#123;</span><br><span class="line">                res+=prices[i]-prices[buyday];</span><br><span class="line">                buyday=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>101-200</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-121. 买卖股票的最佳时机</title>
    <url>/2021/10/26/leetcode/101-200/121.mai-mai-gu-piao-de-zui-jia-shi-ji/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/</a> </p>
<h4 id="解法1：双指针"><a href="#解法1：双指针" class="headerlink" title="解法1：双指针"></a>解法1：双指针</h4><p>buy指针记录购买时的价格，i指针遍历数组</p>
<p>若当前价格小于buy价格，则更新buy价格</p>
<p>若当前价格-buy价格大于当前最大利润，则更新当前最大利润</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> buy=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i]&lt;prices[buy])</span><br><span class="line">                buy=i;</span><br><span class="line">            <span class="keyword">if</span>(prices[i]-prices[buy]&gt;res)</span><br><span class="line">                res=prices[i]-prices[buy];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>101-200</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-123. 买卖股票的最佳时机 III</title>
    <url>/2021/10/26/leetcode/101-200/123.mai-mai-gu-piao-de-zui-jia-shi-ji-iii/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/</a> </p>
<h4 id="解法1：动态规划"><a href="#解法1：动态规划" class="headerlink" title="解法1：动态规划"></a>解法1：动态规划</h4><p>1.dp[i][k]表示第i天交易k次所能获得的最大利润</p>
<p>dp[i][k]有两种操作可以求出来，1.第i天什么都不做，那么dp[i][k]=dp[i-1][k].2.第i天选择卖出，既然选择了卖出，那么0-i-1天就要选择一天进行买入，且在买入前已经进行了k-1次交易。</p>
<span id="more"></span>

<p>我们用mins表示第1天到第i天prices[buy]-dp[buy][k-1]的最小值，（这样我们便能取得第i天卖出的最大利润）</p>
<p>然后比较dp[i-1][k]和prices[i]-mins，选择第i天到达进行什么操作</p>
<p>其中mins=min(mins,prices[i]-dp[i][k-1])</p>
<p>dp[i][k]=max(dp[i-1][k],prices[i]-mins)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(n,vector&lt;<span class="keyword">int</span>&gt;(<span class="number">3</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">2</span>;k++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mins=prices[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                mins=<span class="built_in">min</span>(mins,prices[i]-dp[i][k<span class="number">-1</span>]);</span><br><span class="line">                dp[i][k]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][k],prices[i]-mins);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>][<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="解法2：优化时间复杂度"><a href="#解法2：优化时间复杂度" class="headerlink" title="解法2：优化时间复杂度"></a>解法2：优化时间复杂度</h4><p>上面一种解法先将k放在外循环，i放在内循环，我们也可以对换位置，只要将mins赋对应初值即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">3</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> mins[<span class="number">3</span>];</span><br><span class="line">        mins[<span class="number">0</span>]=prices[<span class="number">0</span>];</span><br><span class="line">        mins[<span class="number">1</span>]=prices[<span class="number">0</span>];</span><br><span class="line">        mins[<span class="number">2</span>]=prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">2</span>;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                mins[k]=<span class="built_in">min</span>(mins[k],prices[i]-dp[k<span class="number">-1</span>]);</span><br><span class="line">                dp[k]=<span class="built_in">max</span>(dp[k],prices[i]-mins[k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="解法3：优化空间复杂度"><a href="#解法3：优化空间复杂度" class="headerlink" title="解法3：优化空间复杂度"></a>解法3：优化空间复杂度</h4><p>上面的方法用了O（n）的空间复杂度，分析发现我们可以用O（1）的空间复杂度</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min1=prices[<span class="number">0</span>],min2=prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> dp1=<span class="number">0</span>,dp2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            min1=<span class="built_in">min</span>(min1,prices[i]<span class="number">-0</span>);</span><br><span class="line">            dp1=<span class="built_in">max</span>(dp1,prices[i]-min1);</span><br><span class="line">            </span><br><span class="line">            min2=<span class="built_in">min</span>(min2,prices[i]-dp1);</span><br><span class="line">            dp2=<span class="built_in">max</span>(dp2,prices[i]-min2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>101-200</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-125. 验证回文串</title>
    <url>/2021/10/26/leetcode/101-200/125.yan-zheng-hui-wen-chuan/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/valid-palindrome/">https://leetcode-cn.com/problems/valid-palindrome/</a> </p>
<h4 id="解法1：双指针"><a href="#解法1：双指针" class="headerlink" title="解法1：双指针"></a>解法1：双指针</h4><p>思路：</p>
<p>先将字符串中字母全部转换为小写，然后将其中的字符和数字写入到新的字符串，然后左右指针进行比较</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">transform</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>(),s.<span class="built_in">begin</span>(),::tolower);</span><br><span class="line">        string str=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&#x27;a&#x27;</span>&lt;=s[i]&amp;&amp;s[i]&lt;=<span class="string">&#x27;z&#x27;</span>||<span class="string">&#x27;0&#x27;</span>&lt;=s[i]&amp;&amp;s[i]&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">                str+=s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=str.<span class="built_in">length</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i]!=str[j])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>101-200</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-124. 二叉树中的最大路径和</title>
    <url>/2021/10/26/leetcode/101-200/124.er-cha-shu-zhong-de-zui-da-lu-jing-he/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/</a> </p>
<h4 id="解法1：递归"><a href="#解法1：递归" class="headerlink" title="解法1：递归"></a>解法1：递归</h4><p>思路：</p>
<p>以abc二叉树为例a是递归中的根节点，b，c是左右子节点（代表递归后的最优解）</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  a</span><br><span class="line"> / \</span><br><span class="line">b   c</span><br></pre></td></tr></table></figure>

<p>则最大路径有这么三种情况：</p>
<p>1.b+a+c</p>
<p>2.b+a+a的父节点</p>
<p>3.c+a+a的父节点</p>
<p>注意：其中节点有可能是负值，最大和要想办法舍弃负值（max（0，x））</p>
<p>所以我们可以递归，同时记录全局最大和，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> res=INT_MIN;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">maxp</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxp</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="built_in">maxp</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> r=<span class="built_in">maxp</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">int</span> les=<span class="built_in">max</span>(l,<span class="number">0</span>)+<span class="built_in">max</span>(r,<span class="number">0</span>)+root-&gt;val;</span><br><span class="line">        <span class="keyword">int</span> ret=root-&gt;val+<span class="built_in">max</span>(<span class="number">0</span>,<span class="built_in">max</span>(l,r));</span><br><span class="line">        res=<span class="built_in">max</span>(res,<span class="built_in">max</span>(les,ret));</span><br><span class="line">        <span class="comment">//注意返回值，我们要返回当前节点和左子树的最大值或当前节点和右子树的最大值</span></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>101-200</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-126. 单词接龙 II</title>
    <url>/2021/10/26/leetcode/101-200/126.dan-ci-jie-long-ii/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>101-200</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-160. 相交链表</title>
    <url>/2021/10/26/leetcode/101-200/160.xiang-jiao-lian-biao/</url>
    <content><![CDATA[<h4 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">160. 相交链表</a></h4><h5 id="解法：快慢指针"><a href="#解法：快慢指针" class="headerlink" title="解法：快慢指针"></a>解法：快慢指针</h5><p>我们需要做的事情是，让两个链表从同距离末尾同等距离的位置开始遍历。这个位置只能是较短链表的头结点位置。<br>为此，我们必须消除两个链表的长度差</p>
<p>指针 pA 指向 A 链表，指针 pB 指向 B 链表，依次往后遍历<br>如果 pA 到了末尾，则 pA = headB 继续遍历<br>如果 pB 到了末尾，则 pB = headA 继续遍历<br>比较长的链表指针指向较短链表head时，长度差就消除了<br>如此，只需要将最短链表遍历两次即可找到位置</p>
<p>如果两链表不相交，则遍历两次后，都指向空</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> a=headA;</span><br><span class="line">        <span class="keyword">auto</span> b=headB;</span><br><span class="line">        <span class="keyword">while</span>(a!=b)</span><br><span class="line">        &#123;</span><br><span class="line">            a= a==<span class="literal">NULL</span>?headB:a-&gt;next;</span><br><span class="line">            b= b==<span class="literal">NULL</span>?headA:b-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>101-200</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-142. 环形链表 II</title>
    <url>/2021/10/26/leetcode/101-200/142.huan-xing-lian-biao-ii/</url>
    <content><![CDATA[<h4 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h4><h5 id="解法1：set"><a href="#解法1：set" class="headerlink" title="解法1：set"></a>解法1：set</h5><p>用set存走过的节点，若后面走过的点已经在set中直接返回该节点</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        set&lt;ListNode *&gt; s;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">find</span>(head)!=s.<span class="built_in">end</span>())</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            s.<span class="built_in">insert</span>(head);</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="解法2：Floyd算法"><a href="#解法2：Floyd算法" class="headerlink" title="解法2：Floyd算法"></a>解法2：Floyd算法</h5><p>阶段1：</p>
<p>一个指针每次走两步，一个每次走一步，若两指针在某时刻相同，表示有环，且记录该节点位置</p>
<p>阶段2：</p>
<p>一个指针从头开始，一个从刚才记录位置开始，当两指针相遇就找到了入环的第一个节点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *p=head;</span><br><span class="line">        ListNode *ph=head;</span><br><span class="line">        ListNode *f;</span><br><span class="line">        <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(p&amp;&amp;p-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            p=p-&gt;next-&gt;next;</span><br><span class="line">            ph=ph-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(ph==p)</span><br><span class="line">            &#123;</span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">                f=ph;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag)  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        p=head;</span><br><span class="line">        <span class="keyword">while</span>(p!=f)</span><br><span class="line">        &#123;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">            f=f-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>101-200</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-第10场双周赛</title>
    <url>/2019/10/06/leetcode/zhou-sai/di-10-chang-shuang-zhou-sai/</url>
    <content><![CDATA[<h4 id="5079-三个有序数组的交集"><a href="#5079-三个有序数组的交集" class="headerlink" title="5079.三个有序数组的交集"></a>5079.三个有序数组的交集</h4><h5 id="解法1：map"><a href="#解法1：map" class="headerlink" title="解法1：map"></a>解法1：map</h5><p>思路：</p>
<p>因为是严格递增不存在一个数组中存在两个相同的数</p>
<p>用map存每个数字出现的次数，若该数字次数达到3次添加到结果数组中。</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">arraysIntersection</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr1, vector&lt;<span class="keyword">int</span>&gt;&amp; arr2, vector&lt;<span class="keyword">int</span>&gt;&amp; arr3)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">int</span> n=arr1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            m[arr1[i]]++;</span><br><span class="line">            m[arr2[i]]++;</span><br><span class="line">            m[arr3[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::iterator ite=m.<span class="built_in">begin</span>();ite!=m.<span class="built_in">end</span>();ite++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ite-&gt;second==<span class="number">3</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(ite-&gt;first);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="5080-查找两棵二叉搜索树之和"><a href="#5080-查找两棵二叉搜索树之和" class="headerlink" title="5080.查找两棵二叉搜索树之和"></a>5080.查找两棵二叉搜索树之和</h4><h5 id="解法1：map-1"><a href="#解法1：map-1" class="headerlink" title="解法1：map"></a>解法1：map</h5><p>用map存第一棵树对应的target-root-&gt;val值，第二颗数查找这个值，若找到直接返回true</p>
<p>即转化为类似的两数之和</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="keyword">int</span> tar;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">twoSumBSTs</span><span class="params">(TreeNode* root1, TreeNode* root2, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        tar=target;</span><br><span class="line">        <span class="built_in">midbfs</span>(root1);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">midbfs2</span>(root2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">midbfs</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">midbfs</span>(root-&gt;left);</span><br><span class="line">            m[tar-root-&gt;val]++;</span><br><span class="line">            <span class="built_in">midbfs</span>(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">midbfs2</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(m[root-&gt;val]!=<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">midbfs2</span>(root-&gt;left)||<span class="built_in">midbfs2</span>(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="5081-步进数"><a href="#5081-步进数" class="headerlink" title="5081.步进数"></a>5081.步进数</h4><h5 id="解法1：预处理-二分"><a href="#解法1：预处理-二分" class="headerlink" title="解法1：预处理+二分"></a>解法1：预处理+二分</h5><p>找规律，发现除0-9这10个数，后面的步进数都是从1开始向后遍历加上一位和末位相差1的数，</p>
<p>例如根据1可以向后10，12，根据2可以向后添加21，23。根据这个规律我们就能快速找到所有小于high的步进数。</p>
<p>现在我们要找到从那个步进数开始是大于low的，这样我们可以采用二分查找，找到第一个大于low的或找到步进数的最后一位。</p>
<p>后处理判断找到的值是否大于low，</p>
<p>1.若小于表示在low-high内没有步进数</p>
<p>2.若大于将找到的步进数数组从left到结束添加到结果数组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">countSteppingNumbers</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">9</span>;i++)&#123;res.<span class="built_in">push_back</span>(i);&#125;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">1</span>,cur,k,temp;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cur=res[i];</span><br><span class="line">            k=cur%<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(k<span class="number">-1</span>&gt;=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                temp=cur*<span class="number">10</span>+k<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">if</span>(temp&gt;high)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(k+<span class="number">1</span>&lt;=<span class="number">9</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                temp=cur*<span class="number">10</span>+k+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(temp&gt;high)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=res.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(res[mid]&lt;low)</span><br><span class="line">            &#123;</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> right=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; anb;</span><br><span class="line">        <span class="keyword">if</span>(res[left]&lt;low)   <span class="keyword">return</span> anb;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(res.begin()+left,res.end())</span></span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="5099-验证回文字符串-III"><a href="#5099-验证回文字符串-III" class="headerlink" title="5099.验证回文字符串 III"></a>5099.验证回文字符串 III</h4><h5 id="解法1：动态规划"><a href="#解法1：动态规划" class="headerlink" title="解法1：动态规划"></a>解法1：动态规划</h5><p>问题的本质就是找一个最长回文子序列。</p>
<p>思路：</p>
<p>先创建一个字符串t是s的翻转字符串。这样我们就可以将问题转为找s和t的最长公共子序列</p>
<p>若最长公共子序列长度&gt;=n-k则符合要求。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidPalindrome</span><span class="params">(string s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">        string t=s;</span><br><span class="line">        <span class="built_in">reverse</span>(t.<span class="built_in">begin</span>(),t.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(n+<span class="number">1</span>,vector&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i]==t[j])  dp[i+<span class="number">1</span>][j+<span class="number">1</span>]=dp[i][j]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span>    dp[i+<span class="number">1</span>][j+<span class="number">1</span>]=<span class="built_in">max</span>(dp[i+<span class="number">1</span>][j],dp[i][j+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][n]&gt;=n-k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>周赛</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-第11场双周赛</title>
    <url>/2019/10/25/leetcode/zhou-sai/di-11-chang-shuang-zhou-sai/</url>
    <content><![CDATA[<p>待补充</p>
<span id="more"></span>]]></content>
      <categories>
        <category>周赛</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-第12场双周赛</title>
    <url>/2021/10/26/leetcode/zhou-sai/di-12-chang-shuang-zhou-sai/</url>
    <content><![CDATA[<h4 id="1243-数组变换"><a href="#1243-数组变换" class="headerlink" title="1243. 数组变换"></a><a href="https://leetcode-cn.com/problems/array-transformation/">1243. 数组变换</a></h4><h5 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h5><p>1.flag记录当前天的数组与上一天的数组是否相同，当相同时跳出循环</p>
<p>2.last记录上一天数组，now记录当前天数组，当当前天数组更新完毕后，要更新last数组为now数组</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">transformArray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">last</span><span class="params">(arr.begin(),arr.end())</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">now</span><span class="params">(arr.begin(),arr.end())</span></span>;</span><br><span class="line">        <span class="keyword">int</span> flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(flag)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(last[i]&gt;last[i<span class="number">-1</span>]&amp;&amp;last[i]&gt;last[i+<span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    now[i]--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(last[i]&lt;last[i<span class="number">-1</span>]&amp;&amp;last[i]&lt;last[i+<span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    now[i]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            flag=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(now[i]==last[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                last[i]=now[i];</span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> now;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1244-力扣排行榜"><a href="#1244-力扣排行榜" class="headerlink" title="1244. 力扣排行榜"></a><a href="https://leetcode-cn.com/problems/design-a-leaderboard/">1244. 力扣排行榜</a></h4><h5 id="解法：-1"><a href="#解法：-1" class="headerlink" title="解法："></a>解法：</h5><p>读懂题目意思很简单。实现类接口。。注意top()函数，按得分排序，得分为0的点不计入在内</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Leaderboard</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">     vector&lt;<span class="keyword">int</span>&gt;res;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Leaderboard</span>() &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res_</span><span class="params">(<span class="number">10010</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        res=res_;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addScore</span><span class="params">(<span class="keyword">int</span> playerId, <span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">        res[playerId]+=score;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">(<span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">temp</span><span class="params">(res.begin(),res.end())</span></span>;</span><br><span class="line">        <span class="built_in">sort</span>(temp.<span class="built_in">begin</span>(),temp.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> j=temp.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;K;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum+=temp[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(<span class="keyword">int</span> playerId)</span> </span>&#123;</span><br><span class="line">        res[playerId]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Leaderboard object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Leaderboard* obj = new Leaderboard();</span></span><br><span class="line"><span class="comment"> * obj-&gt;addScore(playerId,score);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;top(K);</span></span><br><span class="line"><span class="comment"> * obj-&gt;reset(playerId);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h4 id="1245-树的直径"><a href="#1245-树的直径" class="headerlink" title="1245. 树的直径"></a><a href="https://leetcode-cn.com/problems/tree-diameter/">1245. 树的直径</a></h4><h5 id="解法：两次BFS"><a href="#解法：两次BFS" class="headerlink" title="解法：两次BFS"></a>解法：两次BFS</h5><p>先从一点BFS遍历到最远的一点，然后从最远的那一点进行BFS记录能遍历到的最深距离即为树的直径</p>
<p>注意：</p>
<p>1.用邻接表记录每个点的连接,（不要用邻接矩阵，内存会爆掉的。。。亲身经历= =）</p>
<p>2.bool数组记录走过的点，防止进入死循环</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">treeDiameter</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=edges.<span class="built_in">size</span>()+<span class="number">1</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">e</span>(n,vector&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">used</span><span class="params">(n,<span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> edge:edges)</span><br><span class="line">        &#123;</span><br><span class="line">            e[edge[<span class="number">0</span>]].<span class="built_in">push_back</span>(edge[<span class="number">1</span>]);</span><br><span class="line">            e[edge[<span class="number">1</span>]].<span class="built_in">push_back</span>(edge[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">        used[<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> q;</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> size=que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                q=que.<span class="built_in">front</span>();que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> y:e[q])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(used[y]!=<span class="literal">true</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        used[y]=<span class="literal">true</span>;</span><br><span class="line">                        que.<span class="built_in">push</span>(y);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) used[i]=<span class="literal">false</span>;</span><br><span class="line">        used[q]=<span class="literal">true</span>;</span><br><span class="line">        que.<span class="built_in">push</span>(q);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">int</span> size=que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                q=que.<span class="built_in">front</span>();que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> y:e[q])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(used[y]!=<span class="literal">true</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        used[y]=<span class="literal">true</span>;</span><br><span class="line">                        que.<span class="built_in">push</span>(y);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1246-删除回文子数组"><a href="#1246-删除回文子数组" class="headerlink" title="1246. 删除回文子数组"></a><a href="https://leetcode-cn.com/problems/palindrome-removal/">1246. 删除回文子数组</a></h4><p>同样的第四题，同样的靠二哥的讲解</p>
<h5 id="解法：区间dp"><a href="#解法：区间dp" class="headerlink" title="解法：区间dp"></a>解法：区间dp</h5>]]></content>
      <categories>
        <category>周赛</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-第13场双周赛</title>
    <url>/2021/10/26/leetcode/zhou-sai/di-13-chang-shuang-zhou-sai/</url>
    <content><![CDATA[<h4 id="1256-加密数字"><a href="#1256-加密数字" class="headerlink" title="1256. 加密数字"></a><a href="https://leetcode-cn.com/problems/encode-number/">1256. 加密数字</a></h4><h5 id="解法1：位运算"><a href="#解法1：位运算" class="headerlink" title="解法1：位运算"></a>解法1：位运算</h5><p>0         1 2             3   4    5     6</p>
<p>“”        0 1            00 01 10 11</p>
<p>找规律就完事了</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">encode</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> temp=<span class="number">1</span>;</span><br><span class="line">        string res=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(num&gt;=temp)</span><br><span class="line">        &#123;</span><br><span class="line">            num-=temp;</span><br><span class="line">            temp=temp&lt;&lt;<span class="number">1</span>;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(k--)</span><br><span class="line">        &#123;</span><br><span class="line">            c=(num&amp;<span class="number">1</span>)+<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            res+=c;</span><br><span class="line">            num=num&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1257-最小公共区域"><a href="#1257-最小公共区域" class="headerlink" title="1257. 最小公共区域"></a><a href="https://leetcode-cn.com/problems/smallest-common-region/">1257. 最小公共区域</a></h4><h5 id="解法-map-set"><a href="#解法-map-set" class="headerlink" title="解法:map+set"></a>解法:map+set</h5><p>将每个的父区域记录。</p>
<p>然后找region1，和region2的父区域，若两者相同直接返回，若不相同将找到的父区域记录，同时找父区域的父区域，直到找到，返回。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">findSmallestRegion</span><span class="params">(vector&lt;vector&lt;string&gt;&gt;&amp; regions, string region1, string region2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=regions.<span class="built_in">size</span>();</span><br><span class="line">        map&lt;string,string&gt; pre;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            string f=regions[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;regions[i].<span class="built_in">size</span>();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                pre[regions[i][j]]=f;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        set&lt;string&gt; temp;</span><br><span class="line">        temp.<span class="built_in">insert</span>(region1);</span><br><span class="line">        temp.<span class="built_in">insert</span>(region2);</span><br><span class="line">        <span class="keyword">while</span>(pre[region1]!=pre[region2])</span><br><span class="line">        &#123;</span><br><span class="line">            region1=pre[region1];</span><br><span class="line">            region2=pre[region2];</span><br><span class="line">            cout&lt;&lt;region1&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;region2&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">if</span>(temp.<span class="built_in">find</span>(region1)!=temp.<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> region1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp.<span class="built_in">find</span>(region2)!=temp.<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;!&quot;</span>;</span><br><span class="line">                <span class="keyword">return</span> region2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(region1!=<span class="string">&quot;&quot;</span>)</span><br><span class="line">                temp.<span class="built_in">insert</span>(region1);</span><br><span class="line">            <span class="keyword">if</span>(region2!=<span class="string">&quot;&quot;</span>)</span><br><span class="line">                temp.<span class="built_in">insert</span>(region2);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre[region1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1258-近义词句子"><a href="#1258-近义词句子" class="headerlink" title="1258. 近义词句子"></a><a href="https://leetcode-cn.com/problems/synonymous-sentences/">1258. 近义词句子</a></h4><h5 id="解法：并查集-DFS"><a href="#解法：并查集-DFS" class="headerlink" title="解法：并查集+DFS"></a>解法：并查集+DFS</h5><p>注：题目被限制会员才能看了，没权限，没法提交，先用二哥的题解，有机会了写个c++版</p>
<p>from：小白二号</p>
<p>先把所有的近义词集合求出来。题目中 AA 是 BB 的近义词，如果 AA 是 BB 的近义词，AA 是 CC 的近义词，那么 AA，BB，CC 都是近义词，这一步如果数据量大需要用到并查集，数据量小，瞎搞搞咯</p>
<p>然后再dfs，把句子中每个词的近义词都拿出来计算一次。。。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Map&lt;String, Set&lt;String&gt;&gt; map, String[] col, List&lt;String&gt; result, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == col.length) &#123;</span><br><span class="line">            result.add(String.join(<span class="string">&quot; &quot;</span>, col));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(col[index])) &#123;</span><br><span class="line">            String s = col[index];</span><br><span class="line">            <span class="keyword">for</span> (String sub: map.get(col[index])) &#123;</span><br><span class="line">                col[index] = sub;</span><br><span class="line">                dfs(map, col, result, index + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            col[index] = s;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dfs(map, col, result, index + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateSentences</span><span class="params">(List&lt;List&lt;String&gt;&gt; synonyms, String text)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Set&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (List&lt;String&gt; synonym: synonyms) &#123;</span><br><span class="line">            Set&lt;String&gt; s1 = map.getOrDefault(synonym.get(<span class="number">0</span>), <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">            Set&lt;String&gt; s2 = map.getOrDefault(synonym.get(<span class="number">1</span>), <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">            <span class="keyword">if</span> (s1 == s2) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            HashSet&lt;String&gt; ret = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            ret.addAll(s1);</span><br><span class="line">            ret.addAll(s2);</span><br><span class="line">            ret.add(synonym.get(<span class="number">0</span>));</span><br><span class="line">            ret.add(synonym.get(<span class="number">1</span>));</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (String sub: ret) &#123;</span><br><span class="line">                map.put(sub, ret);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String[] col = text.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(map, col, result, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        Collections.sort(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作者：小白二号<br>链接：<a href="https://leetcode-cn.com/circle/discuss/4bcTK1/view/j97Wxb/">https://leetcode-cn.com/circle/discuss/4bcTK1/view/j97Wxb/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h4 id="1259-不相交的握手"><a href="#1259-不相交的握手" class="headerlink" title="1259. 不相交的握手"></a><a href="https://leetcode-cn.com/problems/handshakes-that-dont-cross/">1259. 不相交的握手</a></h4><h5 id="解法：卡特兰数"><a href="#解法：卡特兰数" class="headerlink" title="解法：卡特兰数"></a>解法：卡特兰数</h5><p><a href="https://baike.baidu.com/item/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/6125746?fr=aladdin">卡特兰数</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfWays</span><span class="params">(<span class="keyword">int</span> num_people)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; <span class="title">h</span><span class="params">(<span class="number">1010</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        h[<span class="number">0</span>]=<span class="number">1</span>;h[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mod=<span class="built_in">pow</span>(<span class="number">10</span>,<span class="number">9</span>)+<span class="number">7</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">500</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                res+=h[j]*h[i-j<span class="number">-1</span>]%mod;</span><br><span class="line">                res%=mod;</span><br><span class="line">            &#125;</span><br><span class="line">            h[i]=res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h[num_people/<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>周赛</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-第14场双周赛</title>
    <url>/2021/10/26/leetcode/zhou-sai/di-14-chang-shuang-zhou-sai/</url>
    <content><![CDATA[<h4 id="5112-十六进制魔术数字"><a href="#5112-十六进制魔术数字" class="headerlink" title="5112. 十六进制魔术数字"></a><a href="https://leetcode-cn.com/problems/hexspeak/">5112. 十六进制魔术数字</a></h4><p>你有一个十进制数字，请按照此规则将它变成「十六进制魔术数字」：首先将它变成字母大写的十六进制字符串，然后将所有的数字 0 变成字母 O ，将数字 1  变成字母 I 。</p>
<p>如果一个数字在转换后只包含 {“A”, “B”, “C”, “D”, “E”, “F”, “I”, “O”} ，那么我们就认为这个转换是有效的。</p>
<p>给你一个字符串 num ，它表示一个十进制数 N，如果它的十六进制魔术数字转换是有效的，请返回转换后的结果，否则返回 “ERROR” 。</p>
<p> <span id="more"></span></p>
<p>示例 1：</p>
<p>输入：num = “257”<br>输出：”IOI”<br>解释：257 的十六进制表示是 101 。<br>示例 2：</p>
<p>输入：num = “3”<br>输出：”ERROR”</p>
<p>提示：</p>
<p>1 &lt;= N &lt;= 10^12<br>给定字符串不会有前导 0 。<br>结果中的所有字母都应该是大写字母。</p>
<h5 id="解法1：模拟"><a href="#解法1：模拟" class="headerlink" title="解法1：模拟"></a>解法1：模拟</h5><p>将10进制转换成16进制</p>
<p>注意：1.转化时用longlong 不然会溢出，2.最后要reverse字符串</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">toHexspeak</span><span class="params">(string num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> s=<span class="built_in">stol</span>(num);</span><br><span class="line">        string str[<span class="number">6</span>]=&#123;<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;C&quot;</span>,<span class="string">&quot;D&quot;</span>,<span class="string">&quot;E&quot;</span>,<span class="string">&quot;F&quot;</span>&#125;;</span><br><span class="line">        string res=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp=s%<span class="number">16</span>;</span><br><span class="line">            <span class="keyword">if</span>(temp&gt;=<span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res+=str[temp<span class="number">-10</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(temp==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res+=<span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(temp==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res+=<span class="string">&#x27;I&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(temp&gt;=<span class="number">2</span>&amp;&amp;temp&lt;=<span class="number">9</span>)</span><br><span class="line">                <span class="keyword">return</span>  <span class="string">&quot;ERROR&quot;</span>;</span><br><span class="line">            s=s/<span class="number">16</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="5113-删除区间"><a href="#5113-删除区间" class="headerlink" title="5113. 删除区间"></a><a href="https://leetcode-cn.com/problems/remove-interval/">5113. 删除区间</a></h4><p>给你一个 有序的 不相交区间列表 intervals 和一个要删除的区间 toBeRemoved， intervals 中的每一个区间 intervals[i] = [a, b] 都表示满足 a &lt;= x &lt; b 的所有实数  x 的集合。</p>
<p>我们将 intervals 中任意区间与 toBeRemoved 有交集的部分都删除。</p>
<p>返回删除所有交集区间后， intervals 剩余部分的 有序 列表。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：intervals = [[0,2],[3,4],[5,7]], toBeRemoved = [1,6]<br>输出：[[0,1],[6,7]]<br>示例 2：</p>
<p>输入：intervals = [[0,5]], toBeRemoved = [2,3]<br>输出：[[0,2],[3,5]]</p>
<p>提示：</p>
<p>1 &lt;= intervals.length &lt;= 10^4<br>-10^9 &lt;= intervals[i][0] &lt; intervals[i][1] &lt;= 10^9</p>
<h5 id="解法1：模拟-1"><a href="#解法1：模拟-1" class="headerlink" title="解法1：模拟"></a>解法1：模拟</h5><p>思路：模拟查找重叠区间，要想好思路，不然会很乱</p>
<p>1.若interval[1]&lt;=toBeRemoved[0]，则不在删除区间内，添加进结果数组</p>
<p>2.若interval[0]&gt;=toBeRemoved[1]，则不在删除区间内，添加进结果数组</p>
<p>3.在前面的情况不满足下，若interval[0]&lt;toBeRemoved[0],前面已经讨论interval[1]在删除区间右边的情况,现在还有两种情况</p>
<ul>
<li>​    interval[1]&lt;=toBeRemoved[1],添加{interval[0],toBeRemoved[0]}</li>
<li>​        interval[1]&gt;toBeRemoved[1],<strong>再</strong>添加{toBeRemoved[1],interval[1]}</li>
</ul>
<p>4.在前面的情况不满足下，若interval[0]&lt;toBeRemoved[1]</p>
<ul>
<li>interval[1]&lt;=toBeRemoved[1],直接将跳过这一段应删除的区间</li>
<li>nterval[1]&gt;toBeRemoved[1]，添加{toBeRemoved[1],interval[1]}</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">removeInterval</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals, vector&lt;<span class="keyword">int</span>&gt;&amp; toBeRemoved) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">int</span> n=intervals.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">1</span>]&lt;=toBeRemoved[<span class="number">0</span>]||intervals[i][<span class="number">0</span>]&gt;=toBeRemoved[<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(intervals[i]);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(intervals[i][<span class="number">0</span>]&lt;toBeRemoved[<span class="number">0</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(&#123;intervals[i][<span class="number">0</span>],toBeRemoved[<span class="number">0</span>]&#125;);</span><br><span class="line">                <span class="keyword">if</span>(intervals[i][<span class="number">1</span>]&gt;toBeRemoved[<span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(&#123;toBeRemoved[<span class="number">1</span>],intervals[i][<span class="number">1</span>]&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(intervals[i][<span class="number">0</span>]&lt;toBeRemoved[<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(intervals[i][<span class="number">1</span>]&lt;=toBeRemoved[<span class="number">1</span>])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(&#123;toBeRemoved[<span class="number">1</span>],intervals[i][<span class="number">1</span>]&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="5114-删除树节点"><a href="#5114-删除树节点" class="headerlink" title="5114. 删除树节点"></a><a href="https://leetcode-cn.com/problems/delete-tree-nodes/">5114. 删除树节点</a></h4><p>给你一棵以节点 0 为根节点的树，定义如下：</p>
<p>节点的总数为 nodes 个；<br>第 i 个节点的值为 value[i] ；<br>第 i 个节点的父节点是 parent[i] 。<br>请你删除节点值之和为 0 的每一棵子树。</p>
<p>在完成所有删除之后，返回树中剩余节点的数目。</p>
<p> </p>
<p>示例：</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/30/1421_sample_1.png" alt="img"> </p>
<p>输入：nodes = 7, parent = [-1,0,0,1,2,2,2], value = [1,-2,4,0,-2,-1,-1]<br>输出：2</p>
<p>提示：</p>
<p>1 &lt;= nodes &lt;= 10^4<br>-10^5 &lt;= value[i] &lt;= 10^5<br>parent.length == nodes<br>parent[0] == -1 表示节点 0 是树的根。</p>
<h5 id="解法1：两次DFS"><a href="#解法1：两次DFS" class="headerlink" title="解法1：两次DFS"></a>解法1：两次DFS</h5><p>第一次dfs将和为0的子树标记</p>
<p>第二次dfs求剩余的节点数目</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    map&lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;&gt; pindex;</span><br><span class="line">    vector&lt;<span class="keyword">bool</span>&gt; used;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteTreeNodes</span><span class="params">(<span class="keyword">int</span> nodes, vector&lt;<span class="keyword">int</span>&gt;&amp; parent, vector&lt;<span class="keyword">int</span>&gt;&amp; value)</span> </span>&#123;</span><br><span class="line">        n=nodes;</span><br><span class="line">        used=vector&lt;<span class="keyword">bool</span>&gt;(n,<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            pindex[parent[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs1</span>(parent,value,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs2</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs1</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; parent, vector&lt;<span class="keyword">int</span>&gt;&amp; value,<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=value[i];</span><br><span class="line">        <span class="keyword">if</span>(!pindex.<span class="built_in">count</span>(i))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(sum==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                used[i]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; temp=pindex[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;temp.<span class="built_in">size</span>();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> index=temp[j];</span><br><span class="line">            sum+=<span class="built_in">dfs1</span>(parent,value,index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            used[i]=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!pindex.<span class="built_in">count</span>(i))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; temp=pindex[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;temp.<span class="built_in">size</span>();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> index=temp[j];</span><br><span class="line">            <span class="keyword">if</span>(used[index])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            sum+=<span class="built_in">dfs2</span>(index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="5136-矩形内船只的数目"><a href="#5136-矩形内船只的数目" class="headerlink" title="5136. 矩形内船只的数目"></a><a href="https://leetcode-cn.com/problems/number-of-ships-in-a-rectangle/">5136. 矩形内船只的数目</a></h4><p>(此题是 交互式问题 )</p>
<p>在用笛卡尔坐标系表示的二维海平面上，有一些船。每一艘船都在一个整数点上，且每一个整数点最多只有 1 艘船。</p>
<p>有一个函数 Sea.hasShips(topRight, bottomLeft) ，输入参数为右上角和左下角两个点的坐标，当且仅当这两个点所表示的矩形区域（包含边界）内至少有一艘船时，这个函数才返回 true ，否则返回 false 。</p>
<p>给你矩形的右上角 topRight 和左下角 bottomLeft 的坐标，请你返回此矩形内船只的数目。题目保证矩形内 至多只有 10 艘船。</p>
<p>调用函数 hasShips 超过400次 的提交将被判为 错误答案（Wrong Answer） 。同时，任何尝试绕过评测系统的行为都将被取消比赛资格。</p>
<p> </p>
<p>示例：</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/30/1445_example_1.png" alt="img"> </p>
<p>输入：<br>ships = [[1,1],[2,2],[3,3],[5,5]], topRight = [4,4], bottomLeft = [0,0]<br>输出：3<br>解释：在 [0,0] 到 [4,4] 的范围内总共有 3 艘船。</p>
<p>提示：</p>
<p>ships 数组只用于评测系统内部初始化。你无法得知 ships 的信息，所以只能通过调用 hasShips 接口来求解。<br>0 &lt;= bottomLeft[0] &lt;= topRight[0] &lt;= 1000<br>0 &lt;= bottomLeft[1] &lt;= topRight[1] &lt;= 1000</p>
<h5 id="解法1：二分"><a href="#解法1：二分" class="headerlink" title="解法1：二分"></a>解法1：二分</h5><p>分成四部分，左上，左下，右上，</p>
<p>二分，矩阵的二分，划成了4个小矩阵，分别对这4个小矩阵进行探测，如果没有船，就不继续探测了，如果有船，那么递归探测</p>
<p>递归的终止条件是：矩阵只剩下一个点，那么这个点就有一艘船</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // This is Sea&#x27;s API interface.</span></span><br><span class="line"><span class="comment"> * // You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="comment"> * class Sea &#123;</span></span><br><span class="line"><span class="comment"> *   public:</span></span><br><span class="line"><span class="comment"> *     bool hasShips(vector&lt;int&gt; topRight, vector&lt;int&gt; bottomLeft);</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countShips</span><span class="params">(Sea sea, vector&lt;<span class="keyword">int</span>&gt; topRight, vector&lt;<span class="keyword">int</span>&gt; bottomLeft)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(bottomLeft[<span class="number">0</span>]&gt;topRight[<span class="number">0</span>]||bottomLeft[<span class="number">1</span>]&gt;topRight[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!sea.<span class="built_in">hasShips</span>(topRight,bottomLeft)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(topRight[<span class="number">0</span>]==bottomLeft[<span class="number">0</span>]&amp;&amp;topRight[<span class="number">1</span>]==bottomLeft[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> lowx=bottomLeft[<span class="number">0</span>],lowy=bottomLeft[<span class="number">1</span>],highx=topRight[<span class="number">0</span>],highy=topRight[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> midx=(lowx+highx)/<span class="number">2</span>,midy=(lowy+highy)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">countShips</span>(sea,&#123;highx,highy&#125;,&#123;midx+<span class="number">1</span>,midy+<span class="number">1</span>&#125;)+<span class="built_in">countShips</span>(sea,&#123;midx,midy&#125;,&#123;lowx,lowy&#125;)+<span class="built_in">countShips</span>(sea,&#123;midx,highy&#125;,&#123;lowx,midy+<span class="number">1</span>&#125;)+<span class="built_in">countShips</span>(sea,&#123;highx,midy&#125;,&#123;midx+<span class="number">1</span>,lowy&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>周赛</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-第151场周赛</title>
    <url>/2019/08/26/leetcode/zhou-sai/di-151-chang-zhou-sai/</url>
    <content><![CDATA[<h4 id="1169-查询无效交易"><a href="#1169-查询无效交易" class="headerlink" title="1169.查询无效交易"></a>1169.查询无效交易</h4><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>如果出现下述两种情况，交易 <strong>可能无效</strong>：</p>
<ul>
<li>交易金额超过 ¥1000</li>
<li>或者，它和另一个城市中同名的另一笔交易相隔不超过 60 分钟（包含 60 分钟整）</li>
</ul>
<p>每个交易字符串 <code>transactions[i]</code> 由一些用逗号分隔的值组成，这些值分别表示交易的名称，时间（以分钟计），金额以及城市。</p>
<p>给你一份交易清单 <code>transactions</code>，返回可能无效的交易列表。你可以按任何顺序返回答案。</p>
<span id="more"></span>

<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：transactions = [&quot;alice,20,800,mtv&quot;,&quot;alice,50,100,beijing&quot;]</span><br><span class="line">输出：[&quot;alice,20,800,mtv&quot;,&quot;alice,50,100,beijing&quot;]</span><br><span class="line">解释：第一笔交易是无效的，因为第二笔交易和它间隔不超过 60 分钟、名称相同且发生在不同的城市。同样，第二笔交易也是无效的。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：transactions = [&quot;alice,20,800,mtv&quot;,&quot;alice,50,1200,mtv&quot;]</span><br><span class="line">输出：[&quot;alice,50,1200,mtv&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：transactions = [&quot;alice,20,800,mtv&quot;,&quot;bob,50,1200,mtv&quot;]</span><br><span class="line">输出：[&quot;bob,50,1200,mtv&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>transactions.length &lt;= 1000</code></li>
<li>每笔交易 <code>transactions[i]</code> 按 <code>&quot;&#123;name&#125;,&#123;time&#125;,&#123;amount&#125;,&#123;city&#125;&quot;</code> 的格式进行记录</li>
<li>每个交易名称 <code>&#123;name&#125;</code> 和城市 <code>&#123;city&#125;</code> 都由小写英文字母组成，长度在 <code>1</code> 到 <code>10</code> 之间</li>
<li>每个交易时间 <code>&#123;time&#125;</code> 由一些数字组成，表示一个 <code>0</code> 到 <code>1000</code> 之间的整数</li>
<li>每笔交易金额 <code>&#123;amount&#125;</code> 由一些数字组成，表示一个 <code>0</code> 到 <code>2000</code> 之间的整数</li>
</ul>
<h5 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h5><p>1.将每个字符串切割存入到结构体中，同时记录在原字符串数组中的位置index</p>
<p>2.对结构体数组进行排序，先按名排序，名相同的按时间从小到大排序</p>
<p>3.</p>
<ul>
<li>遍历结构体数组先判断下一位是否越界，没有越界<strong>找到后面第一个不在相同城市的交易</strong>，因为已经排好了序，我们可知，若这一位与当前位时间相差超过60min，则名称相同的必然后面都超过60min,若找到无效交易将当前位放入res结果数组，直接continue下一循环</li>
<li>若下一位超过60min，判断上一位是否越界,若没有越界<strong>找到前面第一个不在相同城市的交易</strong>，其他与找下一位类似</li>
</ul>
<p>4.遍历完毕，返回结果数组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">invalidTransactions</span><span class="params">(vector&lt;string&gt;&amp; transactions)</span> </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">trans</span> </span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            string na;</span><br><span class="line">            <span class="keyword">int</span> ta;</span><br><span class="line">            <span class="keyword">int</span> aa;</span><br><span class="line">            string ca;</span><br><span class="line">            <span class="keyword">int</span> index;</span><br><span class="line">        &#125;;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        <span class="keyword">int</span> n=transactions.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;trans&gt; <span class="title">tr</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> li=<span class="number">0</span>,ln=transactions[i].<span class="built_in">size</span>();</span><br><span class="line">            tr[i].na=<span class="built_in">getStr</span>(transactions[i],li,ln);</span><br><span class="line">            tr[i].ta=<span class="built_in">getInt</span>(transactions[i],li,ln);</span><br><span class="line">            tr[i].aa=<span class="built_in">getInt</span>(transactions[i],li,ln);</span><br><span class="line">            tr[i].ca=<span class="built_in">getStr</span>(transactions[i],li,ln);</span><br><span class="line">            tr[i].index=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(tr.<span class="built_in">begin</span>(),tr.<span class="built_in">end</span>(),[](<span class="keyword">auto</span> &amp;l,<span class="keyword">auto</span> &amp;r)&#123;<span class="keyword">if</span>(l.na!=r.na)<span class="keyword">return</span> l.na&lt;r.na;<span class="keyword">return</span> l.ta&lt;r.ta;&#125;);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i+<span class="number">1</span>&lt;n)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> j=i+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(j&lt;n&amp;&amp;tr[i].ca==tr[j].ca)			<span class="comment">//这里极其重要，有可能两个相邻结构体的城市也是一样，要通过循环找到城市不一样的，这样才能找到所有的可能</span></span><br><span class="line">                    j++;</span><br><span class="line">                <span class="keyword">if</span>(j&lt;n&amp;&amp;tr[i].na==tr[j].na&amp;&amp;(tr[i].ca!=tr[j].ca)&amp;&amp;<span class="built_in">abs</span>(tr[i].ta-tr[j].ta)&lt;=<span class="number">60</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(transactions[tr[i].index]);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;               </span><br><span class="line">                <span class="keyword">if</span>(tr[i].aa&gt;<span class="number">1000</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(transactions[tr[i].index]);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i<span class="number">-1</span>&gt;=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> j=i<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">while</span>(j&gt;=<span class="number">0</span>&amp;&amp;tr[i].ca==tr[j].ca)</span><br><span class="line">                    j--;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=<span class="number">0</span>&amp;&amp;tr[i].na==tr[j].na&amp;&amp;tr[i].ca!=tr[j].ca&amp;&amp;<span class="built_in">abs</span>(tr[i].ta-tr[j].ta)&lt;=<span class="number">60</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(transactions[tr[i].index]);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(tr[i].aa&gt;<span class="number">1000</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(transactions[tr[i].index]);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">getStr</span><span class="params">(string s,<span class="keyword">int</span> &amp;i,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        string temp=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n&amp;&amp;!(<span class="string">&#x27;a&#x27;</span>&lt;=s[i]&amp;&amp;s[i]&lt;=<span class="string">&#x27;z&#x27;</span>))</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n&amp;&amp;(<span class="string">&#x27;a&#x27;</span>&lt;=s[i]&amp;&amp;s[i]&lt;=<span class="string">&#x27;z&#x27;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            temp+=s[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">(string s,<span class="keyword">int</span> &amp;i,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n&amp;&amp;!(<span class="string">&#x27;0&#x27;</span>&lt;=s[i]&amp;&amp;s[i]&lt;=<span class="string">&#x27;9&#x27;</span>))</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n&amp;&amp;(<span class="string">&#x27;0&#x27;</span>&lt;=s[i]&amp;&amp;s[i]&lt;=<span class="string">&#x27;9&#x27;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            temp=temp*<span class="number">10</span>+s[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1170-比较字符串最小字母出现频次"><a href="#1170-比较字符串最小字母出现频次" class="headerlink" title="1170.比较字符串最小字母出现频次"></a>1170.比较字符串最小字母出现频次</h4><p>我们来定义一个函数 <code>f(s)</code>，其中传入参数 <code>s</code> 是一个非空字符串；该函数的功能是统计 <code>s</code>  中（按字典序比较）最小字母的出现频次。</p>
<p>例如，若 <code>s = &quot;dcce&quot;</code>，那么 <code>f(s) = 2</code>，因为最小的字母是 <code>&quot;c&quot;</code>，它出现了 2 次。</p>
<p>现在，给你两个字符串数组待查表 <code>queries</code> 和词汇表 <code>words</code>，请你返回一个整数数组 <code>answer</code> 作为答案，其中每个 <code>answer[i]</code> 是满足 <code>f(queries[i])</code> &lt; <code>f(W)</code> 的词的数目，<code>W</code> 是词汇表 <code>words</code> 中的词。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：queries = [&quot;cbd&quot;], words = [&quot;zaaaz&quot;]</span><br><span class="line">输出：[1]</span><br><span class="line">解释：查询 f(&quot;cbd&quot;) = 1，而 f(&quot;zaaaz&quot;) = 3 所以 f(&quot;cbd&quot;) &lt; f(&quot;zaaaz&quot;)。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：queries = [&quot;bbb&quot;,&quot;cc&quot;], words = [&quot;a&quot;,&quot;aa&quot;,&quot;aaa&quot;,&quot;aaaa&quot;]</span><br><span class="line">输出：[1,2]</span><br><span class="line">解释：第一个查询 f(&quot;bbb&quot;) &lt; f(&quot;aaaa&quot;)，第二个查询 f(&quot;aaa&quot;) 和 f(&quot;aaaa&quot;) 都 &gt; f(&quot;cc&quot;)。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= queries.length &lt;= 2000</code></li>
<li><code>1 &lt;= words.length &lt;= 2000</code></li>
<li><code>1 &lt;= queries[i].length, words[i].length &lt;= 10</code></li>
<li><code>queries[i][j]</code>, <code>words[i][j]</code> 都是小写英文字母</li>
</ul>
<h5 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h5><p>思路很简单</p>
<p>1.定义两个数组q,w分别存放queries和words各个字符串对应的f函数的值</p>
<p>2.将w从小到大排序，遍历q，当q[i]&lt;w[i]时，则w[i]后面的也大于q[i]，也就得到了q[i]对应的结果数组的值</p>
<p>3.将q[i]的每项存起来，便得到了结果数组，返回</p>
<p>f函数的实现：</p>
<p>利用map，存字符串每个字母的出现次数</p>
<p>找到最小字母的出现次数，返回该值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">numSmallerByFrequency</span><span class="params">(vector&lt;string&gt;&amp; queries, vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; w;</span><br><span class="line">        <span class="keyword">int</span> map[<span class="number">26</span>];</span><br><span class="line">        <span class="built_in">memset</span>(map,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(map));</span><br><span class="line">        <span class="keyword">int</span> n=queries.<span class="built_in">size</span>(),m=words.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;queries[i].<span class="built_in">size</span>();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                map[queries[i][j]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">26</span>;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(map[j]!=<span class="number">0</span>)</span><br><span class="line">                &#123; </span><br><span class="line">                    q.<span class="built_in">push_back</span>(map[j]);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memset</span>(map,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(map));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(map,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(map));</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;words[i].<span class="built_in">size</span>();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                map[words[i][j]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">26</span>;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(map[j]!=<span class="number">0</span>)</span><br><span class="line">                &#123; </span><br><span class="line">                    w.<span class="built_in">push_back</span>(map[j]);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memset</span>(map,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(map));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(w.<span class="built_in">begin</span>(),w.<span class="built_in">end</span>());</span><br><span class="line">        j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(q[j]&lt;w[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    q[j]=m-i;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i==m)</span><br><span class="line">                q[j]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1171-从链表中删去总和为0的连续节点"><a href="#1171-从链表中删去总和为0的连续节点" class="headerlink" title="1171.从链表中删去总和为0的连续节点"></a>1171.从链表中删去总和为0的连续节点</h4><p>给你一个链表的头节点 <code>head</code>，请你编写代码，反复删去链表中由 <strong>总和</strong> 值为 <code>0</code> 的连续节点组成的序列，直到不存在这样的序列为止。</p>
<p>删除完毕后，请你返回最终结果链表的头节点。</p>
<p>你可以返回任何满足题目要求的答案。</p>
<p>（注意，下面示例中的所有序列，都是对 <code>ListNode</code> 对象序列化的表示。）</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,-3,3,1]</span><br><span class="line">输出：[3,1]</span><br><span class="line">提示：答案 [1,2,1] 也是正确的。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,-3,4]</span><br><span class="line">输出：[1,2,4]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,-3,-2]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>给你的链表中可能有 <code>1</code> 到 <code>1000</code> 个节点。</li>
<li>对于链表中的每个节点，节点的值：<code>-1000 &lt;= node.val &lt;= 1000</code>.</li>
</ul>
<h5 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h5><p>因为只有1000个节点，所以直接考虑暴力</p>
<p>思路：</p>
<p>1.将链表转换为数组，便于进行操作</p>
<p>2.两层循环，i遍历每一个点，能否和后面形成总和为0的连续节点，若能，跳出循环，记录j位置，从开始位置i到结束位置j每个点赋值为INT_MAX,i跳转到j，进行下一次循环</p>
<p>3.循环完毕，遍历数组，将不为INT_MAX的值依次放入新的链表中，返回新链表</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeZeroSumSublists</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        ListNode *p=head;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s.<span class="built_in">push_back</span>(p-&gt;val);</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(j=i;j&lt;n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                sum+=s[j];</span><br><span class="line">                <span class="keyword">if</span>(sum==<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sum==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;=j;k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    s[k]=INT_MAX;</span><br><span class="line">                &#125;</span><br><span class="line">                i=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *newhead=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        p=newhead;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==INT_MAX)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            ListNode *pn=<span class="keyword">new</span> <span class="built_in">ListNode</span>(s[i]);</span><br><span class="line">            p-&gt;next=pn;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newhead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1172-餐盘栈"><a href="#1172-餐盘栈" class="headerlink" title="1172.餐盘栈"></a>1172.餐盘栈</h4><p>我们把无限数量 ∞ 的栈排成一行，按从左到右的次序从 0 开始编号。每个栈的的最大容量 <code>capacity</code> 都相同。</p>
<p>实现一个叫「餐盘」的类 <code>DinnerPlates</code>：</p>
<ul>
<li><code>DinnerPlates(int capacity)</code> - 给出栈的最大容量 <code>capacity</code>。</li>
<li><code>void push(int val)</code> - 将给出的正整数 <code>val</code> 推入 <strong>从左往右第一个</strong> 没有满的栈。</li>
<li><code>int pop()</code> - 返回 <strong>从右往左第一个</strong> 非空栈顶部的值，并将其从栈中删除；如果所有的栈都是空的，请返回 <code>-1</code>。</li>
<li><code>int popAtStack(int index)</code> - 返回编号 <code>index</code> 的栈顶部的值，并将其从栈中删除；如果编号 <code>index</code> 的栈是空的，请返回 <code>-1</code>。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入： </span><br><span class="line">[&quot;DinnerPlates&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;popAtStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;popAtStack&quot;,&quot;popAtStack&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;]</span><br><span class="line">[[2],[1],[2],[3],[4],[5],[0],[20],[21],[0],[2],[],[],[],[],[]]</span><br><span class="line">输出：</span><br><span class="line">[null,null,null,null,null,null,2,null,null,20,21,5,4,3,1,-1]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">DinnerPlates D = DinnerPlates(2);  // 初始化，栈最大容量 capacity = 2</span><br><span class="line">D.push(1);</span><br><span class="line">D.push(2);</span><br><span class="line">D.push(3);</span><br><span class="line">D.push(4);</span><br><span class="line">D.push(5);         // 栈的现状为：    2  4</span><br><span class="line">                                    1  3  5</span><br><span class="line">                                    ﹈ ﹈ ﹈</span><br><span class="line">D.popAtStack(0);   // 返回 2。栈的现状为：      4</span><br><span class="line">                                          1  3  5</span><br><span class="line">                                          ﹈ ﹈ ﹈</span><br><span class="line">D.push(20);        // 栈的现状为：  20  4</span><br><span class="line">                                   1  3  5</span><br><span class="line">                                   ﹈ ﹈ ﹈</span><br><span class="line">D.push(21);        // 栈的现状为：  20  4 21</span><br><span class="line">                                   1  3  5</span><br><span class="line">                                   ﹈ ﹈ ﹈</span><br><span class="line">D.popAtStack(0);   // 返回 20。栈的现状为：       4 21</span><br><span class="line">                                            1  3  5</span><br><span class="line">                                            ﹈ ﹈ ﹈</span><br><span class="line">D.popAtStack(2);   // 返回 21。栈的现状为：       4</span><br><span class="line">                                            1  3  5</span><br><span class="line">                                            ﹈ ﹈ ﹈ </span><br><span class="line">D.pop()            // 返回 5。栈的现状为：        4</span><br><span class="line">                                            1  3 </span><br><span class="line">                                            ﹈ ﹈  </span><br><span class="line">D.pop()            // 返回 4。栈的现状为：    1  3 </span><br><span class="line">                                           ﹈ ﹈   </span><br><span class="line">D.pop()            // 返回 3。栈的现状为：    1 </span><br><span class="line">                                           ﹈   </span><br><span class="line">D.pop()            // 返回 1。现在没有栈。</span><br><span class="line">D.pop()            // 返回 -1。仍然没有栈。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= capacity &lt;= 20000</code></li>
<li><code>1 &lt;= val &lt;= 20000</code></li>
<li><code>0 &lt;= index &lt;= 100000</code></li>
<li>最多会对 <code>push</code>，<code>pop</code>，和 <code>popAtStack</code> 进行 <code>200000</code> 次调用。</li>
</ul>
<h5 id="解法-3"><a href="#解法-3" class="headerlink" title="解法"></a>解法</h5><p>模拟栈操作，注意数据量10W+</p>
<p>要记录下那些位置可放入数，不然会超时</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DinnerPlates</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    vector&lt;stack&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DinnerPlates</span>(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        n=capacity;</span><br><span class="line">        l=r=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=l;i&lt;res.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(res[i].<span class="built_in">size</span>()&lt;n)</span><br><span class="line">            &#123;</span><br><span class="line">                res[i].<span class="built_in">push</span>(val);</span><br><span class="line">                l=i;</span><br><span class="line">                r=<span class="built_in">max</span>(r,i);</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        res[i].<span class="built_in">push</span>(val);</span><br><span class="line">        l=r=i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=r;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(res[i].<span class="built_in">size</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> x=res[i].<span class="built_in">top</span>();</span><br><span class="line">                res[i].<span class="built_in">pop</span>();</span><br><span class="line">                r=i;</span><br><span class="line">                l=<span class="built_in">min</span>(l,i);</span><br><span class="line">                <span class="keyword">return</span> x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        r=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">popAtStack</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;=res.<span class="built_in">size</span>()||res[index].<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x=res[index].<span class="built_in">top</span>();</span><br><span class="line">            res[index].<span class="built_in">pop</span>();</span><br><span class="line">            l=<span class="built_in">min</span>(l,index);</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your DinnerPlates object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * DinnerPlates* obj = new DinnerPlates(capacity);</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(val);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;popAtStack(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>周赛</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-第152场周赛</title>
    <url>/2019/09/02/leetcode/zhou-sai/di-152-chang-zhou-sai/</url>
    <content><![CDATA[<h4 id="5173-质数序列"><a href="#5173-质数序列" class="headerlink" title="5173.质数序列"></a>5173.质数序列</h4><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>请你帮忙给从 <code>1</code> 到 <code>n</code> 的数设计排列方案，使得所有的「质数」都应该被放在「质数索引」（索引从 1 开始）上；你需要返回可能的方案总数。</p>
<p>让我们一起来回顾一下「质数」：质数一定是大于 1 的，并且不能用两个小于它的正整数的乘积来表示。</p>
<p>由于答案可能会很大，所以请你返回答案 <strong>模 mod 10^9 + 7</strong> 之后的结果即可。</p>
<span id="more"></span>

<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 5</span><br><span class="line">输出：12</span><br><span class="line">解释：举个例子，[1,2,5,4,3] 是一个有效的排列，但 [5,2,3,4,1] 不是，因为在第二种情况里质数 5 被错误地放在索引为 1 的位置上。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 100</span><br><span class="line">输出：682289015</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 100</code></li>
</ul>
<h5 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h5><p>明白题意，质数所对应的索引只能放质数，当然非质数所对应的索引只能放非质数</p>
<p>所以我们可以求出质数的个数然后求全排列数x!，非质数的个数求全排列数y!，然后求x!*y!即为最后结果</p>
<p>注意每一步对10^9+7取余</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numPrimeArrangements</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sumz=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sumnz=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> z=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> nz=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">zhishu</span>(i))</span><br><span class="line">            &#123;</span><br><span class="line">                z++;</span><br><span class="line">                sumz=sumz*z%(<span class="number">1000000007</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                nz++;</span><br><span class="line">                sumnz=sumnz*nz%(<span class="number">1000000007</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum=(sumz*sumnz)%(<span class="number">1000000007</span>);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">zhishu</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">2</span>;k&lt;=i/<span class="number">2</span>;k++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i%k==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="5174-健身计划评估"><a href="#5174-健身计划评估" class="headerlink" title="5174.健身计划评估"></a>5174.健身计划评估</h4><h5 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h5><p>你的好友是一位健身爱好者。前段日子，他给自己制定了一份健身计划。现在想请你帮他评估一下这份计划是否合理。</p>
<p>他会有一份计划消耗的卡路里表，其中 <code>calories[i]</code> 给出了你的这位好友在第 <code>i</code> 天需要消耗的卡路里总量。</p>
<p>为了更好地评估这份计划，对于卡路里表中的每一天，你都需要计算他 「这一天以及之后的连续几天」 （共 <code>k</code> 天）内消耗的总卡路里 <em>T：</em></p>
<ul>
<li>如果 <code>T &lt; lower</code>，那么这份计划相对糟糕，并失去 1 分； </li>
<li>如果 <code>T &gt; upper</code>，那么这份计划相对优秀，并获得 1 分；</li>
<li>否则，这份计划普普通通，分值不做变动。</li>
</ul>
<p>请返回统计完所有 <code>calories.length</code> 天后得到的总分作为评估结果。</p>
<p>注意：总分可能是负数。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：calories = [1,2,3,4,5], k = 1, lower = 3, upper = 3</span><br><span class="line">输出：0</span><br><span class="line">解释：calories[0], calories[1] &lt; lower 而 calories[3], calories[4] &gt; upper, 总分 = 0.</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：calories = [3,2], k = 2, lower = 0, upper = 1</span><br><span class="line">输出：1</span><br><span class="line">解释：calories[0] + calories[1] &gt; upper, 总分 = 1.</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：calories = [6,5,0,0], k = 2, lower = 1, upper = 5</span><br><span class="line">输出：0</span><br><span class="line">解释：calories[0] + calories[1] &gt; upper, calories[2] + calories[3] &lt; lower, 总分 = 0.</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= k &lt;= calories.length &lt;= 10^5</code></li>
<li><code>0 &lt;= calories[i] &lt;= 20000</code></li>
<li><code>0 &lt;= lower &lt;= upper</code></li>
</ul>
<h5 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h5><p>理解题干，注意：每次计划表是移动1个单位，并不是移动k个单位</p>
<p>解法1：暴力</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dietPlanPerformance</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; calories, <span class="keyword">int</span> k, <span class="keyword">int</span> lower, <span class="keyword">int</span> upper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=calories.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n-k;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;k;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                sum+=calories[i+j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sum&lt;lower)</span><br><span class="line">                res--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(sum&gt;upper)</span><br><span class="line">                res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>解法2：动态规划</p>
<p>记录每个位置到开头总的消耗卡路里总量，计算a[i]与a[i-k]之差就可得到这份计划表的卡路里量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dietPlanPerformance</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; calories, <span class="keyword">int</span> k, <span class="keyword">int</span> lower, <span class="keyword">int</span> upper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=calories.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            a[i]=a[i<span class="number">-1</span>]+calories[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp=a[i]-a[i-k];</span><br><span class="line">            <span class="keyword">if</span>(temp&gt;upper)</span><br><span class="line">                res+=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(temp&lt;lower)</span><br><span class="line">                res-=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="5175-构建回文串检测"><a href="#5175-构建回文串检测" class="headerlink" title="5175.构建回文串检测"></a>5175.构建回文串检测</h4><h5 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h5><p>给你一个字符串 <code>s</code>，请你对 <code>s</code> 的子串进行检测。</p>
<p>每次检测，待检子串都可以表示为 <code>queries[i] = [left, right, k]</code>。我们可以 <strong>重新排列</strong> 子串 <code>s[left], ..., s[right]</code>，并从中选择 <strong>最多</strong> <code>k</code> 项替换成任何小写英文字母。 </p>
<p>如果在上述检测过程中，子串可以变成回文形式的字符串，那么检测结果为 <code>true</code>，否则结果为 <code>false</code>。</p>
<p>返回答案数组 <code>answer[]</code>，其中 <code>answer[i]</code> 是第 <code>i</code> 个待检子串 <code>queries[i]</code> 的检测结果。</p>
<p>注意：在替换时，子串中的每个字母都必须作为 <strong>独立的</strong> 项进行计数，也就是说，如果 <code>s[left..right] = &quot;aaa&quot;</code> 且 <code>k = 2</code>，我们只能替换其中的两个字母。（另外，任何检测都不会修改原始字符串 <code>s</code>，可以认为每次检测都是独立的）</p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;abcda&quot;, queries = [[3,3,0],[1,2,0],[0,3,1],[0,3,2],[0,4,1]]</span><br><span class="line">输出：[true,false,false,true,true]</span><br><span class="line">解释：</span><br><span class="line">queries[0] : 子串 = &quot;d&quot;，回文。</span><br><span class="line">queries[1] : 子串 = &quot;bc&quot;，不是回文。</span><br><span class="line">queries[2] : 子串 = &quot;abcd&quot;，只替换 1 个字符是变不成回文串的。</span><br><span class="line">queries[3] : 子串 = &quot;abcd&quot;，可以变成回文的 &quot;abba&quot;。 也可以变成 &quot;baab&quot;，先重新排序变成 &quot;bacd&quot;，然后把 &quot;cd&quot; 替换为 &quot;ab&quot;。</span><br><span class="line">queries[4] : 子串 = &quot;abcda&quot;，可以变成回文的 &quot;abcba&quot;。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length, queries.length &lt;= 10^5</code></li>
<li><code>0 &lt;= queries[i][0] &lt;= queries[i][1] &lt; s.length</code></li>
<li><code>0 &lt;= queries[i][2] &lt;= s.length</code></li>
<li><code>s</code> 中只有小写英文字母</li>
</ul>
<h5 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h5><p>同样是dp策略，构建dp数组a[n][26]，对s字符串，记录从0到当前位置各个字符出现的次数；</p>
<p>然后分析queries 对于每个query来说</p>
<p>我们构建一个数组b[26] 来表示在这段字符串中每个字符出现的次数，我们通过计算a[r][i]-a[l-1][i]便能得到b[i]的值</p>
<p>判断b[i]里有多少个奇数c，若c//2&lt;=k则能构成回文串，否则为false</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">canMakePaliQueries</span><span class="params">(string s, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">a</span>(n,vector&lt;<span class="keyword">int</span>&gt;(<span class="number">26</span>,<span class="number">0</span>));</span><br><span class="line">        a[<span class="number">0</span>][s[<span class="number">0</span>]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">26</span>;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                a[i][j]=a[i<span class="number">-1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">            a[i][s[i]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m=queries.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">res</span><span class="params">(m,<span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> query:queries)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> l=query[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> r=query[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> k=query[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">int</span> b[<span class="number">26</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                b[i]=a[r][i];</span><br><span class="line">                <span class="keyword">if</span>(l<span class="number">-1</span>&gt;=<span class="number">0</span>)</span><br><span class="line">                    b[i]-=a[l<span class="number">-1</span>][i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> c=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                c+=b[i]&amp;<span class="number">1</span>;    				<span class="comment">//与1进行位与运算 便可得到是否为奇数，good idea</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(c/<span class="number">2</span>&lt;=k)</span><br><span class="line">                res[i]=<span class="literal">true</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="5176-猜字谜"><a href="#5176-猜字谜" class="headerlink" title="5176.猜字谜"></a>5176.猜字谜</h4><h5 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h5><p>外国友人仿照中国字谜设计了一个英文版猜字谜小游戏，请你来猜猜看吧。</p>
<p>字谜的迷面 <code>puzzle</code> 按字符串形式给出，如果一个单词 <code>word</code> 符合下面两个条件，那么它就可以算作谜底：</p>
<ul>
<li>单词 <code>word</code> 中包含谜面 <code>puzzle</code> 的第一个字母。</li>
<li>单词 <code>word</code> 中的每一个字母都可以在谜面 <code>puzzle</code> 中找到。<br>例如，如果字谜的谜面是 “abcdefg”，那么可以作为谜底的单词有 “faced”, “cabbage”, 和 “baggage”；而 “beefed”（不含字母 “a”）以及 “based”（其中的 “s” 没有出现在谜面中）。</li>
</ul>
<p>返回一个答案数组 <code>answer</code>，数组中的每个元素 <code>answer[i]</code> 是在给出的单词列表 <code>words</code> 中可以作为字谜迷面 <code>puzzles[i]</code> 所对应的谜底的单词数目。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">words = [&quot;aaaa&quot;,&quot;asas&quot;,&quot;able&quot;,&quot;ability&quot;,&quot;actt&quot;,&quot;actor&quot;,&quot;access&quot;], </span><br><span class="line">puzzles = [&quot;aboveyz&quot;,&quot;abrodyz&quot;,&quot;abslute&quot;,&quot;absoryz&quot;,&quot;actresz&quot;,&quot;gaswxyz&quot;]</span><br><span class="line">输出：[1,1,3,2,4,0]</span><br><span class="line">解释：</span><br><span class="line">1 个单词可以作为 &quot;aboveyz&quot; 的谜底 : &quot;aaaa&quot; </span><br><span class="line">1 个单词可以作为 &quot;abrodyz&quot; 的谜底 : &quot;aaaa&quot;</span><br><span class="line">3 个单词可以作为 &quot;abslute&quot; 的谜底 : &quot;aaaa&quot;, &quot;asas&quot;, &quot;able&quot;</span><br><span class="line">2 个单词可以作为 &quot;absoryz&quot; 的谜底 : &quot;aaaa&quot;, &quot;asas&quot;</span><br><span class="line">4 个单词可以作为 &quot;actresz&quot; 的谜底 : &quot;aaaa&quot;, &quot;asas&quot;, &quot;actt&quot;, &quot;access&quot;</span><br><span class="line">没有单词可以作为 &quot;gaswxyz&quot; 的谜底，因为列表中的单词都不含字母 &#x27;g&#x27;。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= words.length &lt;= 10^5</code></li>
<li><code>4 &lt;= words[i].length &lt;= 50</code></li>
<li><code>1 &lt;= puzzles.length &lt;= 10^4</code></li>
<li><code>puzzles[i].length == 7</code></li>
<li><code>words[i][j]</code>, <code>puzzles[i][j]</code> 都是小写英文字母。</li>
<li>每个 <code>puzzles[i]</code> 所包含的字符都不重复。</li>
</ul>
<h5 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h5><p>此题借鉴大佬：小白二号</p>
<p>思路：</p>
<p>1.首先构建一个map数组map&lt;pair&lt;int,int&gt;,int&gt; wordmap;用来存每个单词  由值对做键，数量做值（学到了，可以这样建map）</p>
<p>2.pair中第一个int 表示该word中个字母组成的bitset用int表示的数，第二个int是用来判断是否存在puzzle[i]的第一个字母，已确定能否让res[i]的个数加1</p>
<p>技巧1：用int bit 存一个单词中每个字母是否出现过，因为字母只有26个 int可以表示32位，我们可以用二进制每一个位置来表示不同的字母，如$(1)_2$表示a，$(10)_2$表示b，依次类推</p>
<p>技巧2：遍历puzzle的子集，同样通过位运算来遍历，</p>
<p>首先我们知道puzzle的非空子集总共为（1&lt;&lt;len)-1个即127个，然后我们同样创建bit来表示该子集中的字母用int表示的数，通过i与（1&lt;&lt;j）进行&amp;运算，可知puzzle[j]能否放入该子集中，若能，我们再进行bit=bit与(1&lt;&lt;(puzzle[j]-‘a’))进行|运算，将其加入到bit中，最后我们将bit放入 ret数组，外层循环遍历完，返回ret数组</p>
<p>3.遍历puzzle[i]的子集sub，count+=map[make_pair(sub,pubble[0]-‘a’)] </p>
<p>count即为puzzle[i]的答案数组res[i]对应的数值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">findNumOfValidWords</span><span class="params">(vector&lt;string&gt;&amp; words, vector&lt;string&gt;&amp; puzzles)</span> </span>&#123;</span><br><span class="line">        map&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;,<span class="keyword">int</span>&gt; wordmap;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> word:words)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> bit=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> c:word)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> index=c-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(bit&amp;(<span class="number">1</span>&lt;&lt;index))</span><br><span class="line">                &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    bit+=(<span class="number">1</span>&lt;&lt;index);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count&gt;=<span class="number">8</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(bit&amp;(<span class="number">1</span>&lt;&lt;i))</span><br><span class="line">                    wordmap[<span class="built_in">make_pair</span>(bit,i)]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> puzzle:puzzles)</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; temp=<span class="built_in">make</span>(puzzle);</span><br><span class="line">            <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> sub:temp)</span><br><span class="line">            &#123;</span><br><span class="line">                count +=wordmap[<span class="built_in">make_pair</span>(sub,puzzle[<span class="number">0</span>]-<span class="string">&#x27;a&#x27;</span>)];</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">make</span><span class="params">(string puzzle)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=puzzle.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;(<span class="number">1</span>&lt;&lt;len);i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> bit=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;j))</span><br><span class="line">                &#123;</span><br><span class="line">                    bit=bit|(<span class="number">1</span>&lt;&lt;puzzle[j]-<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ret.<span class="built_in">push_back</span>(bit);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O($10^4 *(2^7-1)$) puzzles最长10^4 puzzle 又长度固定为7 所以每个的子集 固定为2^7个 ，所以这样时间不会超限</p>
]]></content>
      <tags>
        <tag>Leetcode</tag>
        <tag>周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-第153场周赛</title>
    <url>/2019/09/10/leetcode/zhou-sai/di-153-chang-zhou-sai/</url>
    <content><![CDATA[<h4 id="1184-公交站间的距离"><a href="#1184-公交站间的距离" class="headerlink" title="1184.公交站间的距离"></a>1184.公交站间的距离</h4><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>环形公交路线上有 <code>n</code> 个站，按次序从 <code>0</code> 到 <code>n - 1</code> 进行编号。我们已知每一对相邻公交站之间的距离，<code>distance[i]</code> 表示编号为 <code>i</code> 的车站和编号为 <code>(i + 1) % n</code> 的车站之间的距离。</p>
<p>环线上的公交车都可以按顺时针和逆时针的方向行驶。</p>
<p>返回乘客从出发点 <code>start</code> 到目的地 <code>destination</code> 之间的最短距离。</p>
 <span id="more"></span>

<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/08/untitled-diagram-1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：distance = [1,2,3,4], start = 0, destination = 1</span><br><span class="line">输出：1</span><br><span class="line">解释：公交站 0 和 1 之间的距离是 1 或 9，最小值是 1。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/08/untitled-diagram-1-1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：distance = [1,2,3,4], start = 0, destination = 2</span><br><span class="line">输出：3</span><br><span class="line">解释：公交站 0 和 2 之间的距离是 3 或 7，最小值是 3。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/08/untitled-diagram-1-2.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：distance = [1,2,3,4], start = 0, destination = 3</span><br><span class="line">输出：4</span><br><span class="line">解释：公交站 0 和 3 之间的距离是 6 或 4，最小值是 4。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 10^4</code></li>
<li><code>distance.length == n</code></li>
<li><code>0 &lt;= start, destination &lt; n</code></li>
<li><code>0 &lt;= distance[i] &lt;= 10^4</code></li>
</ul>
<h5 id="解法1：暴力模拟"><a href="#解法1：暴力模拟" class="headerlink" title="解法1：暴力模拟"></a>解法1：暴力模拟</h5><p>思路：题中已经说了，只有两种走法要么逆时针，要么顺时针，将两种走法都走一遍，选一个距离最小的即为结果</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">distanceBetweenBusStops</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; distance, <span class="keyword">int</span> start, <span class="keyword">int</span> destination)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=distance.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> l=start,r=destination;</span><br><span class="line">        <span class="keyword">int</span> suml=<span class="number">0</span>,sumr=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l!=r)</span><br><span class="line">        &#123;</span><br><span class="line">            suml+=distance[l];</span><br><span class="line">            <span class="keyword">if</span>(l==n<span class="number">-1</span>)</span><br><span class="line">                l=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> l++;</span><br><span class="line">        &#125;</span><br><span class="line">        l=start,r=destination;</span><br><span class="line">        <span class="keyword">while</span>(l!=r)</span><br><span class="line">        &#123;</span><br><span class="line">            sumr+=distance[r];</span><br><span class="line">            <span class="keyword">if</span>(r==n<span class="number">-1</span>)</span><br><span class="line">                r=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(suml,sumr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1185-一周中的第几天"><a href="#1185-一周中的第几天" class="headerlink" title="1185.一周中的第几天"></a>1185.一周中的第几天</h4><h5 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h5><p>给你一个日期，请你设计一个算法来判断它是对应一周中的哪一天。</p>
<p>输入为三个整数：<code>day</code>、<code>month</code> 和 <code>year</code>，分别表示日、月、年。</p>
<p>您返回的结果必须是这几个值中的一个 <code>&#123;&quot;Sunday&quot;, &quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;, &quot;Thursday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;&#125;</code>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：day = 31, month = 8, year = 2019</span><br><span class="line">输出：&quot;Saturday&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：day = 18, month = 7, year = 1999</span><br><span class="line">输出：&quot;Sunday&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：day = 15, month = 8, year = 1993</span><br><span class="line">输出：&quot;Sunday&quot;</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>给出的日期一定是在 <code>1971</code> 到 <code>2100</code> 年之间的有效日期。</li>
</ul>
<h5 id="解法1：暴力模拟-1"><a href="#解法1：暴力模拟-1" class="headerlink" title="解法1：暴力模拟"></a>解法1：暴力模拟</h5><p>我们知道公元1年1月1日是星期一，那么我们只要求出当前日期与公元1年1月1日的差，再对7取余，便可算到当前是星期几</p>
<p>先算出中间有多少个闰年，因为闰年比平年多1天，</p>
<p>然后算出当前年已经过去的月份的天数，再加上这个月的已经过的天数-1，再加上过去年份的天数已经闰年数</p>
<p>注意：若当前年为闰年要减去1天，因为当前年并没有过完，但算闰年的时候已经算上了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">dayOfTheWeek</span><span class="params">(<span class="keyword">int</span> day, <span class="keyword">int</span> month, <span class="keyword">int</span> year)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ya=year/<span class="number">4</span>;</span><br><span class="line">        <span class="keyword">int</span> a[<span class="number">12</span>]=&#123;<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> ms=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;month<span class="number">-1</span>;i++)</span><br><span class="line">            ms+=a[i];</span><br><span class="line">        <span class="keyword">if</span>(year%<span class="number">4</span>==<span class="number">0</span>&amp;&amp;month&gt;<span class="number">2</span>)</span><br><span class="line">            ms+=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ys=(year<span class="number">-1</span>)*<span class="number">365</span>+ya+ms+day<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(year%<span class="number">4</span>==<span class="number">0</span>)</span><br><span class="line">            ys-=<span class="number">1</span>;</span><br><span class="line">        string m[<span class="number">7</span>]=&#123;<span class="string">&quot;Sunday&quot;</span>, <span class="string">&quot;Monday&quot;</span>, <span class="string">&quot;Tuesday&quot;</span>, <span class="string">&quot;Wednesday&quot;</span>, <span class="string">&quot;Thursday&quot;</span>, <span class="string">&quot;Friday&quot;</span>, <span class="string">&quot;Saturday&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">return</span> m[ys%<span class="number">7</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1186-删除一次得到子数组的最大和"><a href="#1186-删除一次得到子数组的最大和" class="headerlink" title="1186.删除一次得到子数组的最大和"></a>1186.删除一次得到子数组的最大和</h4><h5 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h5><p>给你一个整数数组，返回它的某个 <strong>非空</strong> 子数组（连续元素）在执行一次可选的删除操作后，所能得到的最大元素总和。</p>
<p>换句话说，你可以从原数组中选出一个子数组，并可以决定要不要从中删除一个元素（只能删一次哦），（删除后）子数组中至少应当有一个元素，然后该子数组（剩下）的元素总和是所有子数组之中最大的。</p>
<p>注意，删除一个元素后，子数组 <strong>不能为空</strong>。</p>
<p>请看示例：</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：arr = [1,-2,0,3]</span><br><span class="line">输出：4</span><br><span class="line">解释：我们可以选出 [1, -2, 0, 3]，然后删掉 -2，这样得到 [1, 0, 3]，和最大。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：arr = [1,-2,-2,3]</span><br><span class="line">输出：3</span><br><span class="line">解释：我们直接选出 [3]，这就是最大和。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：arr = [-1,-1,-1,-1]</span><br><span class="line">输出：-1</span><br><span class="line">解释：最后得到的子数组不能为空，所以我们不能选择 [-1] 并从中删去 -1 来得到 0。</span><br><span class="line">     我们应该直接选择 [-1]，或者选择 [-1, -1] 再从中删去一个 -1。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= arr.length &lt;= 10^5</code></li>
<li><code>-10^4 &lt;= arr[i] &lt;= 10^4</code></li>
</ul>
<h5 id="解法1：动态规划"><a href="#解法1：动态规划" class="headerlink" title="解法1：动态规划"></a>解法1：动态规划</h5><p>1.建立一个dp二维数组dp[n][2]；</p>
<p>dp[i][0]表示 不 删除元素从0到当前i位置的最大子数组和</p>
<p>dp[i][1]表示删除1个元素从0到当前i位置的最大子数组和</p>
<p>2.写出状态转移方程</p>
<p>不删除元素状态转移方程很自然写出来，leetcode53与这一步相同</p>
<p>dp[i][0]=max(dp[i-1][0]+arr[i],arr[i])</p>
<p>删除1个元素状态转移方程</p>
<p>dp[i][1]=max(dp[i-1][0],dp[i-1][1]+arr[i])</p>
<p>意思就是 最大值要么是前面已经删除了1个元素+当前元素 要么是前面没有删除元素，删除当前元素</p>
<p>3.每次循环判断最大值res，循环遍历完毕返回res得到结果</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=arr.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(n,vector&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>,<span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=arr[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res=arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>]+arr[i],arr[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>]+arr[i],dp[i<span class="number">-1</span>][<span class="number">0</span>]);</span><br><span class="line">            res=<span class="built_in">max</span>(dp[i][<span class="number">0</span>],res);</span><br><span class="line">            res=<span class="built_in">max</span>(dp[i][<span class="number">1</span>],res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1187-使数组严格递增"><a href="#1187-使数组严格递增" class="headerlink" title="1187.使数组严格递增"></a>1187.使数组严格递增</h4><h5 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h5><p>给你两个整数数组 <code>arr1</code> 和 <code>arr2</code>，返回使 <code>arr1</code> 严格递增所需要的最小「操作」数（可能为 0）。</p>
<p>每一步「操作」中，你可以分别从 <code>arr1</code> 和 <code>arr2</code> 中各选出一个索引，分别为 <code>i</code> 和 <code>j</code>，<code>0 &lt;= i &lt; arr1.length</code> 和 <code>0 &lt;= j &lt; arr2.length</code>，然后进行赋值运算 <code>arr1[i] = arr2[j]</code>。</p>
<p>如果无法让 <code>arr1</code> 严格递增，请返回 <code>-1</code>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：arr1 = [1,5,3,6,7], arr2 = [1,3,2,4]</span><br><span class="line">输出：1</span><br><span class="line">解释：用 2 来替换 5，之后 arr1 = [1, 2, 3, 6, 7]。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：arr1 = [1,5,3,6,7], arr2 = [4,3,1]</span><br><span class="line">输出：2</span><br><span class="line">解释：用 3 来替换 5，然后用 4 来替换 3，得到 arr1 = [1, 3, 4, 6, 7]。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：arr1 = [1,5,3,6,7], arr2 = [1,6,3,3]</span><br><span class="line">输出：-1</span><br><span class="line">解释：无法使 arr1 严格递增。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= arr1.length, arr2.length &lt;= 2000</code></li>
<li><code>0 &lt;= arr1[i], arr2[i] &lt;= 10^9</code></li>
</ul>
<h5 id="解法1-动态规划-二分"><a href="#解法1-动态规划-二分" class="headerlink" title="解法1:动态规划+二分"></a>解法1:动态规划+二分</h5><p>定义dp[i]，表示0~i保存i元素存在的最小 操作 数。</p>
<p>dp[i]=min(dp[i],dp[j]+(i-j-1)) 其中j从0到i-1,arr1[j]&lt;arr1[i],(i-j-1)为替换的元素个数。被替换元素的下标从j+1到i-1，所需要的替换元素arr2[k]满足arr1[j]&lt;arr2[k]&lt;arr1[i]</p>
<p>1.对arr2进行预处理，先排序，然后去掉重复元素。这样我们就可以通过二分查找找到替换元素所在的位置</p>
<p>2.算出dp[i]我们发现，我们并没有判断最后一个arr1的最后一个数字是否替换，同时状态转移方程也不能满足arr1的第一个元素，无法判断第一个元素是否替换。</p>
<p>我们可以做以下处理，（1）在arr1的末位添加一位数字INT_MAX,这个数字不需要被考虑替换，我们也就可以判断arr1原数组最后一个数字是否替换。（2）在arr1的首部添加一个比任何值小的数，这样我们也就能判断arr1原数组的第一个元素是否替换。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">makeArrayIncreasing</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr1, vector&lt;<span class="keyword">int</span>&gt;&amp; arr2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=arr1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a1</span><span class="params">(n+<span class="number">2</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        a1[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            a1[i+<span class="number">1</span>]=arr1[i];</span><br><span class="line">        &#125;</span><br><span class="line">        a1[n+<span class="number">1</span>]=INT_MAX;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">2</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">sort</span>(arr2.<span class="built_in">begin</span>(),arr2.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt;::iterator ite=<span class="built_in">unique</span>(arr2.<span class="built_in">begin</span>(),arr2.<span class="built_in">end</span>());</span><br><span class="line">        arr2.<span class="built_in">erase</span>(ite,arr2.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i]=INT_MAX;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// a[j] 必须满足 a[j] &lt; a[i]，并且 dp[j] 可解，即可以保持 j 元素存在并且数组递增</span></span><br><span class="line">                <span class="keyword">if</span>(a1[i]&lt;=a1[j]||dp[j]==INT_MAX)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">//  判断是否可以成功替换</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">find</span>(j,i,a1,arr2))</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i]=<span class="built_in">min</span>(dp[i],dp[j]+(i-j<span class="number">-1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n+<span class="number">1</span>]==INT_MAX?<span class="number">-1</span>:dp[n+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> j,<span class="keyword">int</span> i,vector&lt;<span class="keyword">int</span>&gt;&amp; a1,vector&lt;<span class="keyword">int</span>&gt;&amp; arr2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(j+<span class="number">1</span>==i)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 找到大于 a1[j] 的元素的最小下标 minIdx</span></span><br><span class="line">   	    <span class="comment">// 找到小于 a1[i] 的元素的最大下标 maxIdx</span></span><br><span class="line">        <span class="keyword">int</span> minIdx=<span class="built_in">bs1</span>(a1[j],arr2);</span><br><span class="line">        <span class="keyword">int</span> maxIdx=<span class="built_in">bs2</span>(a1[i],arr2);</span><br><span class="line">        <span class="keyword">if</span>(minIdx==arr2.<span class="built_in">size</span>()||maxIdx==<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> (i-j<span class="number">-1</span>)&lt;=(maxIdx-minIdx+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//以下套用二分模板，求最小下标，最大下标</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bs1</span><span class="params">(<span class="keyword">int</span> target,vector&lt;<span class="keyword">int</span>&gt;&amp; arr2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=arr2.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid=l+(r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(arr2[mid]&lt;=target)</span><br><span class="line">                l=mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr2[l]&gt;target?l:arr2.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bs2</span><span class="params">(<span class="keyword">int</span> target,vector&lt;<span class="keyword">int</span>&gt;&amp; arr2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=arr2.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid=l+(r-l+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(arr2[mid]&gt;=target)</span><br><span class="line">                r=mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                l=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr2[l]&lt;target?l:<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O（$N^2LogM$）</p>
<h5 id="解法2：再次优化"><a href="#解法2：再次优化" class="headerlink" title="解法2：再次优化"></a>解法2：再次优化</h5><p>将二分查找部分再次优化，在第一层循环内直接找到小于元素a[i]的最大下标r，然后我们找到允许替换的最大下标（即若能替换这部分，若是比这个下标还大，arr2部分数组的长度就比i-j-1小了），也就是直接找到</p>
<p>l=r-(i-j-1)+1,判断arr2[l]跟a[j]的关系，若arr2[l]大于a[j]表示可以替换这部分，否则就是不能替换</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">makeArrayIncreasing</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr1, vector&lt;<span class="keyword">int</span>&gt;&amp; arr2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=arr1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a1</span><span class="params">(n+<span class="number">2</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        a1[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            a1[i+<span class="number">1</span>]=arr1[i];</span><br><span class="line">        &#125;</span><br><span class="line">        a1[n+<span class="number">1</span>]=INT_MAX;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">2</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">sort</span>(arr2.<span class="built_in">begin</span>(),arr2.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt;::iterator ite=<span class="built_in">unique</span>(arr2.<span class="built_in">begin</span>(),arr2.<span class="built_in">end</span>());</span><br><span class="line">        arr2.<span class="built_in">erase</span>(ite,arr2.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i]=INT_MAX;</span><br><span class="line">            <span class="keyword">int</span> r=<span class="built_in">bs2</span>(a1[i],arr2);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// a[j] 必须满足 a[j] &lt; a[i]，并且 dp[j] 可解，即可以保持 j 元素存在并且数组递增</span></span><br><span class="line">                <span class="keyword">if</span>(a1[i]&lt;=a1[j]||dp[j]==INT_MAX)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">//  判断是否可以成功替换</span></span><br><span class="line">                <span class="keyword">int</span> l=r-(i-j<span class="number">-1</span>)+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(j+<span class="number">1</span>==i||r&gt;=<span class="number">0</span>&amp;&amp;l&gt;=<span class="number">0</span>&amp;&amp;arr2[l]&gt;a1[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i]=<span class="built_in">min</span>(dp[i],dp[j]+(i-j<span class="number">-1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n+<span class="number">1</span>]==INT_MAX?<span class="number">-1</span>:dp[n+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//以下套用二分模板，求最大下标</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bs2</span><span class="params">(<span class="keyword">int</span> target,vector&lt;<span class="keyword">int</span>&gt;&amp; arr2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=arr2.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid=l+(r-l+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(arr2[mid]&gt;=target)</span><br><span class="line">                r=mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                l=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr2[l]&lt;target?l:<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度:O($n^2$)</p>
]]></content>
      <categories>
        <category>周赛</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-第155场周赛</title>
    <url>/2019/10/04/leetcode/zhou-sai/di-155-chang-zhou-sai/</url>
    <content><![CDATA[<h4 id="5197-最小绝对差"><a href="#5197-最小绝对差" class="headerlink" title="5197.最小绝对差"></a>5197.最小绝对差</h4><p>给你个整数数组 <code>arr</code>，其中每个元素都 <strong>不相同</strong>。</p>
<p>请你找到所有具有最小绝对差的元素对，并且按升序的顺序返回。</p>
  <span id="more"></span>

<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：arr = [4,2,1,3]</span><br><span class="line">输出：[[1,2],[2,3],[3,4]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：arr = [1,3,6,10,15]</span><br><span class="line">输出：[[1,3]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：arr = [3,8,-10,23,19,-4,-14,27]</span><br><span class="line">输出：[[-14,-10],[19,23],[23,27]]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= arr.length &lt;= 10^5</code></li>
<li><code>-10^6 &lt;= arr[i] &lt;= 10^6</code></li>
</ul>
<h5 id="解法1：暴力"><a href="#解法1：暴力" class="headerlink" title="解法1：暴力"></a>解法1：暴力</h5><p>先排序，然后找到差值最小的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">minimumAbsDifference</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; arr) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(),arr.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">int</span> n=arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> min=INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x=arr[i]-arr[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(x&gt;min)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(x&lt;min)</span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">clear</span>();</span><br><span class="line">                min=x;</span><br><span class="line">            &#125;</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">            temp.<span class="built_in">push_back</span>(arr[i<span class="number">-1</span>]);</span><br><span class="line">            temp.<span class="built_in">push_back</span>(arr[i]);</span><br><span class="line">            res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="5198-丑数-III"><a href="#5198-丑数-III" class="headerlink" title="5198.丑数 III"></a>5198.丑数 III</h4><p>请你帮忙设计一个程序，用来找出第 <code>n</code> 个丑数。</p>
<p>丑数是可以被 <code>a</code> <strong>或</strong> <code>b</code> <strong>或</strong> <code>c</code> 整除的 <strong>正整数</strong>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 3, a = 2, b = 3, c = 5</span><br><span class="line">输出：4</span><br><span class="line">解释：丑数序列为 2, 3, 4, 5, 6, 8, 9, 10... 其中第 3 个是 4。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 4, a = 2, b = 3, c = 4</span><br><span class="line">输出：6</span><br><span class="line">解释：丑数序列为 2, 3, 4, 6, 8, 9, 12... 其中第 4 个是 6。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 5, a = 2, b = 11, c = 13</span><br><span class="line">输出：10</span><br><span class="line">解释：丑数序列为 2, 4, 6, 8, 10, 11, 12, 13... 其中第 5 个是 10。</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 1000000000, a = 2, b = 217983653, c = 336916467</span><br><span class="line">输出：1999999984</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n, a, b, c &lt;= 10^9</code></li>
<li><code>1 &lt;= a * b * c &lt;= 10^18</code></li>
<li>本题结果在 <code>[1, 2 * 10^9]</code> 的范围内</li>
</ul>
<h5 id="解法1：二分-容斥原理"><a href="#解法1：二分-容斥原理" class="headerlink" title="解法1：二分+容斥原理"></a>解法1：二分+容斥原理</h5><p>1.采用二分，找到左边第一个个数符合n的数</p>
<p>2.求个数get_idx采用容斥原理mid/_a+mid/_b+mid/_c-mid/lcm(_a,_b)-mid/lcm(_a,_c)-mid/lcm(_b,_c)+mid/lcm(lcm(_a,_b),_c)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> _a;</span><br><span class="line">    <span class="keyword">int</span> _b;</span><br><span class="line">    <span class="keyword">int</span> _c;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        _a=a;</span><br><span class="line">        _b=b;</span><br><span class="line">        _c=c;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> left=<span class="number">1</span>,right=<span class="number">2</span>*<span class="built_in">pow</span>(<span class="number">10</span>,<span class="number">9</span>)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> idx=<span class="built_in">get_idx</span>(mid);</span><br><span class="line">            <span class="keyword">if</span>(idx&lt;n)</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                right=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">get_idx</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> mid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mid/_a+mid/_b+mid/_c-mid/<span class="built_in">lcm</span>(_a,_b)-mid/<span class="built_in">lcm</span>(_a,_c)-mid/<span class="built_in">lcm</span>(_b,_c)+mid/<span class="built_in">lcm</span>(<span class="built_in">lcm</span>(_a,_b),_c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">lcm</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (a/<span class="built_in">gcd</span>(a,b))*b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">gcd</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a&lt;b) <span class="keyword">return</span> <span class="built_in">gcd</span>(b,a);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> r;</span><br><span class="line">        <span class="keyword">while</span>(b)</span><br><span class="line">        &#123;</span><br><span class="line">            r=a%b;</span><br><span class="line">            a=b;</span><br><span class="line">            b=r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="5199-交换字符串中的元素"><a href="#5199-交换字符串中的元素" class="headerlink" title="5199.交换字符串中的元素"></a>5199.交换字符串中的元素</h4><p>给你一个字符串 <code>s</code>，以及该字符串中的一些「索引对」数组 <code>pairs</code>，其中 <code>pairs[i] = [a, b]</code> 表示字符串中的两个索引（编号从 0 开始）。</p>
<p>你可以 <strong>任意多次交换</strong> 在 <code>pairs</code> 中任意一对索引处的字符。</p>
<p>返回在经过若干次交换后，<code>s</code> 可以变成的按字典序最小的字符串。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;dcab&quot;, pairs = [[0,3],[1,2]]</span><br><span class="line">输出：&quot;bacd&quot;</span><br><span class="line">解释： </span><br><span class="line">交换 s[0] 和 s[3], s = &quot;bcad&quot;</span><br><span class="line">交换 s[1] 和 s[2], s = &quot;bacd&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;dcab&quot;, pairs = [[0,3],[1,2],[0,2]]</span><br><span class="line">输出：&quot;abcd&quot;</span><br><span class="line">解释：</span><br><span class="line">交换 s[0] 和 s[3], s = &quot;bcad&quot;</span><br><span class="line">交换 s[0] 和 s[2], s = &quot;acbd&quot;</span><br><span class="line">交换 s[1] 和 s[2], s = &quot;abcd&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;cba&quot;, pairs = [[0,1],[1,2]]</span><br><span class="line">输出：&quot;abc&quot;</span><br><span class="line">解释：</span><br><span class="line">交换 s[0] 和 s[1], s = &quot;bca&quot;</span><br><span class="line">交换 s[1] 和 s[2], s = &quot;bac&quot;</span><br><span class="line">交换 s[0] 和 s[1], s = &quot;abc&quot;</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 10^5</code></li>
<li><code>0 &lt;= pairs.length &lt;= 10^5</code></li>
<li><code>0 &lt;= pairs[i][0], pairs[i][1] &lt; s.length</code></li>
<li><code>s</code> 中只含有小写英文字母</li>
</ul>
<h5 id="解法1：并查集"><a href="#解法1：并查集" class="headerlink" title="解法1：并查集"></a>解法1：并查集</h5><p>注意采用n复杂度交换元素，采用n^2会超限</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; pre;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">smallestStringWithSwaps</span><span class="params">(string s, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; pairs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=pairs.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> len=s.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; _pre(len,<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            _pre[i]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;pre=_pre;</span><br><span class="line">        <span class="keyword">for</span>(vector&lt;<span class="keyword">int</span>&gt; pair:pairs)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x,y;</span><br><span class="line">            x=<span class="built_in">find</span>(pair[<span class="number">0</span>]);</span><br><span class="line">            y=<span class="built_in">find</span>(pair[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(x!=y)</span><br><span class="line">            &#123;</span><br><span class="line">                pre[x]=y;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        map&lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">char</span>&gt;&gt; strs;</span><br><span class="line">        map&lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;&gt; idxs;</span><br><span class="line">        <span class="function">unordered_set&lt;<span class="keyword">int</span>&gt; <span class="title">unique_pre</span><span class="params">(pre.begin(),pre.end())</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> u_p=<span class="built_in">find</span>(i);</span><br><span class="line">            idxs[u_p].<span class="built_in">push_back</span>(i);</span><br><span class="line">            strs[u_p].<span class="built_in">push_back</span>(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(map&lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">char</span>&gt;&gt;::iterator ite=strs.<span class="built_in">begin</span>();ite!=strs.<span class="built_in">end</span>();ite++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> k=ite-&gt;first;</span><br><span class="line">            <span class="built_in">sort</span>(strs[k].<span class="built_in">begin</span>(),strs[k].<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(map&lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;&gt;::iterator ite=idxs.<span class="built_in">begin</span>();ite!=idxs.<span class="built_in">end</span>();ite++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> k=ite-&gt;first;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;idxs[k].<span class="built_in">size</span>();i++)</span><br><span class="line">            &#123;</span><br><span class="line">                s[idxs[k][i]]=strs[k][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> son=root,temp;</span><br><span class="line">        <span class="keyword">while</span>(root!=pre[root])</span><br><span class="line">            root=pre[root];</span><br><span class="line">        <span class="keyword">while</span>(son!=root)</span><br><span class="line">        &#123;</span><br><span class="line">            temp=pre[son];</span><br><span class="line">            pre[son]=root;</span><br><span class="line">            son=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>周赛</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-第154场周赛</title>
    <url>/2019/09/18/leetcode/zhou-sai/di-154-chang-zhou-sai/</url>
    <content><![CDATA[<h4 id="1189-”气球”的最大数量"><a href="#1189-”气球”的最大数量" class="headerlink" title="1189.”气球”的最大数量"></a>1189.”气球”的最大数量</h4><p>给你一个字符串 <code>text</code>，你需要使用 <code>text</code> 中的字母来拼凑尽可能多的单词 <strong>“balloon”（气球）</strong>。</p>
<p>字符串 <code>text</code> 中的每个字母最多只能被使用一次。请你返回最多可以拼凑出多少个单词 **”balloon”**。</p>
 <span id="more"></span>

<p><strong>示例 1：</strong></p>
<p><strong><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/14/1536_ex1_upd.jpeg" alt="img"></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：text = &quot;nlaebolko&quot;</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><strong><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/14/1536_ex2_upd.jpeg" alt="img"></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：text = &quot;loonbalxballpoon&quot;</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：text = &quot;leetcode&quot;</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= text.length &lt;= 10^4</code></li>
<li><code>text</code> 全部由小写英文字母组成</li>
</ul>
<h5 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h5><p>简单题。</p>
<p>思路：</p>
<p>创建一个hash表来存各个字母的出现次数，找a,b,l/2,o/2,n的最小值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxNumberOfBalloons</span><span class="params">(string text)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=text.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(<span class="number">26</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res[text[i]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mins=INT_MAX;</span><br><span class="line">        mins=<span class="built_in">min</span>(mins,res[<span class="number">0</span>]);</span><br><span class="line">        mins=<span class="built_in">min</span>(mins,res[<span class="number">1</span>]);</span><br><span class="line">        mins=<span class="built_in">min</span>(mins,res[<span class="number">11</span>]/<span class="number">2</span>);</span><br><span class="line">        mins=<span class="built_in">min</span>(mins,res[<span class="number">13</span>]);</span><br><span class="line">        mins=<span class="built_in">min</span>(mins,res[<span class="number">14</span>]/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> mins;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1190-反转每对括号间的子串"><a href="#1190-反转每对括号间的子串" class="headerlink" title="1190.反转每对括号间的子串"></a>1190.反转每对括号间的子串</h4><p>给出一个字符串 <code>s</code>（仅含有小写英文字母和括号）。</p>
<p>请你按照从括号内到外的顺序，逐层反转每对匹配括号中的字符串，并返回最终的结果。</p>
<p>注意，您的结果中 <strong>不应</strong> 包含任何括号。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;(abcd)&quot;</span><br><span class="line">输出：&quot;dcba&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;(u(love)i)&quot;</span><br><span class="line">输出：&quot;iloveu&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;(ed(et(oc))el)&quot;</span><br><span class="line">输出：&quot;leetcode&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;a(bcdefghijkl(mno)p)q&quot;</span><br><span class="line">输出：&quot;apmnolkjihgfedcbq&quot;</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= s.length &lt;= 2000</code></li>
<li><code>s</code> 中只有小写英文字母和括号</li>
<li>我们确保所有括号都是成对出现的</li>
</ul>
<h5 id="解法1：栈"><a href="#解法1：栈" class="headerlink" title="解法1：栈"></a>解法1：栈</h5><p>思路：用栈存左括号出现位置，当遇见右括号时，翻转从栈顶值左括号到这个右括号的子串。</p>
<p>再遍历一遍字符串，将不是左右括号的字符挨个存入结果字符串。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseParentheses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        string res=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> n=s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                st.<span class="built_in">push</span>(i);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> t=st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>()+t,s.<span class="built_in">begin</span>()+i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]!=<span class="string">&#x27;(&#x27;</span>&amp;&amp;s[i]!=<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">                res+=s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1191-K次串联后最大子数组之和"><a href="#1191-K次串联后最大子数组之和" class="headerlink" title="1191.K次串联后最大子数组之和"></a>1191.K次串联后最大子数组之和</h4><p>给你一个整数数组 <code>arr</code> 和一个整数 <code>k</code>。</p>
<p>首先，我们要对该数组进行修改，即把原数组 <code>arr</code> 重复 <code>k</code> 次。</p>
<blockquote>
<p>举个例子，如果 <code>arr = [1, 2]</code> 且 <code>k = 3</code>，那么修改后的数组就是 <code>[1, 2, 1, 2, 1, 2]</code>。</p>
</blockquote>
<p>然后，请你返回修改后的数组中的最大的子数组之和。</p>
<p>注意，子数组长度可以是 <code>0</code>，在这种情况下它的总和也是 <code>0</code>。</p>
<p>由于 <strong>结果可能会很大</strong>，所以需要 <strong>模（mod）</strong> <code>10^9 + 7</code> 后再返回。 </p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：arr = [1,2], k = 3</span><br><span class="line">输出：9</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：arr = [1,-2,1], k = 5</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：arr = [-1,-2], k = 7</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= arr.length &lt;= 10^5</code></li>
<li><code>1 &lt;= k &lt;= 10^5</code></li>
<li><code>-10^4 &lt;= arr[i] &lt;= 10^4</code></li>
</ul>
<h5 id="解法1：前缀和，后缀和"><a href="#解法1：前缀和，后缀和" class="headerlink" title="解法1：前缀和，后缀和"></a>解法1：前缀和，后缀和</h5><p>先计算出arr数组的总和，然后分两种情况进行讨论</p>
<p>1.若sum&gt;0&amp;&amp;k&gt;2</p>
<p>​    这种情况我们可以求出arr数组的最大前缀和（即复制到最右边的数组应该取的值）和最大后缀和（即最左边数组应该取的值）因为中间每个arr的和sum&gt;0所以我们肯定要加上每个sum。</p>
<p>2.</p>
<p>​    (1).若k&gt;1，我们复制一次arr。</p>
<p>​    (2)找到arr这个数组的最大子序和即为所求结果。</p>
<p>注意：中间数字用int会溢出，所以我们用long long 存数组,最后结果mod10^9+7.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kConcatenationMaxSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mod=<span class="built_in">pow</span>(<span class="number">10</span>,<span class="number">9</span>)+<span class="number">7</span>;</span><br><span class="line">        <span class="keyword">int</span> n=arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; <span class="title">sum</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n+<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum[i]=sum[i<span class="number">-1</span>]+arr[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(sum[n]&gt;<span class="number">0</span>&amp;&amp;k&gt;<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> frist=<span class="number">0</span>,last=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n+<span class="number">1</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                frist=<span class="built_in">max</span>(frist,sum[n]-sum[n-i]);</span><br><span class="line">                last=<span class="built_in">max</span>(last,sum[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            res=frist+last+(k<span class="number">-2</span>)*sum[n];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; <span class="built_in">temp</span>(arr);</span><br><span class="line">            <span class="keyword">if</span>(k&gt;<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> x:arr)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp.<span class="built_in">push_back</span>(x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">sum_t</span>=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;temp.<span class="built_in">size</span>();i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">sum_t</span>&gt;<span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">sum_t</span>+=temp[i];</span><br><span class="line">                <span class="keyword">else</span>    <span class="keyword">sum_t</span>=temp[i];</span><br><span class="line">                res=<span class="built_in">max</span>(res,<span class="keyword">sum_t</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1192-查找集群内的「关键连接」"><a href="#1192-查找集群内的「关键连接」" class="headerlink" title="1192.查找集群内的「关键连接」"></a>1192.查找集群内的「关键连接」</h4><p>力扣数据中心有 <code>n</code> 台服务器，分别按从 <code>0</code> 到 <code>n-1</code> 的方式进行了编号。</p>
<p>它们之间以「服务器到服务器」点对点的形式相互连接组成了一个内部集群，其中连接 <code>connections</code> 是无向的。</p>
<p>从形式上讲，<code>connections[i] = [a, b]</code> 表示服务器 <code>a</code> 和 <code>b</code> 之间形成连接。任何服务器都可以直接或者间接地通过网络到达任何其他服务器。</p>
<p>「关键连接」是在该集群中的重要连接，也就是说，假如我们将它移除，便会导致某些服务器无法访问其他服务器。</p>
<p>请你以任意顺序返回该集群内的所有 「关键连接」。</p>
<p><strong>示例 1：</strong></p>
<p><strong><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/original_images/critical-connections-in-a-network.png" alt="img"></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 4, connections = [[0,1],[1,2],[2,0],[1,3]]</span><br><span class="line">输出：[[1,3]]</span><br><span class="line">解释：[[3,1]] 也是正确的。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 10^5</code></li>
<li><code>n-1 &lt;= connections.length &lt;= 10^5</code></li>
<li><code>connections[i][0] != connections[i][1]</code></li>
<li>不存在重复的连接</li>
</ul>
<h5 id="解法1：Tarjan算法"><a href="#解法1：Tarjan算法" class="headerlink" title="解法1：Tarjan算法"></a>解法1：Tarjan算法</h5><p>找到图中的割点问题。用Tarjan算法实现。</p>
<p>算法实现步骤：</p>
<p>1.定义dfn[i]数组表示dfs遍历时的i点的次序从1开始</p>
<p>2.定义low[i]数组表示i点不经过父节点能到达编号最小的点的数值</p>
<p>3.定义father[i]数组表示i点的父节点</p>
<p>4.遍历connections数组将每个边的两端记录下来。然后进行tarjan算法。</p>
<p>​    tarjan算法：</p>
<p>​    对每个点设置父节点，dfs遍历次序dfn[i]的值，默认low[i]值为dfs[i]，对与i直接相连的点进行遍历，设为to,</p>
<p>（1）to为父节点跳过，</p>
<p>（2）dfn[to]==-1表示还未遍历，进行tarjan(to,i)，然后low[i]在low[i]和low[to]选择一个最小值</p>
<p>（3)若已经遍历dfn[to] low[i]在low[i]和dfn[to]选择一个最小值</p>
<p>5.进行完tarjan算法，遍历所有点，判断父节点dfn[f]和low[i]关系，若low[i]&gt;dfn[f]表示i点必须经过父节点f才能访问到f也就意味着(i,f)这条边是一个割边。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; _g;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; _low;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; _dfn;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; _father;</span><br><span class="line">    <span class="keyword">int</span> time;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">criticalConnections</span>(<span class="keyword">int</span> n, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; connections) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">g</span>(n+<span class="number">1</span>);</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">low</span><span class="params">(n+<span class="number">1</span>,<span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dfn</span><span class="params">(n+<span class="number">1</span>,<span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">father</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_g=g;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_low=low;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_dfn=dfn;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_father=father;</span><br><span class="line">        time=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> temp:connections)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> from=temp[<span class="number">0</span>]+<span class="number">1</span>,to=temp[<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">            _g[from].<span class="built_in">push_back</span>(to);</span><br><span class="line">            _g[to].<span class="built_in">push_back</span>(from);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">tarjan</span>(<span class="number">1</span>,<span class="number">0</span>);	<span class="comment">//从编号1点开始dfs 1的父节点假设为0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> f=_father[i];</span><br><span class="line">            <span class="keyword">if</span>(f&gt;<span class="number">0</span>&amp;&amp;_low[i]&gt;_dfn[f])</span><br><span class="line">            &#123;</span><br><span class="line">                vector&lt;<span class="keyword">int</span>&gt; re;</span><br><span class="line">                re.<span class="built_in">push_back</span>(i<span class="number">-1</span>);</span><br><span class="line">                re.<span class="built_in">push_back</span>(f<span class="number">-1</span>);</span><br><span class="line">                res.<span class="built_in">push_back</span>(re);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> ifather)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _father[i]=ifather;</span><br><span class="line">        time++;</span><br><span class="line">        _low[i]=time;</span><br><span class="line">        _dfn[i]=time;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;_g[i].<span class="built_in">size</span>();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> to=_g[i][j];</span><br><span class="line">            <span class="keyword">if</span>(ifather==to)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(_dfn[to]==<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">tarjan</span>(to,i);</span><br><span class="line">                _low[i]=<span class="built_in">min</span>(_low[i],_low[to]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                _low[i]=<span class="built_in">min</span>(_low[i],_dfn[to]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>周赛</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-第157场周赛</title>
    <url>/2019/10/06/leetcode/zhou-sai/di-157-chang-zhou-sai/</url>
    <content><![CDATA[<h4 id="5213-玩筹码"><a href="#5213-玩筹码" class="headerlink" title="5213.玩筹码"></a>5213.玩筹码</h4><h5 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h5><p>本质是找奇数的个数和偶数的个数，输出较小值</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostToMoveChips</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; chips)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=chips.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> ji=<span class="number">0</span>,ou=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(chips[i]%<span class="number">2</span>)</span><br><span class="line">                ji++;</span><br><span class="line">            <span class="keyword">else</span> ou++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(ji,ou);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="5214-最长定差子序列"><a href="#5214-最长定差子序列" class="headerlink" title="5214.最长定差子序列"></a>5214.最长定差子序列</h4><h5 id="解法1：map"><a href="#解法1：map" class="headerlink" title="解法1：map"></a>解法1：map</h5><p>用map存当前元素的下个数值arr[i]+difference表示当前子序列的最大长度</p>
<p>以arr = [1,5,7,8,5,3,4,2,1], difference = -2为例</p>
<p>1的下一个子序列数字应该-1，我们存m[-1]=max(m[-1],m[1]+1)；</p>
<p>5的下一个子序列数字应该3，我们存m[3]=max(m[3],m[5]+1)；</p>
<p>7的下一个子序列数字应该5，我们存m[5]=max(m[5],m[7]+1)；</p>
<p>8的下一个子序列数字应该6，我们存m[6]=max(m[6],m[8]+1)；</p>
<p>5的下一个子序列数字应该3，我们存m[3]=max(m[3],m[5]+1)；</p>
<p>3的下一个子序列数字应该1，我们存m[1]=max(m[1],m[3]+1)；</p>
<p>依次类推，找到map中存的最大数值就是要返回的最大子序列长度</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestSubsequence</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> difference)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">int</span> n=arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            m[arr[i]+difference]=<span class="built_in">max</span>(m[arr[i]]+<span class="number">1</span>,m[arr[i]+difference]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res=INT_MIN;</span><br><span class="line">        <span class="keyword">for</span>(map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::iterator ite=m.<span class="built_in">begin</span>();ite!=m.<span class="built_in">end</span>();ite++)</span><br><span class="line">        &#123;</span><br><span class="line">            res=<span class="built_in">max</span>(res,ite-&gt;second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="5215-黄金矿工"><a href="#5215-黄金矿工" class="headerlink" title="5215.黄金矿工"></a>5215.黄金矿工</h4><h5 id="解法1：dfs"><a href="#解法1：dfs" class="headerlink" title="解法1：dfs"></a>解法1：dfs</h5><p>因为数据量很小，所以可以采用dfs来解决该题。</p>
<p>用一个used记录走过的点，temp记录当前获得黄金，dir是4个行进方向</p>
<p>注意跳过为0的点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> res=INT_MIN;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMaximumGold</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        n=grid.<span class="built_in">size</span>(),m=grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">used</span>(n,vector&lt;<span class="keyword">bool</span>&gt;(m,<span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                used[i][j]=<span class="literal">true</span>;</span><br><span class="line">                temp=temp+grid[i][j];</span><br><span class="line">                 res=<span class="built_in">max</span>(res,temp);</span><br><span class="line">                <span class="built_in">dfs</span>(i,j,temp,grid,used);</span><br><span class="line">                temp=temp-grid[i][j];</span><br><span class="line">                used[i][j]=<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> temp,vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid,vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt;&amp; used)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x=dir[k][<span class="number">0</span>]+i,y=dir[k][<span class="number">1</span>]+j;</span><br><span class="line">            <span class="keyword">if</span>(x&gt;=<span class="number">0</span>&amp;&amp;x&lt;n&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;y&lt;m&amp;&amp;!used[x][y]&amp;&amp;grid[x][y]!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                used[x][y]=<span class="literal">true</span>;</span><br><span class="line">                temp=temp+grid[x][y];</span><br><span class="line">                <span class="built_in">dfs</span>(x,y,temp,grid,used);</span><br><span class="line">                res=<span class="built_in">max</span>(res,temp);</span><br><span class="line">                temp=temp-grid[x][y];</span><br><span class="line">                used[x][y]=<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="5216-统计元音字母序列的数目"><a href="#5216-统计元音字母序列的数目" class="headerlink" title="5216.统计元音字母序列的数目"></a>5216.统计元音字母序列的数目</h4><h5 id="解法1：map-1"><a href="#解法1：map-1" class="headerlink" title="解法1：map"></a>解法1：map</h5><p>map 存当前长度下以这种字母结尾的字符串个数</p>
<p>注意一个公式(a+b)%c=(a%c+b%c)%c;</p>
<p>最后找到长度为n的各字母结尾的字符串相加取余。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countVowelPermutation</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> res;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mod=(<span class="built_in">pow</span>(<span class="number">10</span>,<span class="number">9</span>)+<span class="number">7</span>);</span><br><span class="line">        map&lt;<span class="keyword">char</span>,<span class="keyword">long</span> <span class="keyword">long</span>&gt; m;</span><br><span class="line">        m[<span class="string">&#x27;a&#x27;</span>]=<span class="number">1</span>;</span><br><span class="line">        m[<span class="string">&#x27;e&#x27;</span>]=<span class="number">1</span>;</span><br><span class="line">        m[<span class="string">&#x27;i&#x27;</span>]=<span class="number">1</span>;</span><br><span class="line">        m[<span class="string">&#x27;o&#x27;</span>]=<span class="number">1</span>;</span><br><span class="line">        m[<span class="string">&#x27;u&#x27;</span>]=<span class="number">1</span>;</span><br><span class="line">        map&lt;<span class="keyword">char</span>,<span class="keyword">long</span> <span class="keyword">long</span>&gt; mnew;</span><br><span class="line">        <span class="keyword">while</span>(n--&gt;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            mnew[<span class="string">&#x27;a&#x27;</span>]=(m[<span class="string">&#x27;e&#x27;</span>]%mod+m[<span class="string">&#x27;i&#x27;</span>]%mod+m[<span class="string">&#x27;u&#x27;</span>]%mod)%mod;</span><br><span class="line">            mnew[<span class="string">&#x27;e&#x27;</span>]=(m[<span class="string">&#x27;a&#x27;</span>]%mod+m[<span class="string">&#x27;i&#x27;</span>]%mod)%mod;</span><br><span class="line">            mnew[<span class="string">&#x27;i&#x27;</span>]=(m[<span class="string">&#x27;e&#x27;</span>]%mod+m[<span class="string">&#x27;o&#x27;</span>]%mod)%mod;</span><br><span class="line">            mnew[<span class="string">&#x27;o&#x27;</span>]=m[<span class="string">&#x27;i&#x27;</span>]%mod;</span><br><span class="line">            mnew[<span class="string">&#x27;u&#x27;</span>]=(m[<span class="string">&#x27;o&#x27;</span>]%mod+m[<span class="string">&#x27;i&#x27;</span>]%mod)%mod;</span><br><span class="line">            m[<span class="string">&#x27;o&#x27;</span>]=mnew[<span class="string">&#x27;o&#x27;</span>];</span><br><span class="line">            m[<span class="string">&#x27;i&#x27;</span>]=mnew[<span class="string">&#x27;i&#x27;</span>];</span><br><span class="line">            m[<span class="string">&#x27;a&#x27;</span>]=mnew[<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            m[<span class="string">&#x27;e&#x27;</span>]=mnew[<span class="string">&#x27;e&#x27;</span>];</span><br><span class="line">            m[<span class="string">&#x27;u&#x27;</span>]=mnew[<span class="string">&#x27;u&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        res=(m[<span class="string">&#x27;a&#x27;</span>]%mod+m[<span class="string">&#x27;e&#x27;</span>]%mod+m[<span class="string">&#x27;i&#x27;</span>]%mod+m[<span class="string">&#x27;o&#x27;</span>]%mod+m[<span class="string">&#x27;u&#x27;</span>]%mod)%mod;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>周赛</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-第156场周赛</title>
    <url>/2019/10/04/leetcode/zhou-sai/di-156-chang-zhou-sai/</url>
    <content><![CDATA[<h4 id="5205-独一无二的出现次数"><a href="#5205-独一无二的出现次数" class="headerlink" title="5205.独一无二的出现次数"></a>5205.独一无二的出现次数</h4><p>给你一个整数数组 <code>arr</code>，请你帮忙统计数组中每个数的出现次数。</p>
<p>如果每个数的出现次数都是独一无二的，就返回 <code>true</code>；否则返回 <code>false</code>。</p>
 <span id="more"></span>

<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：arr = [1,2,2,1,1,3]</span><br><span class="line">输出：true</span><br><span class="line">解释：在该数组中，1 出现了 3 次，2 出现了 2 次，3 只出现了 1 次。没有两个数的出现次数相同。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：arr = [1,2]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：arr = [-3,0,1,-3,1,1,1,-3,10,0]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= arr.length &lt;= 1000</code></li>
<li><code>-1000 &lt;= arr[i] &lt;= 1000</code></li>
</ul>
<h5 id="解法1：map-set"><a href="#解法1：map-set" class="headerlink" title="解法1：map+set"></a>解法1：map+set</h5><p>map存各数出现的次数，set看次数有没有重复的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">uniqueOccurrences</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=arr.<span class="built_in">size</span>();</span><br><span class="line">        map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            m[arr[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::iterator ite=m.<span class="built_in">begin</span>();ite!=m.<span class="built_in">end</span>();ite++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(res[ite-&gt;second]!=<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            res[ite-&gt;second]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="5207-尽可能使字符串相等"><a href="#5207-尽可能使字符串相等" class="headerlink" title="5207.尽可能使字符串相等"></a>5207.尽可能使字符串相等</h4><p>给你两个长度相同的字符串，<code>s</code> 和 <code>t</code>。</p>
<p>将 <code>s</code> 中的第 <code>i</code> 个字符变到 <code>t</code> 中的第 <code>i</code> 个字符需要 <code>|s[i] - t[i]|</code> 的开销（开销可能为 0），也就是两个字符的 ASCII 码值的差的绝对值。</p>
<p>用于变更字符串的最大预算是 <code>maxCost</code>。在转化字符串时，总开销应当小于等于该预算，这也意味着字符串的转化可能是不完全的。</p>
<p>如果你可以将 <code>s</code> 的子字符串转化为它在 <code>t</code> 中对应的子字符串，则返回可以转化的最大长度。</p>
<p>如果 <code>s</code> 中没有子字符串可以转化成 <code>t</code> 中对应的子字符串，则返回 <code>0</code>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;abcd&quot;, t = &quot;bcdf&quot;, cost = 3</span><br><span class="line">输出：3</span><br><span class="line">解释：s 中的 &quot;abc&quot; 可以变为 &quot;bcd&quot;。开销为 3，所以最大长度为 3。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;abcd&quot;, t = &quot;cdef&quot;, cost = 3</span><br><span class="line">输出：1</span><br><span class="line">解释：s 中的任一字符要想变成 t 中对应的字符，其开销都是 2。因此，最大长度为 1。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;abcd&quot;, t = &quot;acde&quot;, cost = 0</span><br><span class="line">输出：1</span><br><span class="line">解释：你无法作出任何改动，所以最大长度为 1。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length, t.length &lt;= 10^5</code></li>
<li><code>0 &lt;= maxCost &lt;= 10^6</code></li>
<li><code>s</code> 和 <code>t</code> 都只含小写英文字母。</li>
</ul>
<h5 id="解法1：滑动窗口"><a href="#解法1：滑动窗口" class="headerlink" title="解法1：滑动窗口"></a>解法1：滑动窗口</h5><p>这题做的时候卡死在，单个开销大于总开销部分了，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">equalSubstring</span><span class="params">(string s, string t, <span class="keyword">int</span> maxCost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">nums</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="comment">//先用nums数组存下每个位置所需的开销</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)		</span><br><span class="line">        &#123;</span><br><span class="line">            nums[i]=<span class="built_in">abs</span>(s[i]-t[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//滑动窗口</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//当前总和+当前元素&lt;=最大开销</span></span><br><span class="line">            <span class="keyword">if</span>(sum+nums[i]&lt;=maxCost)</span><br><span class="line">            &#123;</span><br><span class="line">                sum+=nums[i];</span><br><span class="line">                res=<span class="built_in">max</span>(res,i-left+<span class="number">1</span>);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//一直循环到当前总和+当前元素&lt;=最大开销||或者当前窗口中没有元素！（一开始忘了这部分）</span></span><br><span class="line">               <span class="keyword">while</span>(sum+nums[i]&gt;maxCost&amp;&amp;left&lt;i)</span><br><span class="line">               &#123;</span><br><span class="line">                   sum-=nums[left];</span><br><span class="line">                   left++;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果当前窗口没有元素且当前元素大于最大开销向前移动一个位置</span></span><br><span class="line">            <span class="keyword">while</span>(i&lt;n&amp;&amp;nums[i]&gt;maxCost&amp;&amp;left==i)</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="5206-删除字符串中的所有相邻重复项-II"><a href="#5206-删除字符串中的所有相邻重复项-II" class="headerlink" title="5206.删除字符串中的所有相邻重复项 II"></a>5206.删除字符串中的所有相邻重复项 II</h4><p>给你一个字符串 <code>s</code>，「<code>k</code> 倍重复项删除操作」将会从 <code>s</code> 中选择 <code>k</code> 个相邻且相等的字母，并删除它们，使被删去的字符串的左侧和右侧连在一起。</p>
<p>你需要对 <code>s</code> 重复进行无限次这样的删除操作，直到无法继续为止。</p>
<p>在执行完所有删除操作后，返回最终得到的字符串。</p>
<p>本题答案保证唯一。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;abcd&quot;, k = 2</span><br><span class="line">输出：&quot;abcd&quot;</span><br><span class="line">解释：没有要删除的内容。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;deeedbbcccbdaa&quot;, k = 3</span><br><span class="line">输出：&quot;aa&quot;</span><br><span class="line">解释： </span><br><span class="line">先删除 &quot;eee&quot; 和 &quot;ccc&quot;，得到 &quot;ddbbbdaa&quot;</span><br><span class="line">再删除 &quot;bbb&quot;，得到 &quot;dddaa&quot;</span><br><span class="line">最后删除 &quot;ddd&quot;，得到 &quot;aa&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;pbbcggttciiippooaais&quot;, k = 2</span><br><span class="line">输出：&quot;ps&quot;</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 10^5</code></li>
<li><code>2 &lt;= k &lt;= 10^4</code></li>
<li><code>s</code> 中只含有小写英文字母。</li>
</ul>
<h5 id="解法1：栈"><a href="#解法1：栈" class="headerlink" title="解法1：栈"></a>解法1：栈</h5><p>理解好题意，理解好题意。一开始以为只能把正好连续为k个元素删除，正确要求是若连续k个元素相同就把这k个删除。</p>
<p>用栈，记录每个的字符和位于当前连续的第几个。</p>
<p>遍历完后出栈放入res中，颠倒res便得到了结果</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">string <span class="title">removeDuplicates</span><span class="params">(string s,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			stack&lt;pair&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;&gt; st;</span><br><span class="line">			<span class="keyword">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">			<span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(st.<span class="built_in">empty</span>()||s[i]==st.<span class="built_in">top</span>().first)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>(st.<span class="built_in">empty</span>())</span><br><span class="line">						temp=<span class="number">1</span>;</span><br><span class="line">					<span class="keyword">else</span> temp=st.<span class="built_in">top</span>().second+<span class="number">1</span>;</span><br><span class="line">					st.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(s[i],temp));</span><br><span class="line">                    <span class="keyword">if</span>(st.<span class="built_in">top</span>().second==k)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">int</span> j=st.<span class="built_in">top</span>().second;</span><br><span class="line">						<span class="keyword">while</span>(j--)</span><br><span class="line">						&#123;</span><br><span class="line">							st.<span class="built_in">pop</span>();</span><br><span class="line">						&#125;</span><br><span class="line">                    &#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">                    temp=<span class="number">1</span>;</span><br><span class="line">					st.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(s[i],temp));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			string res=<span class="string">&quot;&quot;</span>;</span><br><span class="line">			<span class="keyword">while</span>(!st.<span class="built_in">empty</span>())</span><br><span class="line">			&#123;</span><br><span class="line">				res+=st.<span class="built_in">top</span>().first;</span><br><span class="line">				st.<span class="built_in">pop</span>();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">			<span class="keyword">return</span> res;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="5208-穿过迷宫的最少移动次数"><a href="#5208-穿过迷宫的最少移动次数" class="headerlink" title="5208.穿过迷宫的最少移动次数"></a>5208.穿过迷宫的最少移动次数</h4><p>你还记得那条风靡全球的贪吃蛇吗？</p>
<p>我们在一个 <code>n*n</code> 的网格上构建了新的迷宫地图，蛇的长度为 2，也就是说它会占去两个单元格。蛇会从左上角（<code>(0, 0)</code> 和 <code>(0, 1)</code>）开始移动。我们用 <code>0</code> 表示空单元格，用 1 表示障碍物。蛇需要移动到迷宫的右下角（<code>(n-1, n-2)</code> 和 <code>(n-1, n-1)</code>）。</p>
<p>每次移动，蛇可以这样走：</p>
<ul>
<li>如果没有障碍，则向右移动一个单元格。并仍然保持身体的水平／竖直状态。</li>
<li>如果没有障碍，则向下移动一个单元格。并仍然保持身体的水平／竖直状态。</li>
<li>如果它处于水平状态并且其下面的两个单元都是空的，就顺时针旋转 90 度。蛇从（<code>(r, c)</code>、<code>(r, c+1)</code>）移动到 （<code>(r, c)</code>、<code>(r+1, c)</code>）。<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/28/image-2.png" alt="img"></li>
<li>如果它处于竖直状态并且其右面的两个单元都是空的，就逆时针旋转 90 度。蛇从（<code>(r, c)</code>、<code>(r+1, c)</code>）移动到（<code>(r, c)</code>、<code>(r, c+1)</code>）。<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/28/image-1.png" alt="img"></li>
</ul>
<p>返回蛇抵达目的地所需的最少移动次数。</p>
<p>如果无法到达目的地，请返回 <code>-1</code>。</p>
<p><strong>示例 1：</strong></p>
<p><strong><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/28/image.png" alt="img"></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [[0,0,0,0,0,1],</span><br><span class="line">               [1,1,0,0,1,0],</span><br><span class="line">               [0,0,0,0,1,1],</span><br><span class="line">               [0,0,1,0,1,0],</span><br><span class="line">               [0,1,1,0,0,0],</span><br><span class="line">               [0,1,1,0,0,0]]</span><br><span class="line">输出：11</span><br><span class="line">解释：</span><br><span class="line">一种可能的解决方案是 [右, 右, 顺时针旋转, 右, 下, 下, 下, 下, 逆时针旋转, 右, 下]。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [[0,0,1,1,1,1],</span><br><span class="line">               [0,0,0,0,1,1],</span><br><span class="line">               [1,1,0,0,0,1],</span><br><span class="line">               [1,1,1,0,0,1],</span><br><span class="line">               [1,1,1,0,0,1],</span><br><span class="line">               [1,1,1,0,0,0]]</span><br><span class="line">输出：9</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= n &lt;= 100</code></li>
<li><code>0 &lt;= grid[i][j] &lt;= 1</code></li>
<li>蛇保证从空单元格开始出发。</li>
</ul>
<h5 id="解法1：BFS"><a href="#解法1：BFS" class="headerlink" title="解法1：BFS"></a>解法1：BFS</h5><p>注意：这个蛇跟贪吃蛇的移动不太一样，仔细阅读题干。考虑各个情况采用BFS</p>
<p>三维数组记录走过的蛇头位置和当前横状态还是竖状态</p>
<p>二维数组记录当前蛇头和蛇尾位置。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumMoves</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">-1</span>;</span><br><span class="line">        vector&lt;vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&gt; <span class="built_in">ck</span>(<span class="number">2</span>,vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;(n,vector&lt;<span class="keyword">int</span>&gt;(n,<span class="literal">false</span>)));</span><br><span class="line">        ck[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">        queue&lt;vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&gt; q;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">qr</span>(<span class="number">2</span>,vector&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>,<span class="number">0</span>));</span><br><span class="line">        qr[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        q.<span class="built_in">push</span>(qr);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> size=q.<span class="built_in">size</span>();</span><br><span class="line">            ans++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">temp</span>(q.<span class="built_in">front</span>());</span><br><span class="line">                vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">qr</span>(<span class="number">2</span>,vector&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>,<span class="number">0</span>));</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">int</span> x1=temp[<span class="number">0</span>][<span class="number">0</span>],y1=temp[<span class="number">0</span>][<span class="number">1</span>],x2=temp[<span class="number">1</span>][<span class="number">0</span>],y2=temp[<span class="number">1</span>][<span class="number">1</span>];    <span class="comment">//(x1,y1)蛇尾 (x2,y2)蛇头</span></span><br><span class="line">                <span class="keyword">if</span>(x1==n<span class="number">-1</span>&amp;&amp;x2==n<span class="number">-1</span>&amp;&amp;y1==n<span class="number">-2</span>&amp;&amp;y2==n<span class="number">-1</span>)</span><br><span class="line">                    <span class="keyword">return</span> ans;</span><br><span class="line">                <span class="keyword">int</span> dir= x1==x2?<span class="number">0</span>:<span class="number">1</span>;        <span class="comment">//  竖1,横0</span></span><br><span class="line">                <span class="keyword">if</span>(!dir)            <span class="comment">//  横向状态</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(y2+<span class="number">1</span>&lt;n&amp;&amp;grid[x2][y2+<span class="number">1</span>]==<span class="number">0</span>&amp;&amp;!ck[dir][x2][y2+<span class="number">1</span>])  <span class="comment">//  右移</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        qr[<span class="number">0</span>][<span class="number">0</span>]=x1;qr[<span class="number">0</span>][<span class="number">1</span>]=y1+<span class="number">1</span>;qr[<span class="number">1</span>][<span class="number">0</span>]=x2;qr[<span class="number">1</span>][<span class="number">1</span>]=y2+<span class="number">1</span>;</span><br><span class="line">                        q.<span class="built_in">push</span>(qr);</span><br><span class="line">                        ck[dir][x2][y2+<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(x1+<span class="number">1</span>&lt;n&amp;&amp;grid[x1+<span class="number">1</span>][y1]==<span class="number">0</span>&amp;&amp;grid[x2+<span class="number">1</span>][y2]==<span class="number">0</span>&amp;&amp;!ck[dir][x2+<span class="number">1</span>][y2])     <span class="comment">//下移</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        qr[<span class="number">0</span>][<span class="number">0</span>]=x1+<span class="number">1</span>;qr[<span class="number">0</span>][<span class="number">1</span>]=y1;qr[<span class="number">1</span>][<span class="number">0</span>]=x2+<span class="number">1</span>;qr[<span class="number">1</span>][<span class="number">1</span>]=y2;</span><br><span class="line">                        q.<span class="built_in">push</span>(qr);</span><br><span class="line">                        ck[dir][x2+<span class="number">1</span>][y2]=<span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(x1+<span class="number">1</span>&lt;n&amp;&amp;grid[x1+<span class="number">1</span>][y1]==<span class="number">0</span>&amp;&amp;grid[x2+<span class="number">1</span>][y2]==<span class="number">0</span>&amp;&amp;!ck[<span class="number">1</span>-dir][x1+<span class="number">1</span>][y1])   <span class="comment">//顺时针90</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        qr[<span class="number">0</span>][<span class="number">0</span>]=x1;qr[<span class="number">0</span>][<span class="number">1</span>]=y1;qr[<span class="number">1</span>][<span class="number">0</span>]=x1+<span class="number">1</span>;qr[<span class="number">1</span>][<span class="number">1</span>]=y1;</span><br><span class="line">                        q.<span class="built_in">push</span>(qr);</span><br><span class="line">                        ck[<span class="number">1</span>-dir][x1+<span class="number">1</span>][y1]=<span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>                    <span class="comment">// 竖向状态</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(y1+<span class="number">1</span>&lt;n&amp;&amp;grid[x1][y1+<span class="number">1</span>]==<span class="number">0</span>&amp;&amp;grid[x2][y2+<span class="number">1</span>]==<span class="number">0</span>&amp;&amp;!ck[dir][x2][y2+<span class="number">1</span>])      <span class="comment">//右移</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        qr[<span class="number">0</span>][<span class="number">0</span>]=x1;qr[<span class="number">0</span>][<span class="number">1</span>]=y1+<span class="number">1</span>;qr[<span class="number">1</span>][<span class="number">0</span>]=x2;qr[<span class="number">1</span>][<span class="number">1</span>]=y2+<span class="number">1</span>;</span><br><span class="line">                        q.<span class="built_in">push</span>(qr);</span><br><span class="line">                        ck[dir][x2][y2+<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(x2+<span class="number">1</span>&lt;n&amp;&amp;grid[x2+<span class="number">1</span>][y2]==<span class="number">0</span>&amp;&amp;!ck[dir][x2+<span class="number">1</span>][y2])        <span class="comment">//下移</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        qr[<span class="number">0</span>][<span class="number">0</span>]=x1+<span class="number">1</span>;qr[<span class="number">0</span>][<span class="number">1</span>]=y1;qr[<span class="number">1</span>][<span class="number">0</span>]=x2+<span class="number">1</span>;qr[<span class="number">1</span>][<span class="number">1</span>]=y2;</span><br><span class="line">                        q.<span class="built_in">push</span>(qr);</span><br><span class="line">                        ck[dir][x2+<span class="number">1</span>][y2]=<span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(y1+<span class="number">1</span>&lt;n&amp;&amp;grid[x1][y1+<span class="number">1</span>]==<span class="number">0</span>&amp;&amp;grid[x2][y2+<span class="number">1</span>]==<span class="number">0</span>&amp;&amp;!ck[<span class="number">1</span>-dir][x1][y1+<span class="number">1</span>])      <span class="comment">//逆时针90</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        qr[<span class="number">0</span>][<span class="number">0</span>]=x1;qr[<span class="number">0</span>][<span class="number">1</span>]=y1;qr[<span class="number">1</span>][<span class="number">0</span>]=x1;qr[<span class="number">1</span>][<span class="number">1</span>]=y1+<span class="number">1</span>;</span><br><span class="line">                        q.<span class="built_in">push</span>(qr);</span><br><span class="line">                        ck[<span class="number">1</span>-dir][x1][y1+<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>周赛</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-第159场周赛</title>
    <url>/2019/10/27/leetcode/zhou-sai/di-159-chang-zhou-sai/</url>
    <content><![CDATA[<h4 id="1232-缀点成线"><a href="#1232-缀点成线" class="headerlink" title="1232. 缀点成线"></a><a href="https://leetcode-cn.com/problems/check-if-it-is-a-straight-line/">1232. 缀点成线</a></h4><h5 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h5><p>基本思路，判断每两点的斜率，注意斜率无穷大时的判断</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkStraightLine</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; coordinates)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> k;</span><br><span class="line">        <span class="keyword">if</span>((coordinates[<span class="number">1</span>][<span class="number">1</span>]-coordinates[<span class="number">0</span>][<span class="number">1</span>])==<span class="number">0</span>)</span><br><span class="line">            k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((coordinates[<span class="number">1</span>][<span class="number">0</span>]-coordinates[<span class="number">0</span>][<span class="number">0</span>])==<span class="number">0</span>)</span><br><span class="line">            k=INT_MAX;</span><br><span class="line">        <span class="keyword">else</span> k=(coordinates[<span class="number">1</span>][<span class="number">1</span>]-coordinates[<span class="number">0</span>][<span class="number">1</span>])/((coordinates[<span class="number">1</span>][<span class="number">0</span>]-coordinates[<span class="number">0</span>][<span class="number">0</span>])*<span class="number">1.0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> n=coordinates.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">double</span> k1;</span><br><span class="line">            <span class="keyword">if</span>((coordinates[i+<span class="number">1</span>][<span class="number">1</span>]-coordinates[i][<span class="number">1</span>])==<span class="number">0</span>)</span><br><span class="line">                k1=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((coordinates[i+<span class="number">1</span>][<span class="number">0</span>]-coordinates[i][<span class="number">0</span>])==<span class="number">0</span>)</span><br><span class="line">                k1=INT_MAX;</span><br><span class="line">            <span class="keyword">else</span> k1=(coordinates[i+<span class="number">1</span>][<span class="number">1</span>]-coordinates[i][<span class="number">1</span>])/((coordinates[i+<span class="number">1</span>][<span class="number">0</span>]-coordinates[i][<span class="number">0</span>])*<span class="number">1.0</span>);</span><br><span class="line">           </span><br><span class="line">            <span class="keyword">if</span>(k1!=k)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1233-删除子文件夹"><a href="#1233-删除子文件夹" class="headerlink" title="1233. 删除子文件夹"></a><a href="https://leetcode-cn.com/problems/remove-sub-folders-from-the-filesystem/">1233. 删除子文件夹</a></h4><h5 id="解法1：set"><a href="#解法1：set" class="headerlink" title="解法1：set"></a>解法1：set</h5><p>思路：</p>
<p>1.先将字符串排序，保证后面的若是子文件夹，在前面必然已经出现过他的父文件夹</p>
<p>2.遍历每个字符串，遇到‘/’就判断当前路径是否已经存在，若存在直接进行下一循环，若单个字符串到达最后也没有父文件夹，就将这个路径添加到set集合中作为父文件夹</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">removeSubfolders</span><span class="params">(vector&lt;string&gt;&amp; folder)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(folder.<span class="built_in">begin</span>(),folder.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> n=folder.<span class="built_in">size</span>();</span><br><span class="line">        set&lt;string&gt; s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            string temp=folder[i];</span><br><span class="line">            <span class="keyword">int</span> size=temp.<span class="built_in">size</span>();</span><br><span class="line">            string t=<span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;size;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(temp[j]==<span class="string">&#x27;/&#x27;</span>&amp;&amp;t!=<span class="string">&quot;&quot;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(s.<span class="built_in">find</span>(t)!=s.<span class="built_in">end</span>())</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                t+=temp[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">find</span>(t)==s.<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                s.<span class="built_in">insert</span>(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">res</span><span class="params">(s.begin(),s.end())</span></span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1234-替换子串得到平衡字符串"><a href="#1234-替换子串得到平衡字符串" class="headerlink" title="1234. 替换子串得到平衡字符串"></a><a href="https://leetcode-cn.com/problems/replace-the-substring-for-balanced-string/">1234. 替换子串得到平衡字符串</a></h4><h5 id="解法1：滑动窗口"><a href="#解法1：滑动窗口" class="headerlink" title="解法1：滑动窗口"></a>解法1：滑动窗口</h5><p>思路：</p>
<p>1.统计四个字符出现的次数</p>
<p>2.比较四个字符出现的次数和当前窗口内各字符出现次数</p>
<p>3.滑动窗口进行比较找到最短符合子串</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">balancedString</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> k=n/<span class="number">4</span>;</span><br><span class="line">        map&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; count;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            count[s[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        map&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; a;</span><br><span class="line">        <span class="keyword">int</span> res=n;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;n&amp;&amp;(count[<span class="string">&#x27;Q&#x27;</span>]-a[<span class="string">&#x27;Q&#x27;</span>]&gt;k||count[<span class="string">&#x27;W&#x27;</span>]-a[<span class="string">&#x27;W&#x27;</span>]&gt;k||count[<span class="string">&#x27;E&#x27;</span>]-a[<span class="string">&#x27;E&#x27;</span>]&gt;k||count[<span class="string">&#x27;R&#x27;</span>]-a[<span class="string">&#x27;R&#x27;</span>]&gt;k))</span><br><span class="line">            &#123;</span><br><span class="line">                a[s[j]]++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count[<span class="string">&#x27;Q&#x27;</span>]-a[<span class="string">&#x27;Q&#x27;</span>]&lt;=k&amp;&amp;count[<span class="string">&#x27;W&#x27;</span>]-a[<span class="string">&#x27;W&#x27;</span>]&lt;=k&amp;&amp;count[<span class="string">&#x27;E&#x27;</span>]-a[<span class="string">&#x27;E&#x27;</span>]&lt;=k&amp;&amp;count[<span class="string">&#x27;R&#x27;</span>]-a[<span class="string">&#x27;R&#x27;</span>]&lt;=k)</span><br><span class="line">                res=<span class="built_in">min</span>(res,j-i);</span><br><span class="line">            a[s[i]]--;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1235-规划兼职工作"><a href="#1235-规划兼职工作" class="headerlink" title="1235. 规划兼职工作"></a><a href="https://leetcode-cn.com/problems/maximum-profit-in-job-scheduling/">1235. 规划兼职工作</a></h4><h5 id="解法1：动态规划"><a href="#解法1：动态规划" class="headerlink" title="解法1：动态规划"></a>解法1：动态规划</h5><p>动态规划。在开始计算之前，先把题目给出的数据整理一下。将 [startTime[i], endTime[i], profit[i]] 整理为数组，并按 startTime[i] - endTime[i] - profit[i]] 排序。</p>
<p>用 dp[i] 表示完成第 i 份工作所能获得的最大收益。假设有第 x 份工作（x &lt; i）：</p>
<p>如果 x 与 i 时间上不重合，表示即可完成工作 x 又可以完成工作 i，那么有：dp[i] = max(dp[i], dp[x] + profit[i])<br>如果 x 与 i 在时间上重合了，那么将无法完成工作 x<br>由此可见，dp[i] 的值取决于在它前面所有与之时间不重合的工作收益，即：</p>
<p>dp[i] = max(dp[0], dp[1], …, dp[j]) + profit[i] （<code>j</code> 为 <code>i</code> 之前最后一个与之时间区域不重合的工作）<br>但是，如果每次都遍历 0 ~ j 必然会超时，所以需要记录下时间区域不重合的工作所在的最大位置。</p>
<p>作者：jalan<br>链接：<a href="https://leetcode-cn.com/problems/maximum-profit-in-job-scheduling/solution/python-dong-tai-gui-hua-xiang-jie-by-jalan-2/">https://leetcode-cn.com/problems/maximum-profit-in-job-scheduling/solution/python-dong-tai-gui-hua-xiang-jie-by-jalan-2/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jobScheduling</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; startTime, vector&lt;<span class="keyword">int</span>&gt;&amp; endTime, vector&lt;<span class="keyword">int</span>&gt;&amp; profit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=startTime.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">time</span>(n,vector&lt;<span class="keyword">int</span>&gt;(<span class="number">3</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            time[i][<span class="number">0</span>]=startTime[i];</span><br><span class="line">            time[i][<span class="number">1</span>]=endTime[i];</span><br><span class="line">            time[i][<span class="number">2</span>]=profit[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(time.<span class="built_in">begin</span>(),time.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> s=<span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> p=<span class="number">0</span>;<span class="comment">//标记位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=p;j&lt;i;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(time[i][<span class="number">0</span>]&gt;=time[j][<span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//如果当前i任务开始时间比j任务结束时间晚，则i+1的开始时间必然也比j任务的结束时间晚移动 pos 的位置</span></span><br><span class="line">                    <span class="keyword">if</span>(j==p)</span><br><span class="line">                        p++;</span><br><span class="line">                    s=<span class="built_in">max</span>(s,dp[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i]=s+time[i][<span class="number">2</span>];</span><br><span class="line">            res=<span class="built_in">max</span>(res,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>周赛</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-第158场周赛</title>
    <url>/2019/10/17/leetcode/zhou-sai/di-158-chang-zhou-sai/</url>
    <content><![CDATA[<h4 id="1221-分割平衡字符串"><a href="#1221-分割平衡字符串" class="headerlink" title="1221. 分割平衡字符串"></a><a href="https://leetcode-cn.com/problems/split-a-string-in-balanced-strings/">1221. 分割平衡字符串</a></h4><h5 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h5><p>遍历一遍，记录R，L,R==L时同时清零且res++</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">balancedStringSplit</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;R&#x27;</span>)</span><br><span class="line">                r++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">                l++;</span><br><span class="line">            <span class="keyword">if</span>(r==l)</span><br><span class="line">            &#123;</span><br><span class="line">                res++;</span><br><span class="line">                r=<span class="number">0</span>;</span><br><span class="line">                l=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1222-可以攻击国王的皇后"><a href="#1222-可以攻击国王的皇后" class="headerlink" title="1222. 可以攻击国王的皇后"></a><a href="https://leetcode-cn.com/problems/queens-that-can-attack-the-king/">1222. 可以攻击国王的皇后</a></h4><h5 id="解法1：DFS"><a href="#解法1：DFS" class="headerlink" title="解法1：DFS"></a>解法1：DFS</h5><p>思路：</p>
<p>从国王出发，最多有8个皇后能攻击到国王，建立方向数组，8个方向都从国王走一遍，</p>
<p>1.遇到皇后记录位置且进行下一方向，</p>
<p>2.遇到边界进行下一方向</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">queensAttacktheKing</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; queens, vector&lt;<span class="keyword">int</span>&gt;&amp; king) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">used</span>(<span class="number">8</span>,vector&lt;<span class="keyword">bool</span>&gt;(<span class="number">8</span>,<span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">int</span> dir[<span class="number">8</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;queens.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            used[queens[i][<span class="number">0</span>]][queens[i][<span class="number">1</span>]]=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">8</span>;k++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x=king[<span class="number">0</span>],y=king[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span>(x+dir[k][<span class="number">0</span>]&gt;=<span class="number">0</span>&amp;&amp;x+dir[k][<span class="number">0</span>]&lt;<span class="number">8</span>&amp;&amp;y+dir[k][<span class="number">1</span>]&gt;=<span class="number">0</span>&amp;&amp;y+dir[k][<span class="number">1</span>]&lt;<span class="number">8</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                x+=dir[k][<span class="number">0</span>];</span><br><span class="line">                y+=dir[k][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(used[x][y])</span><br><span class="line">                &#123;</span><br><span class="line">                    vector&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">                    temp.<span class="built_in">push_back</span>(x);</span><br><span class="line">                    temp.<span class="built_in">push_back</span>(y);</span><br><span class="line">                    res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1223-掷骰子模拟"><a href="#1223-掷骰子模拟" class="headerlink" title="1223. 掷骰子模拟"></a><a href="https://leetcode-cn.com/problems/dice-roll-simulation/">1223. 掷骰子模拟</a></h4><h5 id="解法1：动态规划"><a href="#解法1：动态规划" class="headerlink" title="解法1：动态规划"></a>解法1：动态规划</h5><p>思路：采用动态规划策略</p>
<p>1.dp[n][i][l]表示掷第n次数字i-1连续出现l次能组成的最多序列数</p>
<p>2.状态转移方程</p>
<p>​    （1）如果当前数字j与上一数字k相同，对全部符合的l来说：dp[i][j][l+1]=dp[i-1][k][l];即数字j连续出现，当前情况数量等于上一轮连续掷出i-1次j的情况数量</p>
<p>​    （2）如果不相等,对全部符合的l来说：dp[i][j][1]+=dp[i-1][k][l];即数字j并非连续出现，等于上一轮掷出非数字j的所有情况和</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dieSimulator</span><span class="params">(<span class="keyword">int</span> n, vector&lt;<span class="keyword">int</span>&gt;&amp; rollMax)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dp[n+<span class="number">1</span>][<span class="number">6</span>][<span class="number">20</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">        <span class="keyword">int</span> mod=<span class="built_in">pow</span>(<span class="number">10</span>,<span class="number">9</span>)+<span class="number">7</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[<span class="number">1</span>][i][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">6</span>;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">6</span>;k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(k!=j)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>;l&lt;=rollMax[k];l++)</span><br><span class="line">                        &#123;</span><br><span class="line">                            dp[i][j][<span class="number">1</span>]+=dp[i<span class="number">-1</span>][k][l];</span><br><span class="line">                            dp[i][j][<span class="number">1</span>]%=mod;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>;l&lt;rollMax[k];l++)</span><br><span class="line">                        &#123;</span><br><span class="line">                            dp[i][j][l+<span class="number">1</span>]=dp[i<span class="number">-1</span>][k][l];</span><br><span class="line">                            dp[i][j][l+<span class="number">1</span>]%=mod;</span><br><span class="line">                        &#125;                            </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">6</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>;l&lt;=rollMax[j];l++)</span><br><span class="line">            &#123;</span><br><span class="line">                res+=dp[n][j][l];</span><br><span class="line">                res%=mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1224-最大相等频率"><a href="#1224-最大相等频率" class="headerlink" title="1224. 最大相等频率"></a><a href="https://leetcode-cn.com/problems/maximum-equal-frequency/">1224. 最大相等频率</a></h4><h5 id="解法1：map，考虑4种情况"><a href="#解法1：map，考虑4种情况" class="headerlink" title="解法1：map，考虑4种情况"></a>解法1：map，考虑4种情况</h5><p>问题分析：能够满足答案的条件</p>
<p>1.只有一种数字。 如：1 1 1 1 1</p>
<p>2.有多种数字，每个数字只出现1次。如： 1 2 3 4 5 </p>
<p>3.有多种数字，其中一种数字出现n+1次，其他出现n次。如：1 1 1 2 2 2 3 3 3 4 4 4 4</p>
<p>4.有多种数字，其中一种数字出现1次，其他出现n次。如：1 2 2 2 3 3 3 4 4 4</p>
<p>建立两个数字count和f_count，count用来统计当前各个数字出现的次数，f_count[i]用来统计频率为i的数字个数。</p>
<p>因此成立的条件为，f_count[1]==n||最高频次==1||(f_count[最高频次]==1&amp;&amp;f_count[最高频次-1]==n-1)||f_count[最高频次]==(n-1)&amp;&amp;f_count[1]==1)</p>
<p>因此，需要两个变量,n表示有多少种数字，f_max表示最高频次为多少</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxEqualFreq</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count[<span class="number">100005</span>],f_count[<span class="number">100005</span>];</span><br><span class="line">        <span class="built_in">memset</span>(count,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(count));</span><br><span class="line">        <span class="built_in">memset</span>(f_count,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(f_count));</span><br><span class="line">        <span class="keyword">int</span> n=<span class="number">0</span>,f_max=<span class="number">0</span>,res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> num=nums[i];</span><br><span class="line">            <span class="keyword">if</span>(count[num]==<span class="number">0</span>)</span><br><span class="line">                n++;</span><br><span class="line">            count[num]++;</span><br><span class="line">            <span class="keyword">if</span>(count[num])</span><br><span class="line">                f_count[count[num]<span class="number">-1</span>]--;</span><br><span class="line">            f_count[count[num]]++;</span><br><span class="line">            f_max=<span class="built_in">max</span>(f_max,count[num]);</span><br><span class="line">            <span class="keyword">if</span>(f_count[<span class="number">1</span>]==n||f_max==<span class="number">1</span>||f_count[f_max]==<span class="number">1</span>&amp;&amp;f_count[f_max<span class="number">-1</span>]==n<span class="number">-1</span>||f_count[f_max]==n<span class="number">-1</span>&amp;&amp;f_count[<span class="number">1</span>]==<span class="number">1</span>)</span><br><span class="line">                res=i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>周赛</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-第160场周赛</title>
    <url>/2019/11/03/leetcode/zhou-sai/di-160-chang-zhou-sai/</url>
    <content><![CDATA[<h4 id="1237-找出给定方程的正整数解"><a href="#1237-找出给定方程的正整数解" class="headerlink" title="1237. 找出给定方程的正整数解"></a><a href="https://leetcode-cn.com/problems/find-positive-integer-solution-for-a-given-equation/">1237. 找出给定方程的正整数解</a></h4><h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><p>签到题的全新版本。</p>
<p>直接暴力遍历就行了，明白这是个在写一个函数接口。</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * // This is the custom function interface.</span></span><br><span class="line"><span class="comment"> * // You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="comment"> * class CustomFunction &#123;</span></span><br><span class="line"><span class="comment"> * public:</span></span><br><span class="line"><span class="comment"> *     // Returns f(x, y) for any given positive integers x and y.</span></span><br><span class="line"><span class="comment"> *     // Note that f(x, y) is increasing with respect to both x and y.</span></span><br><span class="line"><span class="comment"> *     // i.e. f(x, y) &lt; f(x + 1, y), f(x, y) &lt; f(x, y + 1)</span></span><br><span class="line"><span class="comment"> *     int f(int x, int y);</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">findSolution</span>(CustomFunction&amp; customfunction, <span class="keyword">int</span> z) &#123;</span><br><span class="line">        <span class="keyword">int</span> x=<span class="number">1</span>,y=<span class="number">1</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">1000</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">1000</span>;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(customfunction.<span class="built_in">f</span>(i,j)==z)</span><br><span class="line">                &#123;</span><br><span class="line">                    vector&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">                    temp.<span class="built_in">push_back</span>(i);</span><br><span class="line">                    temp.<span class="built_in">push_back</span>(j);</span><br><span class="line">                    res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1238-循环码排列"><a href="#1238-循环码排列" class="headerlink" title="1238. 循环码排列"></a><a href="https://leetcode-cn.com/problems/circular-permutation-in-binary-representation/">1238. 循环码排列</a></h4><h5 id="解法：位运算"><a href="#解法：位运算" class="headerlink" title="解法：位运算"></a>解法：位运算</h5><p>思路：采用位运算，其实这题就是格雷编码的改编，可以看第89题，明白格雷编码的实现，这题也就容易了。</p>
<p>以 2 3 1 0 4 5 7 6 为例 进行分析，转换成二进制得</p>
<p>0 1 0</p>
<p>0 1 1</p>
<p>0 0 1 </p>
<p>0 0 0</p>
<p>1 0 0</p>
<p>1 0 1</p>
<p>1 1 1</p>
<p>1 1 0</p>
<p>分析发现，一开始对第1个进行镜像反射，改变最右边一位数，其他不变，便得到了第二位数</p>
<p>然后对1，2进行镜像反射，改变从右起第二位数，其他不变，便得到了3，4数</p>
<p>依次类推，便可得到题目要求的循环码排列</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">circularPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(<span class="number">1</span>&lt;&lt;n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        res[<span class="number">0</span>]=start;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> k=<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;k;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                res[(k&lt;&lt;<span class="number">1</span>)<span class="number">-1</span>-j]=res[j]^k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1239-串联字符串的最大长度"><a href="#1239-串联字符串的最大长度" class="headerlink" title="1239. 串联字符串的最大长度"></a><a href="https://leetcode-cn.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters/">1239. 串联字符串的最大长度</a></h4><h5 id="解法：位压缩"><a href="#解法：位压缩" class="headerlink" title="解法：位压缩"></a>解法：位压缩</h5><p>思路：</p>
<p>1.先对字符串进行排序，从大到小，然后将每个字符串都压缩成一个整数进行保存，用32位整数的每一位代表一个字母，例如1表示a，10表示b，100表示c。（1，10，100是二进制表示）。且在保存过程中，若发现一个字符串中存在重复字符则对该字符串直接舍弃。且每次判断符合要求的单个字符串的最大长度保存res。</p>
<p>2.用s来存当前整数，与想要串联的字符串进行&amp;运算若为0可串联，否则查找下一个字符串。找到最大的res。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxLength</span><span class="params">(vector&lt;string&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">temp</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(),arr.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">reverse</span>(arr.<span class="built_in">begin</span>(),arr.<span class="built_in">end</span>());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            string str=arr[i];</span><br><span class="line">            <span class="keyword">int</span> size=str.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;size;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(temp[i]&amp;(<span class="number">1</span>&lt;&lt;(str[j]-<span class="string">&#x27;a&#x27;</span>)))</span><br><span class="line">                &#123;</span><br><span class="line">                    temp[i]=INT_MAX;</span><br><span class="line">                    arr[i]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                temp[i]=temp[i]|(<span class="number">1</span>&lt;&lt;(str[j]-<span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//cout&lt;&lt;arr[i]&lt;&lt;&quot; &quot;;</span></span><br><span class="line">            <span class="keyword">if</span>(temp[i]!=INT_MAX)</span><br><span class="line">            &#123;</span><br><span class="line">                res=<span class="built_in">max</span>(res,size);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(temp[i]==INT_MAX)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> s=temp[i];</span><br><span class="line">            <span class="keyword">int</span> k1=arr[i].<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(temp[j]==INT_MAX)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>((s&amp;temp[j])==<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    s=s|temp[j];</span><br><span class="line">                    k1=k1+arr[j].<span class="built_in">size</span>();</span><br><span class="line">                    res=<span class="built_in">max</span>(res,k1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1240-铺瓷砖"><a href="#1240-铺瓷砖" class="headerlink" title="1240. 铺瓷砖"></a><a href="https://leetcode-cn.com/problems/tiling-a-rectangle-with-the-fewest-squares/">1240. 铺瓷砖</a></h4><p>此题参考<strong>小白二号</strong>，全靠二哥的讲解，才明白这题</p>
<h5 id="解法1：打表"><a href="#解法1：打表" class="headerlink" title="解法1：打表"></a>解法1：打表</h5><p>没啥好说的。面向测设用例编程=_=！</p>
<h5 id="解法2：回溯"><a href="#解法2：回溯" class="headerlink" title="解法2：回溯"></a>解法2：回溯</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//ret表示当前最小瓷砖数，如果搜索的过程中，瓷砖数比这个数还大，就不用接着搜索了，这是这份代码中唯一的剪枝</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//data表示当前瓷砖铺的情况，总共有n*m个bit，这里把每一行的bit压缩成一个int了，节省空间</span></span><br><span class="line">    <span class="comment">//x表示当前位置的横坐标</span></span><br><span class="line">    <span class="comment">//y表示当前位置的纵坐标</span></span><br><span class="line">    <span class="comment">//now表示当前的瓷砖数</span></span><br><span class="line">    <span class="comment">//n和m就是题目的n和m，因为后面判断需要用到，这里把这俩货也传进来了</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对于dfs来说，状态变量其实只有data，其他变量都是辅助</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; data, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> now, <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当行坐标到了n，说明搜索已经结束了，可以保存结果</span></span><br><span class="line">        <span class="keyword">if</span> (x == n) &#123;</span><br><span class="line">            ret = <span class="built_in">min</span>(ret, now);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当纵坐标到了m，说明来到了一行的末尾，直接换下一行的行首继续搜</span></span><br><span class="line">        <span class="keyword">if</span> (y == m) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(data, x + <span class="number">1</span>, <span class="number">0</span>, now, n, m);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果当前瓷砖数比搜索过的最小瓷砖数还大，直接跳出，这是唯一的剪枝</span></span><br><span class="line">        <span class="keyword">if</span> (now &gt;= ret) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果坐标(x,y)已经被贴了瓷砖，搜索下一个</span></span><br><span class="line">        <span class="keyword">if</span> (data[x] &amp; (<span class="number">1</span> &lt;&lt; y)) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(data, x, y + <span class="number">1</span>, now, n, m);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//k表示坐标(x,y)最大可放的瓷砖，如果放下去超过n*m的范围，就不能放了</span></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;x + i - <span class="number">1</span> &lt; n &amp;&amp; y + i - <span class="number">1</span> &lt; m;i++) &#123;</span><br><span class="line">            k = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//为啥要从最大可放的瓷砖开始搜呢，因为瓷砖越大，最后的瓷砖数会极有可能越少，这样跟剪枝代码结合起来，可以多剪一点</span></span><br><span class="line">        <span class="keyword">while</span> (k &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//flag表示是否可以放k\*k的操作，这里应该可以跟上面的循环合并。如果k\*k中正好某个位置已经被贴瓷砖了，就不能放了</span></span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k;i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; k;j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (data[x + i] &amp; (<span class="number">1</span> &lt;&lt; (y + j))) &#123;</span><br><span class="line">                        flag = <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//flag为true表示可以放，既然可以放，就放呗</span></span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                <span class="comment">//贴瓷砖的过程</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k;i++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; k;j++) &#123;</span><br><span class="line">                        data[x + i] += (<span class="number">1</span> &lt;&lt; (y + j));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//继续搜下一个位置</span></span><br><span class="line">                <span class="built_in">dfs</span>(data, x, y + <span class="number">1</span>, now + <span class="number">1</span>, n, m);</span><br><span class="line">                <span class="comment">//回溯的本质，如果搜索完，必须还原现场</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k;i++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; k;j++) &#123;</span><br><span class="line">                        data[x + i] -= (<span class="number">1</span> &lt;&lt; (y + j));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">tilingRectangle</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">data</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        ret = n * m;</span><br><span class="line">        <span class="built_in">dfs</span>(data, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, n, m);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*作者：小白二号</span></span><br><span class="line"><span class="comment">链接：https://leetcode-cn.com/circle/discuss/LPwegn/view/XeRE60/</span></span><br><span class="line"><span class="comment">来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。*/</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>周赛</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-第161场周赛</title>
    <url>/2021/10/26/leetcode/zhou-sai/di-161-chang-zhou-sai/</url>
    <content><![CDATA[<h4 id="1247-交换字符使得字符串相同"><a href="#1247-交换字符使得字符串相同" class="headerlink" title="1247. 交换字符使得字符串相同"></a><a href="https://leetcode-cn.com/problems/minimum-swaps-to-make-strings-equal/">1247. 交换字符使得字符串相同</a></h4><h5 id="解法：数学"><a href="#解法：数学" class="headerlink" title="解法：数学"></a>解法：数学</h5><p>签到题变成了数学题，写了20分钟。。</p>
<span id="more"></span>

<p>思路：</p>
<p>1.记录两个字符串总共的x和y字符，若出现奇数次直接返回-1</p>
<p>2.记录两个字符串对应位置不相同时，s1出现x的次数和出现y的次数，若x为奇次，交换次数为(x+y)/2+1;</p>
<p>若x为偶数交换次数为(x+y)/2;</p>
<p>原因:</p>
<p>例1：</p>
<p>s1=x y y x</p>
<p>s2=y x x y</p>
<p>交换 s1[1]和s2[2] ,s1[0]和s2[3]</p>
<p>得到y x y x</p>
<p>​    y x y x</p>
<p>例2:</p>
<p>s1=x y x y x y</p>
<p>s2=y x y x y x</p>
<p> -交换s1[0]和s2[2] ,s1[1]和s2[3] ,s1[4]和s2[4] 然后交换s1[4]和s2[5] </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumSwap</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=s1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> x=<span class="number">0</span>,y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> x1=<span class="number">0</span>,y1=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s1[i]!=s2[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s1[i]==<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">                    x++;</span><br><span class="line">                <span class="keyword">else</span> y++;</span><br><span class="line">                x1++;y1++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s1[i]==<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">                    x1+=<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span> y1+=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x1%<span class="number">2</span>||y1%<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(x%<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res=(x+y)/<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> res=(x+y)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1248-统计「优美子数组」"><a href="#1248-统计「优美子数组」" class="headerlink" title="1248. 统计「优美子数组」"></a><a href="https://leetcode-cn.com/problems/count-number-of-nice-subarrays/">1248. 统计「优美子数组」</a></h4><h5 id="解法1：滑动窗口"><a href="#解法1：滑动窗口" class="headerlink" title="解法1：滑动窗口"></a>解法1：滑动窗口</h5><p>思路：</p>
<p>1.记录每一个奇数在数组中的位置</p>
<p>2.遍历这个奇数所在位置数组v，从0到v.size()-k+1进行遍历，记录i,j=i+k-1即正好包含k个奇数的最小子数组的左右边界，然后通过i位置找到与前一奇数（或头部）所在位置中间的距离*j位置与后一奇数（或尾部）所在位置中间的距离，便得到了窗口在这个左右边界时能组成的优美子数组。将所有情况累加得到res</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfSubarrays</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]%<span class="number">2</span>)</span><br><span class="line">                v.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(v.<span class="built_in">size</span>()&lt;k)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> size=v.<span class="built_in">size</span>(),res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size-k+<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=i+k<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">int</span> l=i==<span class="number">0</span>?v[i]+<span class="number">1</span>:v[i]-v[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">int</span> r=j==(size<span class="number">-1</span>)?(n-v[j]):(v[j+<span class="number">1</span>]-v[j]);</span><br><span class="line">            res+=l*r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="解法2：前缀数组"><a href="#解法2：前缀数组" class="headerlink" title="解法2：前缀数组"></a>解法2：前缀数组</h5><p>参考二哥的思路</p>
<p>思路：前缀和，把数组中所有奇数都变成 1，所有偶数变成 0，于是原数组中区间中奇数的个数就等于变换后数组中区间和用一个 map 统计前缀和等于 s 的个数，就可以统计区间和等于 k 的个数了。</p>
<p>sum[s]表示第s个奇数与第s+1个奇数间的距离</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfSubarrays</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">        map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; sum;</span><br><span class="line">        sum[s] ++;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                s++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s - k &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                ret += sum[s - k];</span><br><span class="line">            &#125;</span><br><span class="line">            sum[s]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1249-移除无效的括号"><a href="#1249-移除无效的括号" class="headerlink" title="1249. 移除无效的括号"></a><a href="https://leetcode-cn.com/problems/minimum-remove-to-make-valid-parentheses/">1249. 移除无效的括号</a></h4><h5 id="解法：栈"><a href="#解法：栈" class="headerlink" title="解法：栈"></a>解法：栈</h5><p>思路：</p>
<p>创建bool used数组，记录字符串中那些位置括号应删掉</p>
<p>1.用栈记录所有的右括号位置，扫描字符串，遇到’(‘,’)’时判断</p>
<p>1）若遇到’(‘将该位置添加进栈</p>
<p>2)若遇到’)’</p>
<ul>
<li><pre><code> 若栈空，将该位置used[i]=true
</code></pre>
</li>
<li>​       若栈不空，将栈顶元素出栈</li>
</ul>
<p>2.扫描完毕，将栈中剩余元素对应的used值都设为true</p>
<p>3.再次扫描字符串，将对应used位置的字符都跳过即得到了目标字符串</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minRemoveToMakeValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">used</span><span class="params">(n,<span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!st.<span class="built_in">empty</span>())</span><br><span class="line">                    st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">else</span> used[i]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            used[st.<span class="built_in">top</span>()]=<span class="literal">true</span>;</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        string res=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(used[i])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            res+=s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1250-检查「好数组」"><a href="#1250-检查「好数组」" class="headerlink" title="1250. 检查「好数组」"></a><a href="https://leetcode-cn.com/problems/check-if-it-is-a-good-array/">1250. 检查「好数组」</a></h4><h5 id="解法：数学-1"><a href="#解法：数学-1" class="headerlink" title="解法：数学"></a>解法：数学</h5><p>又是数学题。。经过二哥指点明白了，若数组的最大公因子为1，则为true，否则为false</p>
<p>定理链接：<a href="https://baike.baidu.com/item/%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86/5186593">裴蜀定理</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isGoodArray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> g=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            g=<span class="built_in">gcd</span>(g,nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> g==<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a&lt;b) <span class="keyword">return</span> <span class="built_in">gcd</span>(b,a);</span><br><span class="line">        <span class="keyword">int</span> r;</span><br><span class="line">        <span class="keyword">while</span>(b)</span><br><span class="line">        &#123;</span><br><span class="line">            r=a%b;</span><br><span class="line">            a=b;</span><br><span class="line">            b=r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>周赛</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-第162场周赛</title>
    <url>/2021/10/26/leetcode/zhou-sai/di-162-chang-zhou-sai/</url>
    <content><![CDATA[<h4 id="1252-奇数值单元格的数目"><a href="#1252-奇数值单元格的数目" class="headerlink" title="1252. 奇数值单元格的数目"></a><a href="https://leetcode-cn.com/problems/cells-with-odd-values-in-a-matrix/">1252. 奇数值单元格的数目</a></h4><h5 id="解法1：暴力模拟"><a href="#解法1：暴力模拟" class="headerlink" title="解法1：暴力模拟"></a>解法1：暴力模拟</h5><p>暴力模拟，遍历将奇数找出来</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">oddCells</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; indices)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">v</span>(n,vector&lt;<span class="keyword">int</span>&gt;(m,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">int</span> size=indices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x=indices[i][<span class="number">0</span>],y=indices[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                v[x][j]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                v[j][y]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(v[i][j]%<span class="number">2</span>)</span><br><span class="line">                    res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1253-重构-2-行二进制矩阵"><a href="#1253-重构-2-行二进制矩阵" class="headerlink" title="1253. 重构 2 行二进制矩阵"></a><a href="https://leetcode-cn.com/problems/reconstruct-a-2-row-binary-matrix/">1253. 重构 2 行二进制矩阵</a></h4><h5 id="解法1：模拟存放"><a href="#解法1：模拟存放" class="headerlink" title="解法1：模拟存放"></a>解法1：模拟存放</h5><p>1.判断upper+lower是否等于colsum总和</p>
<p>2.如果colsum[i]=2将结果数组对应该列都赋值为1</p>
<p>3.先将第一行按要求填充，剩下的填第二行</p>
<p>4.判断各行对应总和是否符合要求</p>
<p>5.返回对应结果</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">reconstructMatrix</span>(<span class="keyword">int</span> upper, <span class="keyword">int</span> lower, vector&lt;<span class="keyword">int</span>&gt;&amp; colsum) &#123;</span><br><span class="line">        <span class="keyword">int</span> size=colsum.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">res</span>(<span class="number">2</span>,vector&lt;<span class="keyword">int</span>&gt;(size,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            temp+=colsum[i];</span><br><span class="line">            <span class="keyword">if</span>(colsum[i]==<span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res[<span class="number">0</span>][i]=<span class="number">1</span>;res[<span class="number">1</span>][i]=<span class="number">1</span>;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(colsum[i]==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(k&lt;upper)</span><br><span class="line">                &#123;    </span><br><span class="line">                    res[<span class="number">0</span>][i]=<span class="number">1</span>;</span><br><span class="line">                    k++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> res[<span class="number">1</span>][i]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res1;</span><br><span class="line">        <span class="keyword">int</span> u=<span class="number">0</span>,l=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            u+=res[<span class="number">0</span>][i];l+=res[<span class="number">1</span>][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u!=upper||l!=lower)</span><br><span class="line">            <span class="keyword">return</span> res1;</span><br><span class="line">        <span class="keyword">if</span>(temp!=(upper+lower))</span><br><span class="line">            <span class="keyword">return</span> res1;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1254-统计封闭岛屿的数目"><a href="#1254-统计封闭岛屿的数目" class="headerlink" title="1254. 统计封闭岛屿的数目"></a><a href="https://leetcode-cn.com/problems/number-of-closed-islands/">1254. 统计封闭岛屿的数目</a></h4><h5 id="解法1：BFS"><a href="#解法1：BFS" class="headerlink" title="解法1：BFS"></a>解法1：BFS</h5><p>1.遍历不在边缘位置的0，从这一位置开始BFS。</p>
<p>2.BFS过程中将走过的点都标记下</p>
<p>3.BFS中若遇到触碰到边缘表示这个区域不是一个封闭岛屿，返回值置为0，否则为1</p>
<p>4.将封闭岛屿累计，得到返回值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; grid_d;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">closedIsland</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        n=grid.<span class="built_in">size</span>(),m=grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">this</span>-&gt;grid_d=grid;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">used</span>(n,vector&lt;<span class="keyword">bool</span>&gt;(m,<span class="literal">false</span>));</span><br><span class="line">        <span class="comment">/*for(int i=0;i&lt;n;i++)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            for(int j=0;j&lt;m;j++)</span></span><br><span class="line"><span class="comment">                cout&lt;&lt;grid[i][j]&lt;&lt;&quot; &quot;;</span></span><br><span class="line"><span class="comment">            cout&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;m<span class="number">-1</span>;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]!=<span class="number">1</span>&amp;&amp;!used[i][j])</span><br><span class="line">                &#123;</span><br><span class="line">                    used[i][j]=<span class="literal">true</span>;</span><br><span class="line">                    res+=<span class="built_in">bfs</span>(i,j,used);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt;&amp; used)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        queue&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(i,j));</span><br><span class="line">        <span class="keyword">int</span> ret=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> size=que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;size;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; q=que.<span class="built_in">front</span>();que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">int</span> x=q.first,y=q.second;</span><br><span class="line">               <span class="comment">// cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;endl;</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> d=<span class="number">0</span>;d&lt;<span class="number">4</span>;d++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(x+dir[d][<span class="number">0</span>]&gt;=<span class="number">0</span>&amp;&amp;x+dir[d][<span class="number">0</span>]&lt;n&amp;&amp;y+dir[d][<span class="number">1</span>]&gt;=<span class="number">0</span>&amp;&amp;y+dir[d][<span class="number">1</span>]&lt;m&amp;&amp;grid_d[x+dir[d][<span class="number">0</span>]][y+dir[d][<span class="number">1</span>]]!=<span class="number">1</span>&amp;&amp;!used[x+dir[d][<span class="number">0</span>]][y+dir[d][<span class="number">1</span>]])</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">int</span> newx=x+dir[d][<span class="number">0</span>],newy=y+dir[d][<span class="number">1</span>];</span><br><span class="line">                        used[newx][newy]=<span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">if</span>((newx==<span class="number">0</span>||newx==n<span class="number">-1</span>||newy==<span class="number">0</span>||newy==m<span class="number">-1</span>)&amp;&amp;grid_d[newx][newy]==<span class="number">0</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                           ret=<span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        que.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(newx,newy));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1255-得分最高的单词集合"><a href="#1255-得分最高的单词集合" class="headerlink" title="1255. 得分最高的单词集合"></a><a href="https://leetcode-cn.com/problems/maximum-score-words-formed-by-letters/">1255. 得分最高的单词集合</a></h4><h5 id="解法1：子集-amp-位压缩"><a href="#解法1：子集-amp-位压缩" class="headerlink" title="解法1：子集&amp;位压缩"></a>解法1：子集&amp;位压缩</h5><p>思路：</p>
<p>1.由于words长度最高15，可枚举words的子集，即$2^{15}$，对于每个子集，统计一下这个子集每个字母用了多少次，是不是letters的子集，如果是计算得分，比较获得最高得分</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxScoreWords</span><span class="params">(vector&lt;string&gt;&amp; words, vector&lt;<span class="keyword">char</span>&gt;&amp; letters, vector&lt;<span class="keyword">int</span>&gt;&amp; score)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">let</span><span class="params">(<span class="number">26</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span>&amp; c:letters)</span><br><span class="line">        &#123;</span><br><span class="line">            let[c-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=words.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);i++)</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; g=<span class="built_in">group</span>(words,i);</span><br><span class="line">            <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">26</span>;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(g[j]&gt;let[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    temp=<span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    temp+=g[j]*score[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">                res=<span class="built_in">max</span>(res,temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">group</span><span class="params">(vector&lt;string&gt;&amp; words,<span class="keyword">int</span> bit)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ret</span><span class="params">(<span class="number">26</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;words.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(bit&amp;(<span class="number">1</span>&lt;&lt;i))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;words[i].<span class="built_in">size</span>();j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    ret[words[i][j]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>周赛</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-第163场周赛</title>
    <url>/2021/10/26/leetcode/zhou-sai/di-163-chang-zhou-sai/</url>
    <content><![CDATA[<h4 id="1260-二维网格迁移"><a href="#1260-二维网格迁移" class="headerlink" title="1260. 二维网格迁移"></a><a href="https://leetcode-cn.com/problems/shift-2d-grid/">1260. 二维网格迁移</a></h4><h5 id="解法：模拟"><a href="#解法：模拟" class="headerlink" title="解法：模拟"></a>解法：模拟</h5><p>模拟，就是右下角向后移动跑到左上角，其他依次右移一个单元格</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">shiftGrid</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span> n=grid.<span class="built_in">size</span>(),m=grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">res</span>(grid.<span class="built_in">begin</span>(),grid.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">temp</span>(grid.<span class="built_in">begin</span>(),grid.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">while</span>(k--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(i==<span class="number">0</span>&amp;&amp;j==<span class="number">0</span>)</span><br><span class="line">                        temp[i][j]=res[n<span class="number">-1</span>][m<span class="number">-1</span>];</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(j==<span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        temp[i][j]=res[i<span class="number">-1</span>][m<span class="number">-1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> temp[i][j]=res[i][j<span class="number">-1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1261-在受污染的二叉树中查找元素"><a href="#1261-在受污染的二叉树中查找元素" class="headerlink" title="1261. 在受污染的二叉树中查找元素"></a><a href="https://leetcode-cn.com/problems/find-elements-in-a-contaminated-binary-tree/">1261. 在受污染的二叉树中查找元素</a></h4><h5 id="解法1：递归"><a href="#解法1：递归" class="headerlink" title="解法1：递归"></a>解法1：递归</h5><p>先前序构造二叉树</p>
<p>然后遍历查找元素</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FindElements</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    TreeNode *root_r;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FindElements</span>(TreeNode* root) &#123;</span><br><span class="line">        root-&gt;val=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">recover</span>(root);</span><br><span class="line">        <span class="keyword">this</span>-&gt;root_r=root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recover</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;left-&gt;val=root-&gt;val*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">recover</span>(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;right-&gt;val=root-&gt;val*<span class="number">2</span>+<span class="number">2</span>;</span><br><span class="line">            <span class="built_in">recover</span>(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        TreeNode *root;</span><br><span class="line">        root=root_r;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find_tar</span>(root,target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">find_tar</span><span class="params">(TreeNode* root,<span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val==target)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find_tar</span>(root-&gt;left,target)||<span class="built_in">find_tar</span>(root-&gt;right,target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your FindElements object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * FindElements* obj = new FindElements(root);</span></span><br><span class="line"><span class="comment"> * bool param_1 = obj-&gt;find(target);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h5 id="解法2：递归-set"><a href="#解法2：递归-set" class="headerlink" title="解法2：递归+set"></a>解法2：递归+set</h5><p>提升：可以在构造过程中直接将元素记录下来，节省大量时间</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FindElements</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    TreeNode *root_r;</span><br><span class="line">    set&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FindElements</span>(TreeNode* root) &#123;</span><br><span class="line">        root-&gt;val=<span class="number">0</span>;</span><br><span class="line">        s.<span class="built_in">insert</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">recover</span>(root);</span><br><span class="line">        <span class="keyword">this</span>-&gt;root_r=root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recover</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;left-&gt;val=root-&gt;val*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">            s.<span class="built_in">insert</span>(root-&gt;left-&gt;val);</span><br><span class="line">            <span class="built_in">recover</span>(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;right-&gt;val=root-&gt;val*<span class="number">2</span>+<span class="number">2</span>;</span><br><span class="line">            s.<span class="built_in">insert</span>(root-&gt;right-&gt;val);</span><br><span class="line">            <span class="built_in">recover</span>(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">find</span>(target)!=s.<span class="built_in">end</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your FindElements object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * FindElements* obj = new FindElements(root);</span></span><br><span class="line"><span class="comment"> * bool param_1 = obj-&gt;find(target);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>



<h4 id="1262-可被三整除的最大和"><a href="#1262-可被三整除的最大和" class="headerlink" title="1262. 可被三整除的最大和"></a><a href="https://leetcode-cn.com/problems/greatest-sum-divisible-by-three/">1262. 可被三整除的最大和</a></h4><h5 id="解法：动态规划"><a href="#解法：动态规划" class="headerlink" title="解法：动态规划"></a>解法：动态规划</h5><p>1.设dp[i]代表 选取的数字累加和 模3=i 的数字和</p>
<p>2.对dp[0]而言。若num[i]%3=k,那么，和前面选取的数字和模3=3-k的数(dp[3-k])相加，就可以模3得0,表达起来就是dp[0]=max(dp[0],dp[3-k]+num[i])</p>
<p>更一般的得dp[j]=max(dp[j],dp[(3-k+j)%3]+num[i])</p>
<p>3.遍历数组，不断更新dp数组，最后返回dp[0]的值即为结果</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSumDivThree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dp[<span class="number">3</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> mod = nums[i] % <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/* int a = dp[(3 + 0 - mod) % 3];</span></span><br><span class="line"><span class="comment">            int b = dp[(3 + 1 - mod) % 3];</span></span><br><span class="line"><span class="comment">            int c = dp[(3 + 2 - mod) % 3];*/</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[(<span class="number">3</span>-mod+j)%<span class="number">3</span>]||mod==j)</span><br><span class="line">               		dp[j]=<span class="built_in">max</span>(dp[j],dp[(<span class="number">3</span>-mod+j)%<span class="number">3</span>]+nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//前面三个if是防止a||b||c =0时，执行后面语句产生错误</span></span><br><span class="line">          <span class="comment">/*  if (a || mod == 0) dp[0] = std::max(dp[0], a + nums[i]);</span></span><br><span class="line"><span class="comment">            if (b || mod == 1) dp[1] = std::max(dp[1], b + nums[i]);</span></span><br><span class="line"><span class="comment">            if (c || mod == 2) dp[2] = std::max(dp[2], c + nums[i]);*/</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<h4 id="1263-推箱子"><a href="#1263-推箱子" class="headerlink" title="1263. 推箱子"></a><a href="https://leetcode-cn.com/problems/minimum-moves-to-move-a-box-to-their-target-location/">1263. 推箱子</a></h4>]]></content>
      <categories>
        <category>周赛</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-第164场周赛</title>
    <url>/2021/10/26/leetcode/zhou-sai/di-164-chang-zhou-sai/</url>
    <content><![CDATA[<h4 id="1266-访问所有点的最小时间"><a href="#1266-访问所有点的最小时间" class="headerlink" title="1266. 访问所有点的最小时间"></a><a href="https://leetcode-cn.com/problems/minimum-time-visiting-all-points/">1266. 访问所有点的最小时间</a></h4><h5 id="解法：切比雪夫距离"><a href="#解法：切比雪夫距离" class="headerlink" title="解法：切比雪夫距离"></a>解法：切比雪夫距离</h5><p>计算max(dx,dy)取较大值</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minTimeToVisitAllPoints</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=points.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x=<span class="built_in">abs</span>(points[i][<span class="number">0</span>]-points[i<span class="number">-1</span>][<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">int</span> y=<span class="built_in">abs</span>(points[i][<span class="number">1</span>]-points[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">            res+=<span class="built_in">max</span>(x,y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1267-统计参与通信的服务器"><a href="#1267-统计参与通信的服务器" class="headerlink" title="1267. 统计参与通信的服务器"></a><a href="https://leetcode-cn.com/problems/count-servers-that-communicate/">1267. 统计参与通信的服务器</a></h4><h5 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h5><p>1.计算各列存在的服务器数量，各行服务器存在的数量，记录服务器的总数量sum</p>
<p>2.当该行该列服务器为1时，表示这个服务器没有连接，统计数量s_res</p>
<p>3.返回sum-s_res</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countServers</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=grid.<span class="built_in">size</span>(),m=grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">col</span><span class="params">(m,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">row</span><span class="params">(n,<span class="number">0</span>)</span></span>;   </span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                row[i]+=grid[i][j];</span><br><span class="line">                col[j]+=grid[i][j];</span><br><span class="line">                sum+=grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> s_res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(row[i]==<span class="number">1</span>&amp;&amp;col[j]==<span class="number">1</span>&amp;&amp;grid[i][j])</span><br><span class="line">                    s_res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum-s_res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1268-搜索推荐系统"><a href="#1268-搜索推荐系统" class="headerlink" title="1268. 搜索推荐系统"></a><a href="https://leetcode-cn.com/problems/search-suggestions-system/">1268. 搜索推荐系统</a></h4><h5 id="解法：map"><a href="#解法：map" class="headerlink" title="解法：map"></a>解法：map</h5><p>思路：</p>
<p>1.利用map存储产品，遍历每个产品数组字符串，将其产品各位数组成的前缀字符串，添加产品到map中，map的名就是前缀字符串</p>
<p>2.遍历searchword，在map中搜索各前缀字符串</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">suggestedProducts</span>(vector&lt;string&gt;&amp; products, string searchWord) &#123;</span><br><span class="line">        map&lt;string,vector&lt;string&gt;&gt; m;</span><br><span class="line">        <span class="keyword">int</span> n=products.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            string t=products[i];</span><br><span class="line">            <span class="keyword">int</span> size=t.<span class="built_in">size</span>();</span><br><span class="line">            string temp=<span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;size;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                temp+=t[j];</span><br><span class="line">                m[temp].<span class="built_in">push_back</span>(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">        <span class="keyword">int</span> len=searchWord.<span class="built_in">size</span>();</span><br><span class="line">        string c=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            c+=searchWord[i];</span><br><span class="line">            <span class="keyword">if</span>(m.<span class="built_in">count</span>(c))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">sort</span>(m[c].<span class="built_in">begin</span>(),m[c].<span class="built_in">end</span>());</span><br><span class="line">                <span class="keyword">if</span>(m[c].<span class="built_in">size</span>()&gt;<span class="number">3</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="function">vector&lt;string&gt; <span class="title">temp</span><span class="params">(m[c].begin(),m[c].begin()+<span class="number">3</span>)</span></span>;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    vector&lt;string&gt; <span class="built_in">temp</span>(m[c].<span class="built_in">begin</span>(),m[c].<span class="built_in">end</span>());</span><br><span class="line">                    res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(&#123;&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1269-停在原地的方案数"><a href="#1269-停在原地的方案数" class="headerlink" title="1269. 停在原地的方案数"></a><a href="https://leetcode-cn.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps/">1269. 停在原地的方案数</a></h4><h5 id="解法1：动态规划"><a href="#解法1：动态规划" class="headerlink" title="解法1：动态规划"></a>解法1：动态规划</h5><p>1.dp[i][j]表示移动i步，停在j位置的总方案数</p>
<p>2.得到dp[i][j]=sum(dp[i-1][j],dp[i-1][j-1],dp[i-1][j+1])</p>
<p>注意：判断steps和arrlen的关系，可以减少时间复杂度，可行位置必然不会超过steps的长度</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> steps, <span class="keyword">int</span> arrLen)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arrlen=<span class="built_in">min</span>(steps,arrLen);</span><br><span class="line">        <span class="keyword">int</span> mod=<span class="built_in">pow</span>(<span class="number">10</span>,<span class="number">9</span>)+<span class="number">7</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt; <span class="built_in">dp</span>(steps+<span class="number">1</span>,vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(arrlen,<span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;steps+<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;arrlen;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j]=dp[i<span class="number">-1</span>][j];</span><br><span class="line">                <span class="keyword">if</span>(j!=<span class="number">0</span>)</span><br><span class="line">                    dp[i][j]+=dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">if</span>(j!=arrlen<span class="number">-1</span>)</span><br><span class="line">                    dp[i][j]+=dp[i<span class="number">-1</span>][j+<span class="number">1</span>];</span><br><span class="line">                dp[i][j]%=mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[steps][<span class="number">0</span>]%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>周赛</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-第165场周赛</title>
    <url>/2021/10/26/leetcode/zhou-sai/di-165-chang-zhou-sai/</url>
    <content><![CDATA[<h4 id="5275-找出井字棋的获胜者"><a href="#5275-找出井字棋的获胜者" class="headerlink" title="5275. 找出井字棋的获胜者"></a><a href="https://leetcode-cn.com/problems/find-winner-on-a-tic-tac-toe-game/">5275. 找出井字棋的获胜者</a></h4><h5 id="解法1：模拟"><a href="#解法1：模拟" class="headerlink" title="解法1：模拟"></a>解法1：模拟</h5><p>模拟每步棋子的放置，判断最后一步的位置的所在的行、列，对角线能否取胜</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">tictactoe</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; moves)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=moves.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt; <span class="built_in">res</span>(<span class="number">3</span>,vector&lt;<span class="keyword">char</span>&gt;(<span class="number">3</span>,<span class="string">&#x27; &#x27;</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">                res[moves[i][<span class="number">0</span>]][moves[i][<span class="number">1</span>]]=<span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                res[moves[i][<span class="number">0</span>]][moves[i][<span class="number">1</span>]]=<span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> f1=<span class="literal">true</span>,f2=<span class="literal">true</span>,f3=<span class="literal">true</span>,f4=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(n%<span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(res[moves[n<span class="number">-1</span>][<span class="number">0</span>]][i]!=<span class="string">&#x27;X&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    f1=<span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(res[i][i]!=<span class="string">&#x27;X&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    f2=<span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(res[<span class="number">2</span>-i][i]!=<span class="string">&#x27;X&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    f3=<span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(res[i][moves[n<span class="number">-1</span>][<span class="number">1</span>]]!=<span class="string">&#x27;X&#x27;</span>)</span><br><span class="line">                    f4=<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(res[moves[n<span class="number">-1</span>][<span class="number">0</span>]][i]!=<span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    f1=<span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(res[i][i]!=<span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    f2=<span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(res[<span class="number">2</span>-i][i]!=<span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    f3=<span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(res[i][moves[n<span class="number">-1</span>][<span class="number">1</span>]]!=<span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                    f4=<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(f1||f2||f3||f4)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(n%<span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;A&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;B&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">9</span>)    <span class="keyword">return</span> <span class="string">&quot;Draw&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Pending&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="5276-不浪费原料的汉堡制作方案"><a href="#5276-不浪费原料的汉堡制作方案" class="headerlink" title="5276. 不浪费原料的汉堡制作方案"></a><a href="https://leetcode-cn.com/problems/number-of-burgers-with-no-waste-of-ingredients/">5276. 不浪费原料的汉堡制作方案</a></h4><h5 id="解法1：解方程"><a href="#解法1：解方程" class="headerlink" title="解法1：解方程"></a>解法1：解方程</h5><p>小学方程题。。。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">numOfBurgers</span><span class="params">(<span class="keyword">int</span> tomatoSlices, <span class="keyword">int</span> cheeseSlices)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=cheeseSlices;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">4</span>*i+<span class="number">2</span>*(cheeseSlices-i)==tomatoSlices)</span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(i);</span><br><span class="line">                res.<span class="built_in">push_back</span>(cheeseSlices-i);</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="5277-统计全为-1-的正方形子矩阵"><a href="#5277-统计全为-1-的正方形子矩阵" class="headerlink" title="5277. 统计全为 1 的正方形子矩阵"></a><a href="https://leetcode-cn.com/problems/count-square-submatrices-with-all-ones/">5277. 统计全为 1 的正方形子矩阵</a></h4><h5 id="解法1：dp动态规划"><a href="#解法1：dp动态规划" class="headerlink" title="解法1：dp动态规划"></a>解法1：dp动态规划</h5><p>1.dp[i][j]表示以i,j为正方形右下角点所能组成的最长的正方形</p>
<p>2.初始化dp[i][0]=matrix[i][0];dp[0][j]=matrix[0][j];</p>
<p>3.状态转移方程,</p>
<p>​    若dp[i-1][j-1]==dp[i-1][j]&amp;&amp;dp[i-1][j-1]==dp[i][j-1]&amp;&amp;matrix[i][j],         dp[i][j]=dp[i-1][j-1]+1;</p>
<p>​    否则若matrix[i][j]                    dp[i][j]=min(min(dp[i-1][j-1],dp[i-1][j]),dp[i][j-1])+1;</p>
<p>4.返回res=sum(dp[i][j])；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSquares</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=matrix.<span class="built_in">size</span>(),m=matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(n,vector&lt;<span class="keyword">int</span>&gt;(m,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j==<span class="number">0</span>)</span><br><span class="line">                    dp[i][j]=matrix[i][j];</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">                    dp[i][j]=matrix[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;m;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[i<span class="number">-1</span>][j<span class="number">-1</span>]==dp[i<span class="number">-1</span>][j]&amp;&amp;dp[i<span class="number">-1</span>][j<span class="number">-1</span>]==dp[i][j<span class="number">-1</span>]&amp;&amp;matrix[i][j])</span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(matrix[i][j])</span><br><span class="line">                    dp[i][j]=<span class="built_in">min</span>(<span class="built_in">min</span>(dp[i<span class="number">-1</span>][j<span class="number">-1</span>],dp[i<span class="number">-1</span>][j]),dp[i][j<span class="number">-1</span>])+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                res+=dp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="5278-分割回文串-III"><a href="#5278-分割回文串-III" class="headerlink" title="5278. 分割回文串 III"></a><a href="https://leetcode-cn.com/problems/palindrome-partitioning-iii/">5278. 分割回文串 III</a></h4><h5 id="解法1：dp"><a href="#解法1：dp" class="headerlink" title="解法1：dp"></a>解法1：dp</h5><p>1.dp[i][j]表示,[0,i]位置字符串分成j份，需要的最少修改字符数</p>
<p>定义cost[i][j]数组，表示[i,j]位置字符串转化为回文串所需要的最小代价</p>
<p>2.初始化dp[i][1]=cost[0][i];</p>
<p>3.状态转移方程dp[i][j]=min(dp[x][j-1]+cost[x+1][i])其中x[0,i)</p>
<p>4.返回dp[n-1][k];</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">palindromePartition</span><span class="params">(string s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(n,vector&lt;<span class="keyword">int</span>&gt;(k+<span class="number">1</span>,n));</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">cost</span>(n,vector&lt;<span class="keyword">int</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                cost[i][j]=<span class="built_in">get_cost</span>(i,j,s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][<span class="number">1</span>]=cost[<span class="number">0</span>][i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;k+<span class="number">1</span>;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;i;x++)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j]=<span class="built_in">min</span>(dp[i][j],dp[x][j<span class="number">-1</span>]+cost[x+<span class="number">1</span>][i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>][k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_cost</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,string s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]!=s[j])</span><br><span class="line">                res++;</span><br><span class="line">            i++;j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>周赛</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-第7场双周赛</title>
    <url>/2019/08/25/leetcode/zhou-sai/di-7-chang-shuang-zhou-sai/</url>
    <content><![CDATA[<h4 id="1165-单行键盘"><a href="#1165-单行键盘" class="headerlink" title="1165.单行键盘"></a>1165.单行键盘</h4><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>我们定制了一款特殊的力扣键盘，所有的键都排列在一行上。</p>
<p>我们可以按从左到右的顺序，用一个长度为 26 的字符串 <code>keyboard</code> （索引从 0 开始，到 25 结束）来表示该键盘的键位布局。</p>
<p>现在需要测试这个键盘是否能够有效工作，那么我们就需要个机械手来测试这个键盘。</p>
<p>最初的时候，机械手位于左边起第一个键（也就是索引为 0 的键）的上方。当机械手移动到某一字符所在的键位时，就会在终端上输出该字符。</p>
<p>机械手从索引 <code>i</code> 移动到索引 <code>j</code> 所需要的时间是 <code>|i - j|</code>。</p>
<p>当前测试需要你使用机械手输出指定的单词 <code>word</code>，请你编写一个函数来计算机械手输出该单词所需的时间。</p>
<p>​    <span id="more"></span> </p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：keyboard = &quot;abcdefghijklmnopqrstuvwxyz&quot;, word = &quot;cba&quot;</span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">机械手从 0 号键移动到 2 号键来输出 &#x27;c&#x27;，又移动到 1 号键来输出 &#x27;b&#x27;，接着移动到 0 号键来输出 &#x27;a&#x27;。</span><br><span class="line">总用时 = 2 + 1 + 1 = 4. </span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：keyboard = &quot;pqrstuvwxyzabcdefghijklmno&quot;, word = &quot;leetcode&quot;</span><br><span class="line">输出：73</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>keyboard.length == 26</code></li>
<li><code>keyboard</code> 按某种特定顺序排列，并包含每个小写英文字母一次。</li>
<li><code>1 &lt;= word.length &lt;= 10^4</code></li>
<li><code>word[i]</code> 是一个小写英文字母</li>
</ul>
<h5 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h5><p>1.扫描keyboard 利用map存储每个字母的位置</p>
<p>2.扫描word得到距离</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculateTime</span><span class="params">(string keyboard, string word)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;keyboard.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            m[keyboard[i]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> time=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;word.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            time+=<span class="built_in">abs</span>(j-m[word[i]]);</span><br><span class="line">            j=m[word[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> time;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1166-设计文件系统"><a href="#1166-设计文件系统" class="headerlink" title="1166.设计文件系统"></a>1166.设计文件系统</h4><h5 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h5><p>你需要设计一个能提供下面两个函数的文件系统：</p>
<ul>
<li><strong>create(path, value):</strong> 创建一个新的路径，并尽可能将值 <code>value</code> 与路径 <code>path</code> 关联，然后返回 <code>True</code>。如果路径已经存在或者路径的父路径不存在，则返回 <code>False</code>。</li>
<li><strong>get(path):</strong> 返回与路径关联的值。如果路径不存在，则返回 <code>-1</code>。</li>
</ul>
<p>“路径” 是由一个或多个符合下述格式的字符串连接起来形成的：在 <code>/</code> 后跟着一个或多个小写英文字母。</p>
<p>例如 <code>/leetcode</code> 和 <code>/leetcode/problems</code> 都是有效的路径，但空字符串和 <code>/</code> 不是有效的路径。</p>
<p>好了，接下来就请你来实现这两个函数吧！（请参考示例以获得更多信息）</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入： </span><br><span class="line">[&quot;FileSystem&quot;,&quot;create&quot;,&quot;get&quot;]</span><br><span class="line">[[],[&quot;/a&quot;,1],[&quot;/a&quot;]]</span><br><span class="line">输出： </span><br><span class="line">[null,true,1]</span><br><span class="line">解释： </span><br><span class="line">FileSystem fileSystem = new FileSystem();</span><br><span class="line"></span><br><span class="line">fileSystem.create(&quot;/a&quot;, 1); // 返回 true</span><br><span class="line">fileSystem.get(&quot;/a&quot;); // 返回 1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入： </span><br><span class="line">[&quot;FileSystem&quot;,&quot;create&quot;,&quot;create&quot;,&quot;get&quot;,&quot;create&quot;,&quot;get&quot;]</span><br><span class="line">[[],[&quot;/leet&quot;,1],[&quot;/leet/code&quot;,2],[&quot;/leet/code&quot;],[&quot;/c/d&quot;,1],[&quot;/c&quot;]]</span><br><span class="line">输出： </span><br><span class="line">[null,true,true,2,false,-1]</span><br><span class="line">解释：</span><br><span class="line">FileSystem fileSystem = new FileSystem();</span><br><span class="line"></span><br><span class="line">fileSystem.create(&quot;/leet&quot;, 1); // 返回 true</span><br><span class="line">fileSystem.create(&quot;/leet/code&quot;, 2); // 返回 true</span><br><span class="line">fileSystem.get(&quot;/leet/code&quot;); // 返回 2</span><br><span class="line">fileSystem.create(&quot;/c/d&quot;, 1); // 返回 false 因为父路径 &quot;/c&quot; 不存在。</span><br><span class="line">fileSystem.get(&quot;/c&quot;); // 返回 -1 因为该路径不存在。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>对两个函数的调用次数加起来小于等于 <code>10^4</code></li>
<li><code>2 &lt;= path.length &lt;= 100</code></li>
<li><code>1 &lt;= value &lt;= 10^9</code></li>
</ul>
<h5 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h5><p>模拟存放，map存已经生成的路径</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSystem</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    map&lt;string,<span class="keyword">int</span>&gt; F;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FileSystem</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">create</span><span class="params">(string path, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        string t;</span><br><span class="line">        <span class="keyword">int</span> n=path.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            t+=path[i];</span><br><span class="line">            <span class="keyword">for</span>(i++;i&lt;n;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(path[i]==<span class="string">&#x27;/&#x27;</span>)<span class="keyword">break</span>;</span><br><span class="line">                t+=path[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i!=n&amp;&amp;!F.<span class="built_in">count</span>(t))   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(F.<span class="built_in">count</span>(t))  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        F[t]=value;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(string path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!F.<span class="built_in">count</span>(path))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> F[path];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your FileSystem object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * FileSystem* obj = new FileSystem();</span></span><br><span class="line"><span class="comment"> * bool param_1 = obj-&gt;create(path,value);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;get(path);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h4 id="1167-连接棒材的最低费用"><a href="#1167-连接棒材的最低费用" class="headerlink" title="1167.连接棒材的最低费用"></a>1167.连接棒材的最低费用</h4><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>为了装修新房，你需要加工一些长度为正整数的棒材 <code>sticks</code>。</p>
<p>如果要将长度分别为 <code>X</code> 和 <code>Y</code> 的两根棒材连接在一起，你需要支付 <code>X + Y</code> 的费用。 由于施工需要，你必须将所有棒材连接成一根。</p>
<p>返回你把所有棒材 <code>sticks</code> 连成一根所需要的最低费用。注意你可以任意选择棒材连接的顺序。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：sticks = [2,4,3]</span><br><span class="line">输出：14</span><br><span class="line">解释：先将 2 和 3 连接成 5，花费 5；再将 5 和 4 连接成 9；总花费为 14。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：sticks = [1,8,3,5]</span><br><span class="line">输出：30</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= sticks.length &lt;= 10^4</code></li>
<li><code>1 &lt;= sticks[i] &lt;= 10^4</code></li>
</ul>
<h5 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h5><p>思路是huffman树，每次取数组的最小值和次小值，用优先级队列快速实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">connectSticks</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; sticks)</span> </span>&#123;</span><br><span class="line">           priority_queue&lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt;&gt; que;</span><br><span class="line">           <span class="keyword">int</span> n=sticks.<span class="built_in">size</span>();</span><br><span class="line">           <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            que.<span class="built_in">push</span>(sticks[i]);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()&amp;&amp;que.<span class="built_in">size</span>()&gt;=<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x=que.<span class="built_in">top</span>();que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">int</span> y=que.<span class="built_in">top</span>();que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">int</span> z=x+y;</span><br><span class="line">            sum+=z;</span><br><span class="line">            que.<span class="built_in">push</span>(z);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>周赛</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-第8场双周赛</title>
    <url>/2019/09/08/leetcode/zhou-sai/di-8-chang-shuang-zhou-sai/</url>
    <content><![CDATA[<h4 id="5067-统计只含单一字母的子串"><a href="#5067-统计只含单一字母的子串" class="headerlink" title="5067.统计只含单一字母的子串"></a>5067.统计只含单一字母的子串</h4><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>给你一个字符串 <code>S</code>，返回只含 <strong>单一字母</strong> 的子串个数。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入： &quot;aaaba&quot;</span><br><span class="line">输出： 8</span><br><span class="line">解释： </span><br><span class="line">只含单一字母的子串分别是 &quot;aaa&quot;， &quot;aa&quot;， &quot;a&quot;， &quot;b&quot;。</span><br><span class="line">&quot;aaa&quot; 出现 1 次。</span><br><span class="line">&quot;aa&quot; 出现 2 次。</span><br><span class="line">&quot;a&quot; 出现 4 次。</span><br><span class="line">&quot;b&quot; 出现 1 次。</span><br><span class="line">所以答案是 1 + 2 + 4 + 1 = 8。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入： &quot;aaaaaaaaaa&quot;</span><br><span class="line">输出： 55</span><br></pre></td></tr></table></figure>

 <span id="more"></span>

<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= S.length &lt;= 1000</code></li>
<li><code>S[i]</code> 仅由小写英文字母组成。</li>
</ol>
<h5 id="解法1：暴力"><a href="#解法1：暴力" class="headerlink" title="解法1：暴力"></a>解法1：暴力</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countLetters</span><span class="params">(string S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=S.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> temp=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> c=S[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(S[i]==c)</span><br><span class="line">            &#123;</span><br><span class="line">                k++;</span><br><span class="line">                temp+=k;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                res+=temp;</span><br><span class="line">                k=<span class="number">1</span>;</span><br><span class="line">                temp=<span class="number">1</span>;</span><br><span class="line">                c=S[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res+=temp;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="5068-前后拼接"><a href="#5068-前后拼接" class="headerlink" title="5068.前后拼接"></a>5068.前后拼接</h4><h5 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h5><p>给你一个「短语」列表 <code>phrases</code>，请你帮忙按规则生成拼接后的「新短语」列表。</p>
<p>「短语」（phrase）是仅由小写英文字母和空格组成的字符串。「短语」的开头和结尾都不会出现空格，「短语」中的空格不会连续出现。</p>
<p>「前后拼接」（Before and After puzzles）是合并两个「短语」形成「新短语」的方法。我们规定拼接时，<strong>第一个短语的最后一个单词</strong> 和 <strong>第二个短语的第一个单词</strong> 必须相同。</p>
<p>返回每两个「短语」 <code>phrases[i]</code> 和 <code>phrases[j]</code>（<code>i != j</code>）进行「前后拼接」得到的「新短语」。</p>
<p>注意，两个「短语」拼接时的顺序也很重要，我们需要同时考虑这两个「短语」。另外，同一个「短语」可以多次参与拼接，但「新短语」不能再参与拼接。</p>
<p>请你按字典序排列并返回「新短语」列表，列表中的字符串应该是 <strong>不重复的</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：phrases = [&quot;writing code&quot;,&quot;code rocks&quot;]</span><br><span class="line">输出：[&quot;writing code rocks&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：phrases = [&quot;mission statement&quot;,</span><br><span class="line">                &quot;a quick bite to eat&quot;,</span><br><span class="line">                &quot;a chip off the old block&quot;,</span><br><span class="line">                &quot;chocolate bar&quot;,</span><br><span class="line">                &quot;mission impossible&quot;,</span><br><span class="line">                &quot;a man on a mission&quot;,</span><br><span class="line">                &quot;block party&quot;,</span><br><span class="line">                &quot;eat my words&quot;,</span><br><span class="line">                &quot;bar of soap&quot;]</span><br><span class="line">输出：[&quot;a chip off the old block party&quot;,</span><br><span class="line">      &quot;a man on a mission impossible&quot;,</span><br><span class="line">      &quot;a man on a mission statement&quot;,</span><br><span class="line">      &quot;a quick bite to eat my words&quot;,</span><br><span class="line">      &quot;chocolate bar of soap&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：phrases = [&quot;a&quot;,&quot;b&quot;,&quot;a&quot;]</span><br><span class="line">输出：[&quot;a&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= phrases.length &lt;= 100</code></li>
<li><code>1 &lt;= phrases[i].length &lt;= 100</code></li>
</ul>
<h5 id="解法1：暴力-1"><a href="#解法1：暴力-1" class="headerlink" title="解法1：暴力"></a>解法1：暴力</h5><p>思路：phrases的长度只有100，100*100也只有10000的复杂度，所以我们直接暴力，判断首尾，最后对数组排序再去重就得到了结果</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">beforeAndAfterPuzzles</span><span class="params">(vector&lt;string&gt;&amp; phrases)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        <span class="keyword">int</span> len=phrases.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            string s1l=<span class="string">&quot;&quot;</span>;</span><br><span class="line">            string s1r=<span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">int</span> l1;</span><br><span class="line">            <span class="keyword">int</span> k;</span><br><span class="line">            <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;phrases[i].<span class="built_in">size</span>()&amp;&amp;phrases[i][k]!=<span class="string">&#x27; &#x27;</span>;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                s1l+=phrases[i][k];</span><br><span class="line">            &#125;</span><br><span class="line">            l1=k;</span><br><span class="line">            <span class="keyword">for</span>(k=phrases[i].<span class="built_in">size</span>()<span class="number">-1</span>;k&gt;=<span class="number">0</span>&amp;&amp;phrases[i][k]!=<span class="string">&#x27; &#x27;</span>;k--)</span><br><span class="line">            &#123;</span><br><span class="line">                s1r+=phrases[i][k];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">reverse</span>(s1r.<span class="built_in">begin</span>(),s1r.<span class="built_in">end</span>());</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;len;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                string s2l=<span class="string">&quot;&quot;</span>;</span><br><span class="line">                string s2r=<span class="string">&quot;&quot;</span>;</span><br><span class="line">                <span class="keyword">int</span> l2;</span><br><span class="line">                <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;phrases[j].<span class="built_in">size</span>()&amp;&amp;phrases[j][k]!=<span class="string">&#x27; &#x27;</span>;k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    s2l+=phrases[j][k];</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                l2=k;</span><br><span class="line">                <span class="keyword">for</span>(k=phrases[j].<span class="built_in">size</span>()<span class="number">-1</span>;k&gt;=<span class="number">0</span>&amp;&amp;phrases[j][k]!=<span class="string">&#x27; &#x27;</span>;k--)</span><br><span class="line">                &#123;</span><br><span class="line">                    s2r+=phrases[j][k];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">reverse</span>(s2r.<span class="built_in">begin</span>(),s2r.<span class="built_in">end</span>());</span><br><span class="line">                <span class="keyword">if</span>(s1r==s2l)</span><br><span class="line">                &#123;</span><br><span class="line">                    string temp=phrases[i]+phrases[j].<span class="built_in">substr</span>(l2);</span><br><span class="line">                    res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(s2r==s1l)</span><br><span class="line">                &#123;</span><br><span class="line">                    string temp=phrases[j]+phrases[i].<span class="built_in">substr</span>(l1);</span><br><span class="line">                    res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;string&gt;::iterator iter=<span class="built_in">unique</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">        res.<span class="built_in">erase</span>(iter,res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="5070-与目标颜色间的最短距离"><a href="#5070-与目标颜色间的最短距离" class="headerlink" title="5070.与目标颜色间的最短距离"></a>5070.与目标颜色间的最短距离</h4><h5 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h5><p>给你一个数组 <code>colors</code>，里面有  <code>1</code>、<code>2</code>、 <code>3</code> 三种颜色。</p>
<p>我们需要在 <code>colors</code> 上进行一些查询操作 <code>queries</code>，其中每个待查项都由两个整数 <code>i</code> 和 <code>c</code> 组成。</p>
<p>现在请你帮忙设计一个算法，查找从索引 <code>i</code> 到具有目标颜色 <code>c</code> 的元素之间的最短距离。</p>
<p>如果不存在解决方案，请返回 <code>-1</code>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：colors = [1,1,2,1,3,2,2,3,3], queries = [[1,3],[2,2],[6,1]]</span><br><span class="line">输出：[3,0,3]</span><br><span class="line">解释： </span><br><span class="line">距离索引 1 最近的颜色 3 位于索引 4（距离为 3）。</span><br><span class="line">距离索引 2 最近的颜色 2 就是它自己（距离为 0）。</span><br><span class="line">距离索引 6 最近的颜色 1 位于索引 3（距离为 3）。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：colors = [1,2], queries = [[0,3]]</span><br><span class="line">输出：[-1]</span><br><span class="line">解释：colors 中没有颜色 3。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= colors.length &lt;= 5*10^4</code></li>
<li><code>1 &lt;= colors[i] &lt;= 3</code></li>
<li><code>1 &lt;= queries.length &lt;= 5*10^4</code></li>
<li><code>queries[i].length == 2</code></li>
<li><code>0 &lt;= queries[i][0] &lt; colors.length</code></li>
<li><code>1 &lt;= queries[i][1] &lt;= 3</code></li>
</ul>
<h5 id="解法1：左右各遍历1次"><a href="#解法1：左右各遍历1次" class="headerlink" title="解法1：左右各遍历1次"></a>解法1：左右各遍历1次</h5><p>1.先从左往右遍历。记录这个索引下，各种颜色离这个索引位置最近的索引（即当前该颜色的最大值）</p>
<p>2.同样从右往左遍历。</p>
<p>3.选择左右离这个索引最近的值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">shortestDistanceColor</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; colors, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> n=colors.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> m=queries.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">left</span>(<span class="number">4</span>,vector&lt;<span class="keyword">int</span>&gt;(<span class="number">50005</span>,<span class="number">0</span>));</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">right</span>(<span class="number">4</span>,vector&lt;<span class="keyword">int</span>&gt;(<span class="number">50005</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x=<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;colors.<span class="built_in">size</span>();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(colors[j]==i)</span><br><span class="line">                    x=j;</span><br><span class="line">                left[i][j]=x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x=<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=colors.<span class="built_in">size</span>()<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(colors[j]==i)</span><br><span class="line">                    x=j;</span><br><span class="line">                right[i][j]=x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> index=queries[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> color=queries[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> l=left[color][index];</span><br><span class="line">            <span class="keyword">int</span> r=right[color][index];</span><br><span class="line">            <span class="keyword">if</span>(l==<span class="number">-1</span>&amp;&amp;r==<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(<span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> val=INT_MAX;</span><br><span class="line">            <span class="keyword">if</span>(l!=<span class="number">-1</span>)</span><br><span class="line">                val=<span class="built_in">min</span>(<span class="built_in">abs</span>(left[color][index]-index),val);</span><br><span class="line">            <span class="keyword">if</span>(r!=<span class="number">-1</span>)</span><br><span class="line">                val=<span class="built_in">min</span>(<span class="built_in">abs</span>(right[color][index]-index),val);</span><br><span class="line">            res.<span class="built_in">push_back</span>(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="5082-矩阵中1的最大数量"><a href="#5082-矩阵中1的最大数量" class="headerlink" title="5082.矩阵中1的最大数量"></a>5082.矩阵中1的最大数量</h4><h5 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h5><p>现在有一个尺寸为 <code>width * height</code> 的矩阵 <code>M</code>，矩阵中的每个单元格的值不是 <code>0</code> 就是 <code>1</code>。</p>
<p>而且矩阵 <code>M</code> 中每个大小为 <code>sideLength * sideLength</code> 的 <strong>正方形</strong> 子阵中，<code>1</code> 的数量不得超过 <code>maxOnes</code>。</p>
<p>请你设计一个算法，计算矩阵中最多可以有多少个 <code>1</code>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：width = 3, height = 3, sideLength = 2, maxOnes = 1</span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">题目要求：在一个 3*3 的矩阵中，每一个 2*2 的子阵中的 1 的数目不超过 1 个。</span><br><span class="line">最好的解决方案中，矩阵 M 里最多可以有 4 个 1，如下所示：</span><br><span class="line">[1,0,1]</span><br><span class="line">[0,0,0]</span><br><span class="line">[1,0,1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：width = 3, height = 3, sideLength = 2, maxOnes = 2</span><br><span class="line">输出：6</span><br><span class="line">解释：</span><br><span class="line">[1,0,1]</span><br><span class="line">[1,0,1]</span><br><span class="line">[1,0,1]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= width, height &lt;= 100</code></li>
<li><code>1 &lt;= sideLength &lt;= width, height</code></li>
<li><code>0 &lt;= maxOnes &lt;= sideLength * sideLength</code></li>
</ul>
<h5 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h5><p>循环矩阵</p>
<p>以sideLength的正方形为一个循环，找到每个位置在大矩阵中出现的次数，选择出现次数最多的前maxOnes位</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumNumberOfOnes</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height, <span class="keyword">int</span> sideLength, <span class="keyword">int</span> maxOnes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a[<span class="number">101</span>][<span class="number">101</span>] =&#123;&#123;<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;width;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;height;j++)&#123;</span><br><span class="line">                a[i%sideLength][j%sideLength]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sideLength;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;sideLength;j++)&#123;</span><br><span class="line">                cnt.<span class="built_in">push_back</span>(a[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(cnt.<span class="built_in">begin</span>(),cnt.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">reverse</span>(cnt.<span class="built_in">begin</span>(),cnt.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;maxOnes;i++)&#123;</span><br><span class="line">            ans += cnt[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>周赛</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-第9场双周赛</title>
    <url>/2019/10/04/leetcode/zhou-sai/di-9-chang-shuang-zhou-sai/</url>
    <content><![CDATA[<h4 id="5072-最多可以买到的苹果数量"><a href="#5072-最多可以买到的苹果数量" class="headerlink" title="5072.最多可以买到的苹果数量"></a>5072.最多可以买到的苹果数量</h4><p>楼下水果店正在促销，你打算买些苹果，<code>arr[i]</code> 表示第 <code>i</code> 个苹果的单位重量。</p>
<p>你有一个购物袋，最多可以装 <code>5000</code> 单位重量的东西，算一算，最多可以往购物袋里装入多少苹果。</p>
  <span id="more"></span>

<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：arr = [100,200,150,1000]</span><br><span class="line">输出：4</span><br><span class="line">解释：所有 4 个苹果都可以装进去，因为它们的重量之和为 1450。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：arr = [900,950,800,1000,700,800]</span><br><span class="line">输出：5</span><br><span class="line">解释：6 个苹果的总重量超过了 5000，所以我们只能从中任选 5 个。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= arr.length &lt;= 10^3</code></li>
<li><code>1 &lt;= arr[i] &lt;= 10^3</code></li>
</ul>
<h5 id="解法-贪心"><a href="#解法-贪心" class="headerlink" title="解法:贪心"></a>解法:贪心</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxNumberOfApples</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(),arr.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> n=arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">5000</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum-=arr[i];</span><br><span class="line">            <span class="keyword">if</span>(sum&lt;<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="5073-进击的骑士"><a href="#5073-进击的骑士" class="headerlink" title="5073.进击的骑士"></a>5073.进击的骑士</h4><p>一个坐标可以从 <code>-infinity</code> 延伸到 <code>+infinity</code> 的 <strong>无限大的</strong> 棋盘上，你的 <strong>骑士</strong> 驻扎在坐标为 <code>[0, 0]</code> 的方格里。</p>
<p>骑士的走法和中国象棋中的马相似，走 “日” 字：即先向左（或右）走 1 格，再向上（或下）走 2 格；或先向左（或右）走 2 格，再向上（或下）走 1 格。</p>
<p>每次移动，他都可以按图示八个方向之一前进。</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/21/knight.png" alt="img"></p>
<p>现在，骑士需要前去征服坐标为 <code>[x, y]</code> 的部落，请你为他规划路线。</p>
<p>最后返回所需的最小移动次数即可。本题确保答案是一定存在的。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：x = 2, y = 1</span><br><span class="line">输出：1</span><br><span class="line">解释：[0, 0] → [2, 1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：x = 5, y = 5</span><br><span class="line">输出：4</span><br><span class="line">解释：[0, 0] → [2, 1] → [4, 2] → [3, 4] → [5, 5]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>|x| + |y| &lt;= 300</code></li>
</ul>
<h5 id="解法1：bfs"><a href="#解法1：bfs" class="headerlink" title="解法1：bfs"></a>解法1：bfs</h5><p>广度优先搜索，注意判断边界条件，</p>
<p>小技巧：将坐标+300，就全都变成了正数，处理数据更简单</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minKnightMoves</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dx[<span class="number">8</span>]=&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> dy[<span class="number">8</span>]=&#123;<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-2</span>&#125;;</span><br><span class="line">        <span class="keyword">bool</span> dist[<span class="number">610</span>][<span class="number">610</span>];</span><br><span class="line">        queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; que;</span><br><span class="line">        x+=<span class="number">300</span>,y+=<span class="number">300</span>;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(dist, <span class="literal">false</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dist));</span><br><span class="line">        dist[<span class="number">300</span>][<span class="number">300</span>]=<span class="literal">true</span>; que.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">300</span>, <span class="number">300</span>));</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> size=que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> nowx=que.<span class="built_in">front</span>().first, nowy=que.<span class="built_in">front</span>().second;</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(nowx==x&amp;&amp;nowy==y)</span><br><span class="line">                    <span class="keyword">return</span> res;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;<span class="number">8</span>; k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> nx=nowx+dx[k], ny=nowy+dy[k];</span><br><span class="line">                    <span class="keyword">if</span> (nx&lt;<span class="number">0</span> || ny&lt;<span class="number">0</span> || nx&gt;<span class="number">600</span> || ny&gt;<span class="number">600</span>||dist[nx][ny]) <span class="keyword">continue</span>;</span><br><span class="line">                    dist[nx][ny]=<span class="literal">true</span>;</span><br><span class="line">                    que.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(nx, ny));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="5071-找出所有行中最小公共元素"><a href="#5071-找出所有行中最小公共元素" class="headerlink" title="5071.找出所有行中最小公共元素"></a>5071.找出所有行中最小公共元素</h4><p>给你一个矩阵 <code>mat</code>，其中每一行的元素都已经按 <strong>递增</strong> 顺序排好了。请你帮忙找出在所有这些行中 <strong>最小的公共元素</strong>。</p>
<p>如果矩阵中没有这样的公共元素，就请返回 <code>-1</code>。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：mat = [[1,2,3,4,5],[2,4,5,8,10],[3,5,7,9,11],[1,3,5,7,9]]</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= mat.length, mat[i].length &lt;= 500</code></li>
<li><code>1 &lt;= mat[i][j] &lt;= 10^4</code></li>
<li><code>mat[i]</code> 已按递增顺序排列。</li>
</ul>
<h5 id="解法1：map"><a href="#解法1：map" class="headerlink" title="解法1：map"></a>解法1：map</h5><p>map存每一个数字的个数，找到map中数字个数和行数相等的元素</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">smallestCommonElement</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; mat)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">int</span> n=mat.<span class="built_in">size</span>(),ml=mat[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;ml;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                m[mat[i][j]]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::iterator ite=m.<span class="built_in">begin</span>();ite!=m.<span class="built_in">end</span>();ite++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ite-&gt;second==n)</span><br><span class="line">                <span class="keyword">return</span> ite-&gt;first;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="5091-建造街区的最短时间"><a href="#5091-建造街区的最短时间" class="headerlink" title="5091.建造街区的最短时间"></a>5091.建造街区的最短时间</h4><p>你是个城市规划工作者，手里负责管辖一系列的街区。在这个街区列表中 <code>blocks[i] = t</code> 意味着第  <code>i</code> 个街区需要 <code>t</code> 个单位的时间来建造。</p>
<p>由于一个街区只能由一个工人来完成建造。</p>
<p>所以，一个工人要么需要再召唤一个工人（工人数增加 1）；要么建造完一个街区后回家。这两个决定都需要花费一定的时间。</p>
<p>一个工人再召唤一个工人所花费的时间由整数 <code>split</code> 给出。</p>
<p>注意：如果两个工人同时召唤别的工人，那么他们的行为是并行的，所以时间花费仍然是 <code>split</code>。</p>
<p>最开始的时候只有 <strong>一个</strong> 工人，请你最后输出建造完所有街区所需要的最少时间。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：blocks = [1], split = 1</span><br><span class="line">输出：1</span><br><span class="line">解释：我们使用 1 个工人在 1 个时间单位内来建完 1 个街区。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：blocks = [1,2], split = 5</span><br><span class="line">输出：7</span><br><span class="line">解释：我们用 5 个时间单位将这个工人分裂为 2 个工人，然后指派每个工人分别去建造街区，从而时间花费为 5 + max(1, 2) = 7</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：blocks = [1,2,3], split = 1</span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">将 1 个工人分裂为 2 个工人，然后指派第一个工人去建造最后一个街区，并将第二个工人分裂为 2 个工人。</span><br><span class="line">然后，用这两个未分派的工人分别去建造前两个街区。</span><br><span class="line">时间花费为 1 + max(3, 1 + max(1, 2)) = 4</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= blocks.length &lt;= 1000</code></li>
<li><code>1 &lt;= blocks[i] &lt;= 10^5</code></li>
<li><code>1 &lt;= split &lt;= 100</code></li>
</ol>
<h5 id="解法1：优先级队列"><a href="#解法1：优先级队列" class="headerlink" title="解法1：优先级队列"></a>解法1：优先级队列</h5><p>每次都取最小的两位</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minBuildTime</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; blocks, <span class="keyword">int</span> split)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> b:blocks)</span><br><span class="line">        &#123;</span><br><span class="line">            que.<span class="built_in">push</span>(-b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(que.<span class="built_in">size</span>()&gt;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x=-que.<span class="built_in">top</span>();que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">int</span> y=-que.<span class="built_in">top</span>();que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">int</span> z=split+y;</span><br><span class="line">            que.<span class="built_in">push</span>(-z);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -que.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>周赛</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-1. 两数之和</title>
    <url>/2019/08/20/leetcode/1-100/1.liang-shu-zhi-he/</url>
    <content><![CDATA[<h4 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode-cn.com/problems/two-sum/">1. 两数之和</a></h4><p>思路：用map将目标值-该数的值存下，后面遍历数组发现该值已存在表示找到。</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::iterator ite;</span><br><span class="line">            ite=m.<span class="built_in">find</span>(nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(ite!=m.<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(m[nums[i]]);</span><br><span class="line">                res.<span class="built_in">push_back</span>(i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;  </span><br><span class="line">            m[target-nums[i]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>map</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-10.正则表达式匹配</title>
    <url>/2019/08/21/leetcode/1-100/10.zheng-ze-biao-da-shi-pi-pei/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote>
<p>给你一个字符串 <code>s</code> 和一个字符规律 <code>p</code>，请你来实现一个支持 <code>&#39;.&#39;</code> 和 <code>&#39;*&#39;</code> 的正则表达式匹配。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;.&#x27; 匹配任意单个字符</span><br><span class="line">&#x27;*&#x27; 匹配零个或多个前面的那一个元素</span><br></pre></td></tr></table></figure>

<p>所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。</p>
<p>说明:</p>
<ul>
<li>s 可能为空，且只包含从 a-z 的小写字母。</li>
<li>p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。</li>
</ul>
</blockquote>
<span id="more"></span>

<h4 id="解法-1：动态规划"><a href="#解法-1：动态规划" class="headerlink" title="解法 1：动态规划"></a>解法 1：动态规划</h4><p>1.状态</p>
<p>$dp[i][j]$表示s的前i个字符，p的前j个字符，能否匹配（i&lt;=n,j&lt;=m,n=s.length(),m=p.length())</p>
<p>2.转移方程</p>
<p>1)如果s的第 i 个字符和p的第 j 个字符相同，或者s2的第 j 个字符为 “.” </p>
<p>p[j]==s[i]||p[j]==’.’:dp[i][j]=dp[i-1][j-1]   //如果</p>
<p>2)p[j]==’*’:</p>
<ul>
<li><p>p[j-1]!=s[i]:dp[i][j]=dp[i][j-2]</p>
</li>
<li><p>p[j-1]==s[i]||p[j-1]==’.’:</p>
<ul>
<li>dp[i][j]=dp[i-1][j]// a*与多个a匹配          </li>
<li>dp[i][j]=dp[i][j-1]//a*与一个a匹配     </li>
<li>dp[i][j]=dp[i][j-2]//a*与0个a匹配      </li>
</ul>
</li>
</ul>
<p><em>ps:只写dp[i-1][j]和dp[i][j]也可以，思考一下</em></p>
<p>3.初始化</p>
<p>dp[0][0]=true</p>
<p>dp[0][j]=dp[0][j-2]if(j==’*’)</p>
<p>s的前0个字符和p的前j个字符能否匹配</p>
<p>4.结果</p>
<p>dp[n][m]</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">int</span> m=p.<span class="built_in">length</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">dp</span>(n+<span class="number">1</span>,vector&lt;<span class="keyword">bool</span>&gt;(m+<span class="number">1</span>,<span class="literal">false</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">2</span>;j&lt;=m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j]=dp[<span class="number">0</span>][j<span class="number">-2</span>]&amp;&amp;p[j<span class="number">-1</span>]==<span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(s[i<span class="number">-1</span>]==p[j<span class="number">-1</span>]||p[j<span class="number">-1</span>]==<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">if</span>(p[j<span class="number">-1</span>]==<span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j]=dp[i][j<span class="number">-2</span>]||(p[j<span class="number">-2</span>]==s[i<span class="number">-1</span>]||p[j<span class="number">-2</span>]==<span class="string">&#x27;.&#x27;</span>)&amp;&amp;(dp[i<span class="number">-1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-100. 相同的树</title>
    <url>/2019/10/04/leetcode/1-100/100.xiang-tong-de-shu/</url>
    <content><![CDATA[<p>给定两个二叉树，编写一个函数来检验它们是否相同。</p>
<p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p>
<span id="more"></span>

<p>题目链接：<a href="https://leetcode-cn.com/problems/same-tree/">https://leetcode-cn.com/problems/same-tree/</a> </p>
<h4 id="解法1：dfs"><a href="#解法1：dfs" class="headerlink" title="解法1：dfs"></a>解法1：dfs</h4><p>采用深度优先搜索，各个节点同时比较</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(p,q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(TreeNode *p,TreeNode *q)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p!=<span class="literal">NULL</span>&amp;&amp;q!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;val==q-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">dfs</span>(p-&gt;left,q-&gt;left)&amp;&amp;<span class="built_in">dfs</span>(p-&gt;right,q-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p==<span class="literal">NULL</span>&amp;&amp;q==<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-11.盛最多水的容器</title>
    <url>/2019/08/22/leetcode/1-100/11.sheng-zui-duo-shui-de-rong-qi/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote>
<p>给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
<p>说明：你不能倾斜容器，且 n 的值至少为 2。</p>
</blockquote>
<span id="more"></span>

<p><img src="/../../../images/question_11.jpg" alt="img"></p>
<p>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p>
<h4 id="解法1-双指针"><a href="#解法1-双指针" class="headerlink" title="解法1:双指针"></a>解法1:双指针</h4><p>i从最左端开始往右移，j从最右端开始往左移，直到两指针相遇将过程中所出现的最大值保存</p>
<p>移动<strong>较小</strong>高度段的指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        i=<span class="number">0</span>;j=height.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> s;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(height[i]&lt;height[j])</span><br><span class="line">            &#123;</span><br><span class="line">                s=(j-i)*height[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                s=(j-i)*height[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(max&lt;s)</span><br><span class="line">                max=s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-12. 整数转罗马数字</title>
    <url>/2019/08/22/leetcode/1-100/12.zheng-shu-zhuan-luo-ma-shu-zi/</url>
    <content><![CDATA[<h4 id="12-整数转罗马数字"><a href="#12-整数转罗马数字" class="headerlink" title="12. 整数转罗马数字"></a><a href="https://leetcode-cn.com/problems/integer-to-roman/">12. 整数转罗马数字</a></h4><p>思路：</p>
<p>贪心，尽可能选则大的</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">         <span class="comment">// 把阿拉伯数字与罗马数字可能出现的所有情况和对应关系，放在两个数组中</span></span><br><span class="line">        <span class="comment">// 并且按照阿拉伯数字的大小降序排列，这是贪心选择思想</span></span><br><span class="line">        <span class="keyword">int</span> nums []= &#123;<span class="number">1000</span>, <span class="number">900</span>, <span class="number">500</span>, <span class="number">400</span>, <span class="number">100</span>, <span class="number">90</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        string romans[] = &#123;<span class="string">&quot;M&quot;</span>, <span class="string">&quot;CM&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;CD&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;XC&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;XL&quot;</span>, <span class="string">&quot;X&quot;</span>, <span class="string">&quot;IX&quot;</span>, <span class="string">&quot;V&quot;</span>, <span class="string">&quot;IV&quot;</span>, <span class="string">&quot;I&quot;</span>&#125;;</span><br><span class="line">        string res=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; <span class="number">13</span>) &#123;</span><br><span class="line">            <span class="comment">// 特别注意：这里是等号</span></span><br><span class="line">            <span class="keyword">while</span> (num &gt;= nums[index]) &#123;</span><br><span class="line">                <span class="comment">// 注意：这里是等于号，表示尽量使用大的&quot;面值&quot;</span></span><br><span class="line">                res+=romans[index];</span><br><span class="line">                num -= nums[index];</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>作者：liweiwei1419<br>链接：<a href="https://leetcode-cn.com/problems/integer-to-roman/solution/tan-xin-suan-fa-by-liweiwei1419/">https://leetcode-cn.com/problems/integer-to-roman/solution/tan-xin-suan-fa-by-liweiwei1419/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-13. 罗马数字转整数</title>
    <url>/2019/08/22/leetcode/1-100/13.luo-ma-shu-zi-zhuan-zheng-shu/</url>
    <content><![CDATA[<h4 id="13-罗马数字转整数"><a href="#13-罗马数字转整数" class="headerlink" title="13. 罗马数字转整数"></a><a href="https://leetcode-cn.com/problems/roman-to-integer/">13. 罗马数字转整数</a></h4><p>思路：哈希表</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        map&lt;string,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        m[<span class="string">&quot;I&quot;</span>]=<span class="number">1</span>;</span><br><span class="line">        m[<span class="string">&quot;V&quot;</span>]=<span class="number">5</span>;</span><br><span class="line">        m[<span class="string">&quot;IV&quot;</span>]=<span class="number">4</span>;</span><br><span class="line">        m[<span class="string">&quot;IX&quot;</span>]=<span class="number">9</span>;</span><br><span class="line">        m[<span class="string">&quot;X&quot;</span>]=<span class="number">10</span>;</span><br><span class="line">        m[<span class="string">&quot;XL&quot;</span>]=<span class="number">40</span>;</span><br><span class="line">        m[<span class="string">&quot;L&quot;</span>]=<span class="number">50</span>;</span><br><span class="line">        m[<span class="string">&quot;XC&quot;</span>]=<span class="number">90</span>;</span><br><span class="line">        m[<span class="string">&quot;C&quot;</span>]=<span class="number">100</span>;</span><br><span class="line">        m[<span class="string">&quot;CD&quot;</span>]=<span class="number">400</span>;</span><br><span class="line">        m[<span class="string">&quot;D&quot;</span>]=<span class="number">500</span>;</span><br><span class="line">        m[<span class="string">&quot;CM&quot;</span>]=<span class="number">900</span>;</span><br><span class="line">        m[<span class="string">&quot;M&quot;</span>]=<span class="number">1000</span>;</span><br><span class="line">        i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;s.<span class="built_in">length</span>();)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((i&lt;s.<span class="built_in">length</span>()<span class="number">-1</span>)&amp;&amp;(m.<span class="built_in">find</span>(s.<span class="built_in">substr</span>(i,<span class="number">2</span>))!=m.<span class="built_in">end</span>()))</span><br><span class="line">            &#123;</span><br><span class="line">                sum+=m[s.<span class="built_in">substr</span>(i,<span class="number">2</span>)];</span><br><span class="line">                i+=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                sum+=m[s.<span class="built_in">substr</span>(i,<span class="number">1</span>)];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-14. 最长公共前缀</title>
    <url>/2019/08/22/leetcode/1-100/14.zui-chang-gong-gong-qian-zhui/</url>
    <content><![CDATA[<h4 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14. 最长公共前缀"></a><a href="https://leetcode-cn.com/problems/longest-common-prefix/">14. 最长公共前缀</a></h4><p>思路：暴力</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestCommonPrefix</span><span class="params">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        string s=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(strs.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;strs[<span class="number">0</span>].<span class="built_in">length</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;strs.<span class="built_in">size</span>();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(strs[j][i]!=strs[<span class="number">0</span>][i])</span><br><span class="line">                    <span class="keyword">return</span> s;</span><br><span class="line">            &#125;</span><br><span class="line">            s+=strs[<span class="number">0</span>].<span class="built_in">substr</span>(i,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-15.三数之和</title>
    <url>/2021/10/26/leetcode/1-100/15.san-shu-zhi-he/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote>
<p>给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。</p>
<p>例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，</p>
<p>满足要求的三元组集合为：<br>[<br>  [-1, 0, 1],<br>  [-1, -1, 2]<br>]</p>
</blockquote>
<span id="more"></span>

<h4 id="解法1：双指针法"><a href="#解法1：双指针法" class="headerlink" title="解法1：双指针法"></a>解法1：双指针法</h4><p>1.排序，先将nums排序</p>
<p>2.固定3个指针中最左（小）数字指针k，双指针i，j分别在数组索引[k+1,nums.length()-1]两端，通过双指针交替向中间移动，记录对于固定指针k的所有满足nums[k]+nums[i]+nums[j]=0的i,j组合：</p>
<ol>
<li>当nums[k]&gt;0时直接跳出:因为nums[j]&gt;=nums[i]&gt;=nums[k]&gt;0,3数之和必然不可能为0，在k之后也不可能再找到结果了。</li>
<li>当k&gt;0且nums[k]==nums[k-1]时即跳过此元素nums[k]：因为已经将nums[k-1]的所有组合加入到结果中。</li>
<li>当i&lt;j时循环计算s=nums[k]+nums[i]+nums[j],并按照下列规则进行移动:<ul>
<li>当s&lt;0时，i+=1并跳过所有重复的nums[i],</li>
<li>当s&gt;0时，j-=1并跳过所有重复的nums[j],</li>
<li>当s==0时，记录组合[k,i,j]至res，并执行i+=1,j-=1并跳过所有重复的nums[i]和nums[j],防止记录重复组合</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> s;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()&lt;=<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        i=<span class="number">0</span>;j=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>||nums[j]&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">for</span>(;k&lt;nums.<span class="built_in">size</span>()<span class="number">-2</span>;k++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[k]&gt;<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(k&gt;<span class="number">0</span>&amp;&amp;nums[k]==nums[k<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            i=k+<span class="number">1</span>;</span><br><span class="line">            j=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;j)</span><br><span class="line">            &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(nums[j]&lt;<span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                s=nums[k]+nums[i]+nums[j];</span><br><span class="line">                <span class="keyword">if</span>(s==<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(vector&lt;<span class="keyword">int</span>&gt;&#123;nums[k],nums[i],nums[j]&#125;);</span><br><span class="line">                    i++;</span><br><span class="line">                    <span class="keyword">while</span>(nums[i]==nums[i<span class="number">-1</span>]&amp;&amp;i&lt;j)</span><br><span class="line">                        i++;</span><br><span class="line">                    j--;</span><br><span class="line">                    <span class="keyword">while</span>(nums[j]==nums[j+<span class="number">1</span>]&amp;&amp;i&lt;j)</span><br><span class="line">                        j--;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(s&lt;<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                    <span class="keyword">while</span>(nums[i]==nums[i<span class="number">-1</span>]&amp;&amp;i&lt;j)</span><br><span class="line">                        i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    j--;</span><br><span class="line">                    <span class="keyword">while</span>(nums[j]==nums[j+<span class="number">1</span>]&amp;&amp;i&lt;j)</span><br><span class="line">                        j--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>复杂度分析：<br>1)：时间复杂度 O($N^2$)<br>2 )：其中固定指针k循环复杂度 O(N)，双指针 i，j 复杂度 O(N)。<br>空间复杂度 O(1)：指针使用常数大小的额外空间。</p>
]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-16.最接近的三数之和</title>
    <url>/2021/10/26/leetcode/1-100/16.zui-jie-jin-de-san-shu-zhi-he/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote>
<p>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p>
<p>例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.</p>
<p>与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).</p>
</blockquote>
<span id="more"></span>

<h4 id="解法1：双指针法"><a href="#解法1：双指针法" class="headerlink" title="解法1：双指针法"></a>解法1：双指针法</h4><p>思路与Leetcode-15题基本类似</p>
<p>添加max变量，max为距离最近目标值的差值，始终为正</p>
<p>添加代码m=nums[k]+nums[i]+nums[j]</p>
<p>temp=m-target</p>
<p>1.temp==0即找到等于目标值的组合，直接返回target</p>
<p>2.temp&lt;0     当max&gt;-temp 即当前离目标值更近，更新max为-temp，res为m</p>
<p>3.temp&gt;0    当max&gt;temp 即当前离目标值更近 , 更新max为temp,res为m</p>
<p>其他与15题相同</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max=INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">int</span> m;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()&lt;=<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(;k&lt;nums.<span class="built_in">size</span>()<span class="number">-2</span>;k++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(k&gt;<span class="number">0</span>&amp;&amp;nums[k]==nums[k<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            i=k+<span class="number">1</span>;</span><br><span class="line">            j=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;j)</span><br><span class="line">            &#123;</span><br><span class="line">                m=nums[k]+nums[i]+nums[j];</span><br><span class="line">                temp=m-target;</span><br><span class="line">                <span class="keyword">if</span>(temp==<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> target;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(temp&lt;<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span>(max&gt;-temp)</span><br><span class="line">                    &#123;</span><br><span class="line">                        max=-temp;</span><br><span class="line">                        res=m;</span><br><span class="line">                    &#125;</span><br><span class="line">                    i++;</span><br><span class="line">                    <span class="keyword">while</span>(nums[i]==nums[i<span class="number">-1</span>]&amp;&amp;i&lt;j)</span><br><span class="line">                        i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(max&gt;temp)</span><br><span class="line">                    &#123;</span><br><span class="line">                        max=temp;</span><br><span class="line">                        res=m;</span><br><span class="line">                    &#125;</span><br><span class="line">                    j--;</span><br><span class="line">                    <span class="keyword">while</span>(nums[j]==nums[j+<span class="number">1</span>]&amp;&amp;i&lt;j)</span><br><span class="line">                        j--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-17.电话号码的字母组合</title>
    <url>/2021/10/26/leetcode/1-100/17.dian-hua-hao-ma-de-zi-mu-zu-he/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote>
<p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p>示例:</p>
<p>输入：”23”<br>输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].<br>说明:<br>尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。</p>
</blockquote>
<span id="more"></span>

<p><img src="/../../images/17_telephone_keypad.png" alt="1566573388338"></p>
<h4 id="解法1：回溯法"><a href="#解法1：回溯法" class="headerlink" title="解法1：回溯法"></a>解法1：回溯法</h4><p>构建Map，从头遍历目标字符串</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="keyword">char</span>,string&gt; m;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(digits.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        m[<span class="string">&#x27;2&#x27;</span>]=<span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        m[<span class="string">&#x27;3&#x27;</span>]=<span class="string">&quot;def&quot;</span>;</span><br><span class="line">        m[<span class="string">&#x27;4&#x27;</span>]=<span class="string">&quot;ghi&quot;</span>;</span><br><span class="line">        m[<span class="string">&#x27;5&#x27;</span>]=<span class="string">&quot;jkl&quot;</span>;</span><br><span class="line">        m[<span class="string">&#x27;6&#x27;</span>]=<span class="string">&quot;mno&quot;</span>;</span><br><span class="line">        m[<span class="string">&#x27;7&#x27;</span>]=<span class="string">&quot;pqrs&quot;</span>;</span><br><span class="line">        m[<span class="string">&#x27;8&#x27;</span>]=<span class="string">&quot;tuv&quot;</span>;</span><br><span class="line">        m[<span class="string">&#x27;9&#x27;</span>]=<span class="string">&quot;wxyz&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        i=<span class="number">0</span>;</span><br><span class="line">        string temp;</span><br><span class="line">        <span class="built_in">Maps</span>(i,m,res,digits,temp);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Maps</span><span class="params">(<span class="keyword">int</span> i,map&lt;<span class="keyword">char</span>,string&gt;&amp; m,vector&lt;string&gt;&amp; res,string digits,string temp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;digits.<span class="built_in">length</span>())</span><br><span class="line">    &#123;</span><br><span class="line">    string s1=m[digits[i]];</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;s1.<span class="built_in">length</span>();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            temp+=s1.<span class="built_in">substr</span>(j,<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">Maps</span>(i+<span class="number">1</span>,m,res,digits,temp);</span><br><span class="line">            temp=temp.<span class="built_in">substr</span>(<span class="number">0</span>,temp.<span class="built_in">length</span>()<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>map</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-18. 四数之和</title>
    <url>/2019/08/22/leetcode/1-100/18.si-shu-zhi-he/</url>
    <content><![CDATA[<h4 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a><a href="https://leetcode-cn.com/problems/4sum/">18. 四数之和</a></h4><p>思路：与三数之和相同，采用双指针</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">int</span> k;</span><br><span class="line">        <span class="keyword">int</span> k1;</span><br><span class="line">        <span class="keyword">int</span> s;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()&lt;=<span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;nums.<span class="built_in">size</span>()<span class="number">-3</span>;k++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[k]&gt;target&amp;&amp;target&gt;=<span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(k&gt;<span class="number">0</span>&amp;&amp;nums[k]==nums[k<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(k1=k+<span class="number">1</span>;k1&lt;nums.<span class="built_in">size</span>()<span class="number">-2</span>;k1++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(k1&gt;k+<span class="number">1</span>&amp;&amp;nums[k1]==nums[k1<span class="number">-1</span>])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                i=k1+<span class="number">1</span>;</span><br><span class="line">                j=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">while</span>(i&lt;j)</span><br><span class="line">                &#123;</span><br><span class="line">                    s=nums[k]+nums[k1]+nums[i]+nums[j]-target;</span><br><span class="line">                    <span class="keyword">if</span>(s==<span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        res.<span class="built_in">push_back</span>(vector&lt;<span class="keyword">int</span>&gt;&#123;nums[k],nums[k1],nums[i],nums[j]&#125;);</span><br><span class="line">                        i++;</span><br><span class="line">                        <span class="keyword">while</span>(nums[i]==nums[i<span class="number">-1</span>]&amp;&amp;i&lt;j)</span><br><span class="line">                            i++;</span><br><span class="line">                        j--;</span><br><span class="line">                        <span class="keyword">while</span>(nums[j]==nums[j+<span class="number">1</span>]&amp;&amp;i&lt;j)</span><br><span class="line">                            j--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(s&lt;<span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        i++;</span><br><span class="line">                        <span class="keyword">while</span>(nums[i]==nums[i<span class="number">-1</span>]&amp;&amp;i&lt;j)</span><br><span class="line">                            i++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> </span><br><span class="line">                    &#123;</span><br><span class="line">                        j--;</span><br><span class="line">                        <span class="keyword">while</span>(nums[j]==nums[j+<span class="number">1</span>]&amp;&amp;i&lt;j)</span><br><span class="line">                            j--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-19.删除链表的倒数第N个节点</title>
    <url>/2019/08/24/leetcode/1-100/19.shan-chu-lian-biao-de-dao-shu-di-n-ge-jie-dian/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote>
<p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p>
<p>示例：</p>
<p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.</p>
<p>当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.<br>说明：</p>
<p>给定的 n 保证是有效的。</p>
<p>进阶：</p>
<p>你能尝试使用一趟扫描实现吗？</p>
</blockquote>
<span id="more"></span>

<h4 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h4><ul>
<li><p>思路：先让指针移动n步，之后前后指针共同移动，直到前指针到尾部</p>
</li>
<li><p>两指针首先都为头指针head</p>
</li>
<li><p>若首先移动的指针n步到达尾部，表明删除的是第1个节点，即直接返回head=head-&gt;next即可</p>
</li>
<li><p>若未到达尾部，两指针移动，直到前指针的下一节点为NULL，则后指针的下一位就是要删除的节点，返回head</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s=<span class="number">0</span>;</span><br><span class="line">        ListNode *p=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        p=head;</span><br><span class="line">        ListNode *p1=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        p1=head;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            p1=p1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p1==<span class="literal">NULL</span>)</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(p1-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                p=p-&gt;next;</span><br><span class="line">                p1=p1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            p-&gt;next=p-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-2. 两数相加</title>
    <url>/2019/08/20/leetcode/1-100/2.liang-shu-xiang-jia/</url>
    <content><![CDATA[<h4 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a><a href="https://leetcode-cn.com/problems/add-two-numbers/">2. 两数相加</a></h4><p>注意处理长度不等的情况</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode *m=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        ListNode *p=m;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> con=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="literal">NULL</span>||l2!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(l1!=<span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sum+=l1-&gt;val;</span><br><span class="line">                l1=l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l2!=<span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sum+=l2-&gt;val;</span><br><span class="line">                l2=l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            sum+=con;</span><br><span class="line">            con=sum/<span class="number">10</span>;</span><br><span class="line">            sum=sum%<span class="number">10</span>;</span><br><span class="line">            p-&gt;next=<span class="keyword">new</span> <span class="built_in">ListNode</span>(sum);</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">            sum=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(con!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;next=<span class="keyword">new</span> <span class="built_in">ListNode</span>(con);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-20.有限的括号</title>
    <url>/2019/08/24/leetcode/1-100/20.you-xiao-de-gua-hao/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote>
<p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。</p>
</blockquote>
<span id="more"></span>

<p>示例 1:</p>
<p>输入: “()”<br>输出: true<br>示例 2:</p>
<p>输入: “()[]{}”<br>输出: true<br>示例 3:</p>
<p>输入: “(]”<br>输出: false<br>示例 4:</p>
<p>输入: “([)]”<br>输出: false<br>示例 5:</p>
<p>输入: “{[]}”<br>输出: true</p>
<h4 id="解法1：栈"><a href="#解法1：栈" class="headerlink" title="解法1：栈"></a>解法1：栈</h4><p>通常匹配问题可以通过栈来解决</p>
<p>遍历字符串当为左括号时，放入对应右括号,</p>
<p>如为’(‘  放入’)’</p>
<p>当为右括号时，与栈顶比较，若不相等或栈为空（右括号比左括号多）返回false </p>
<p>遍历完毕，判断栈是否为空，若为空返回true，若不为空（左括号比右括号多）返回false；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="keyword">char</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                res.<span class="built_in">push</span>(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">                res.<span class="built_in">push</span>(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">                res.<span class="built_in">push</span>(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(res.<span class="built_in">empty</span>()||res.<span class="built_in">top</span>()!=s[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                res.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-21. 合并两个有序链表</title>
    <url>/2019/08/24/leetcode/1-100/21.he-bing-liang-ge-you-xu-lian-biao/</url>
    <content><![CDATA[<h4 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a></h4><p>思路：</p>
<p>建一个新链表头指针，顺序比较俩链表各节点大小</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode *l=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        ListNode *m=l;</span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="literal">NULL</span>&amp;&amp;l2!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val&gt;l2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                ListNode *p=<span class="keyword">new</span> <span class="built_in">ListNode</span>(l2-&gt;val);</span><br><span class="line">                l2=l2-&gt;next;</span><br><span class="line">                m-&gt;next=p;</span><br><span class="line">                m=m-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ListNode *p=<span class="keyword">new</span> <span class="built_in">ListNode</span>(l1-&gt;val);</span><br><span class="line">                l1=l1-&gt;next;</span><br><span class="line">                m-&gt;next=p;</span><br><span class="line">                m=m-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *p=<span class="keyword">new</span> <span class="built_in">ListNode</span>(l1-&gt;val);</span><br><span class="line">            l1=l1-&gt;next;</span><br><span class="line">            m-&gt;next=p;</span><br><span class="line">            m=m-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l2!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *p=<span class="keyword">new</span> <span class="built_in">ListNode</span>(l2-&gt;val);</span><br><span class="line">            l2=l2-&gt;next;</span><br><span class="line">            m-&gt;next=p;</span><br><span class="line">            m=m-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        l=l-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> m;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-22.括号生成</title>
    <url>/2019/08/24/leetcode/1-100/22.gua-hao-sheng-cheng/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote>
<p>给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。</p>
<p>例如，给出 n = 3，生成结果为：</p>
<p>[<br>  “((()))”,<br>  “(()())”,<br>  “(())()”,<br>  “()(())”,<br>  “()()()”<br>]</p>
</blockquote>
<span id="more"></span>

<h4 id="解法1：回溯"><a href="#解法1：回溯" class="headerlink" title="解法1：回溯"></a>解法1：回溯</h4><p>只有在我们知道序列仍然保持有效时才添加 ‘(‘ or ‘)’。我们可以通过跟踪到目前为止放置的左括号和右括号的数目来做到这一点。</p>
<p>如果我们还剩一个位置，我们可以开始放一个左括号。 如果它不超过左括号的数量，我们可以放一个右括号。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">backtrack</span>(<span class="string">&quot;&quot;</span>,<span class="number">0</span>,<span class="number">0</span>,n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(string temp,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp.<span class="built_in">length</span>()==n*<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left&lt;n)</span><br><span class="line">            <span class="built_in">backtrack</span>(temp+<span class="string">&#x27;(&#x27;</span>,left+<span class="number">1</span>,right,n);</span><br><span class="line">        <span class="keyword">if</span>(right&lt;left)</span><br><span class="line">            <span class="built_in">backtrack</span>(temp+<span class="string">&#x27;)&#x27;</span>,left,right+<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="解法2：闭合法"><a href="#解法2：闭合法" class="headerlink" title="解法2：闭合法"></a>解法2：闭合法</h4><p>思路</p>
<p>为了枚举某些内容，我们通常希望将其表示为更容易计算的不相交子集的总和。</p>
<p>考虑有效括号序列 S 的 闭包数：至少存在 index &gt;= 0，使得 S[0], S[1], …, S[2*index+1]是有效的。 显然，每个括号序列都有一个唯一的闭包号。 我们可以尝试单独列举它们。</p>
<p>算法</p>
<p>对于每个闭合数 c，我们知道起始和结束括号必定位于索引 0 和 2<em>c + 1。然后两者间的 2</em>c 个元素一定是有效序列，其余元素一定是有效序列。</p>
<p>作者：LeetCode<br>链接：<a href="https://leetcode-cn.com/problems/generate-parentheses/solution/gua-hao-sheng-cheng-by-leetcode/">https://leetcode-cn.com/problems/generate-parentheses/solution/gua-hao-sheng-cheng-by-leetcode/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">            ans.<span class="built_in">push_back</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> a=<span class="number">0</span>;a&lt;n;a++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(string left:<span class="built_in">generateParenthesis</span>(a))</span><br><span class="line">                    <span class="keyword">for</span>(string right:<span class="built_in">generateParenthesis</span>(n<span class="number">-1</span>-a))</span><br><span class="line">                        ans.<span class="built_in">push_back</span>(<span class="string">&quot;(&quot;</span>+left+<span class="string">&quot;)&quot;</span>+right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-23.合并K个链表</title>
    <url>/2019/08/26/leetcode/1-100/23.he-bing-k-ge-lian-biao/</url>
    <content><![CDATA[<blockquote>
<p>合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p>
<p>示例:</p>
<p>输入:<br>[<br>  1-&gt;4-&gt;5,<br>  1-&gt;3-&gt;4,<br>  2-&gt;6<br>]<br>输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</p>
</blockquote>
<span id="more"></span>

<h4 id="解法1：挨个插入（笨方法）"><a href="#解法1：挨个插入（笨方法）" class="headerlink" title="解法1：挨个插入（笨方法）"></a>解法1：挨个插入（笨方法）</h4><p>将所有节点插入到第一个链表中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">int</span> n=lists.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">        ListNode *p=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            p=lists[i];</span><br><span class="line">            ListNode *pm=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">            ListNode *pa=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">            pm=lists[<span class="number">0</span>];</span><br><span class="line">            pa-&gt;next=lists[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;pm!=<span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(p-&gt;val&lt;pm-&gt;val)</span><br><span class="line">                &#123;</span><br><span class="line">                    ListNode *temp=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">                    <span class="keyword">if</span>(p-&gt;val&lt;lists[<span class="number">0</span>]-&gt;val)</span><br><span class="line">                    &#123;</span><br><span class="line">                        temp=p;</span><br><span class="line">                        p=p-&gt;next;</span><br><span class="line">                        temp-&gt;next=lists[<span class="number">0</span>];</span><br><span class="line">                        lists[<span class="number">0</span>]=temp;</span><br><span class="line">                        pa=lists[<span class="number">0</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        temp=p;</span><br><span class="line">                        p=p-&gt;next;</span><br><span class="line">                        temp-&gt;next=pm;</span><br><span class="line">                        pa-&gt;next=temp;</span><br><span class="line">                        pa=pa-&gt;next;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    pm=pm-&gt;next;</span><br><span class="line">                    pa=pa-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pm==<span class="literal">NULL</span>&amp;&amp;lists[<span class="number">0</span>]!=<span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                pa-&gt;next=p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(pm==<span class="literal">NULL</span>&amp;&amp;lists[<span class="number">0</span>]==<span class="literal">NULL</span>)</span><br><span class="line">                lists[<span class="number">0</span>]=p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：KN</p>
<h4 id="解法2：优先级队列"><a href="#解法2：优先级队列" class="headerlink" title="解法2：优先级队列"></a>解法2：优先级队列</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cmp</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(ListNode* l1, ListNode* l2)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> l1-&gt;val &gt; l2-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span></span>&#123;</span><br><span class="line">        ListNode* phead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        ListNode* p = phead;</span><br><span class="line">        <span class="keyword">if</span>(lists.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, cmp&gt; MinHeap;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; lists.<span class="built_in">size</span>();i++) </span><br><span class="line">            <span class="keyword">if</span>(lists[i] != <span class="literal">nullptr</span>)</span><br><span class="line">                MinHeap.<span class="built_in">push</span>(lists[i]);</span><br><span class="line">        <span class="keyword">while</span>(!MinHeap.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;next = MinHeap.<span class="built_in">top</span>();</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(MinHeap.<span class="built_in">top</span>()-&gt;next != <span class="literal">nullptr</span>) </span><br><span class="line">                MinHeap.<span class="built_in">push</span>(MinHeap.<span class="built_in">top</span>()-&gt;next);</span><br><span class="line">            MinHeap.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> phead-&gt;next;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：NlogK</p>
]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-24. 两两交换链表中的节点</title>
    <url>/2019/08/24/leetcode/1-100/24.liang-liang-jiao-huan-lian-biao-zhong-de-jie-dian/</url>
    <content><![CDATA[<h4 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a></h4><p>思路：</p>
<p>直接套用25题模板</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        stack&lt;ListNode *&gt; s;</span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        ListNode *p=head;</span><br><span class="line">        ListNode *pre=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        ListNode *pr=pre;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            count=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(count&lt;k&amp;&amp;p!=<span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                s.<span class="built_in">push</span>(p);</span><br><span class="line">                p=p-&gt;next;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count&lt;k)</span><br><span class="line">            &#123;</span><br><span class="line">                pr-&gt;next=head;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                ListNode *temp=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">                temp=s.<span class="built_in">top</span>();</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                pr-&gt;next=temp;</span><br><span class="line">                pr=pr-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            pr-&gt;next=p;</span><br><span class="line">            head=p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-26.删除排序数组中的重复项</title>
    <url>/2019/08/26/leetcode/1-100/26.shan-chu-pai-xu-shu-zu-zhong-de-chong-fu-xiang/</url>
    <content><![CDATA[<blockquote>
<p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p>
</blockquote>
<span id="more"></span>

<p>示例 1:</p>
<p>给定数组 nums = [1,1,2], </p>
<p>函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </p>
<p>你不需要考虑数组中超出新长度后面的元素。<br>示例 2:</p>
<p>给定 nums = [0,0,1,1,1,2,2,3,3,4],</p>
<p>函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</p>
<p>你不需要考虑数组中超出新长度后面的元素。</p>
<h4 id="解法：双指针法"><a href="#解法：双指针法" class="headerlink" title="解法：双指针法"></a>解法：双指针法</h4><p>一个指针i遍历数组,一个指针len存当前有多少个不重复的元素</p>
<p>当前指针元素等于len位置元素表示这是重复元素，进行下一循环</p>
<p>当前指针元素不等于len位置元素表示这是个新元素，len+1位置放入新元素</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=nums[len<span class="number">-1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                nums[len]=nums[i];</span><br><span class="line">                len++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-27.移除元素</title>
    <url>/2019/08/27/leetcode/1-100/27.yi-chu-yuan-su/</url>
    <content><![CDATA[<blockquote>
<p>给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
</blockquote>
<span id="more"></span>

<h4 id="解法：双指针"><a href="#解法：双指针" class="headerlink" title="解法：双指针"></a>解法：双指针</h4><p>i指针遍历数组，len指针表示当前有多少位值不等于val的元素</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=val)</span><br><span class="line">            &#123;</span><br><span class="line">                nums[len]=nums[i];</span><br><span class="line">                len++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-25.K个一组翻转链表</title>
    <url>/2019/08/26/leetcode/1-100/25.k-ge-yi-zu-fan-zhuan-lian-biao/</url>
    <content><![CDATA[<blockquote>
<p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</p>
<p>k 是一个正整数，它的值小于或等于链表的长度。</p>
<p>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p>
<p>示例 :</p>
<p>给定这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5</p>
<p>当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5</p>
<p>当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5</p>
<p>说明 :</p>
<p>你的算法只能使用常数的额外空间。<br>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
</blockquote>
<span id="more"></span>

<h4 id="解法1：利用栈"><a href="#解法1：利用栈" class="headerlink" title="解法1：利用栈"></a>解法1：利用栈</h4><p>利用栈进行翻转，新链表是翻转后的链表，</p>
<p>若最后栈内节点小于K直接让新链表的尾指针指向最后一组的头节点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        stack&lt;ListNode *&gt; s;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        ListNode *p=head;</span><br><span class="line">        ListNode *pre=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        ListNode *pr=pre;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            count=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(count&lt;k&amp;&amp;p!=<span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                s.<span class="built_in">push</span>(p);</span><br><span class="line">                p=p-&gt;next;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count&lt;k)</span><br><span class="line">            &#123;</span><br><span class="line">                pr-&gt;next=head;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                ListNode *temp=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">                temp=s.<span class="built_in">top</span>();</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                pr-&gt;next=temp;</span><br><span class="line">                pr=pr-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            pr-&gt;next=p;</span><br><span class="line">            head=p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-28.实现strStr()</title>
    <url>/2019/08/27/leetcode/1-100/28.shi-xian-strstr/</url>
    <content><![CDATA[<blockquote>
<p>实现 strStr() 函数。</p>
<p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。</p>
<p>示例 1:</p>
<p>输入: haystack = “hello”, needle = “ll”<br>输出: 2<br>示例 2:</p>
<p>输入: haystack = “aaaaa”, needle = “bba”<br>输出: -1<br>说明:</p>
<p>当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。</p>
<p>对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。</p>
</blockquote>
<span id="more"></span>

<h4 id="解法1：BF-暴力"><a href="#解法1：BF-暴力" class="headerlink" title="解法1：BF(暴力)"></a>解法1：BF(暴力)</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(needle.<span class="built_in">length</span>()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(haystack.<span class="built_in">length</span>()&lt;needle.<span class="built_in">length</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=haystack.<span class="built_in">length</span>()-needle.<span class="built_in">length</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            k=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(haystack[i]==needle[<span class="number">0</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;needle.<span class="built_in">length</span>();j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(haystack[i+j]!=needle[j])</span><br><span class="line">                    &#123;    </span><br><span class="line">                      k=<span class="number">1</span>;</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(k==<span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(M*N)</p>
<h4 id="解法2：KMP"><a href="#解法2：KMP" class="headerlink" title="解法2：KMP"></a>解法2：KMP</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> hn=haystack.<span class="built_in">length</span>(),nn=needle.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">if</span>(nn==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">next</span><span class="params">(nn)</span></span>;</span><br><span class="line">        next[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;nn<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(k==<span class="number">-1</span>||needle[k]==needle[j])</span><br><span class="line">            &#123;</span><br><span class="line">                k++;</span><br><span class="line">                j++;</span><br><span class="line">                </span><br><span class="line">                    next[j]=k;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                k=next[k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;hn&amp;&amp;j&lt;nn)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j==<span class="number">-1</span>||haystack[i]==needle[j])</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                j=next[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j==nn)</span><br><span class="line">            <span class="keyword">return</span> i-j;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度:O(N+M)</p>
<h4 id="解法3：KMP-优化next数组"><a href="#解法3：KMP-优化next数组" class="headerlink" title="解法3：KMP(优化next数组)"></a>解法3：KMP(优化next数组)</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> hn=haystack.<span class="built_in">length</span>(),nn=needle.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">if</span>(nn==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">next</span><span class="params">(nn)</span></span>;</span><br><span class="line">        next[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;nn<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(k==<span class="number">-1</span>||needle[k]==needle[j])</span><br><span class="line">            &#123;</span><br><span class="line">                k++;</span><br><span class="line">                j++;</span><br><span class="line">                <span class="keyword">if</span>(needle[k]!=needle[j])</span><br><span class="line">                    next[j]=k;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    next[j]=next[k];</span><br><span class="line">                &#125;                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                k=next[k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;hn&amp;&amp;j&lt;nn)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j==<span class="number">-1</span>||haystack[i]==needle[j])</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                j=next[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j==nn)</span><br><span class="line">            <span class="keyword">return</span> i-j;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="解法4：BM"><a href="#解法4：BM" class="headerlink" title="解法4：BM"></a>解法4：BM</h4><h4 id="解法5：Sunday"><a href="#解法5：Sunday" class="headerlink" title="解法5：Sunday"></a>解法5：Sunday</h4>]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-29.两数相除</title>
    <url>/2019/08/27/leetcode/1-100/29.liang-shu-xiang-chu/</url>
    <content><![CDATA[<p>给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。</p>
<p>返回被除数 dividend 除以除数 divisor 得到的商。</p>
<p>示例 1:</p>
<p>输入: dividend = 10, divisor = 3<br>输出: 3<br>示例 2:</p>
<p>输入: dividend = 7, divisor = -3<br>输出: -2<br>说明:</p>
<p>被除数和除数均为 32 位有符号整数。<br>除数不为 0。<br>假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2^31,  2^31 − 1]。本题中，如果除法结果溢出，则返回 2^31 − 1。</p>
<span id="more"></span>

<h4 id="解法：位运算"><a href="#解法：位运算" class="headerlink" title="解法：位运算"></a>解法：位运算</h4><p>商s=0,信号量sign=(dividend&gt;0)^(divisor&gt;0) 判断s的最终符号</p>
<p>两层循环，第一层循环当 <strong>当前被除数Idividend大于除数Idivisor</strong> 时，初始增量i=1，中间除数temp初始为除数Idivisor</p>
<p>第二层循环当 <strong>当前被除数Idividend大于当前除数temp</strong> 时， 当前被除数Idividend-=temp ，s+=i;i左移1位，temp左移1位</p>
<p>一种种特殊情况</p>
<ul>
<li>当Idividend=INT_MIN Idivisor==-1时 直接返回INT_MAX</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> s=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sign;</span><br><span class="line">        <span class="keyword">if</span>(dividend==INT_MIN&amp;&amp;divisor==<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> INT_MAX;</span><br><span class="line">        <span class="keyword">if</span>(divisor==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> dividend;</span><br><span class="line">        <span class="keyword">if</span>(divisor==<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> -dividend;</span><br><span class="line">        sign=(dividend&gt;<span class="number">0</span>)^(divisor&gt;<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> Idividend=<span class="built_in">abs</span>((<span class="keyword">long</span> <span class="keyword">long</span>)dividend);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> Idivisor=<span class="built_in">abs</span>((<span class="keyword">long</span> <span class="keyword">long</span>)divisor);</span><br><span class="line">        <span class="keyword">while</span>(Idividend&gt;=Idivisor)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> temp=Idivisor;</span><br><span class="line">            <span class="keyword">while</span>(Idividend&gt;=temp)</span><br><span class="line">            &#123;</span><br><span class="line">                Idividend-=temp;</span><br><span class="line">                s+=i;</span><br><span class="line">                i&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">                temp&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sign==<span class="number">1</span>) s=-s;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-3. 无重复字符的最长子串</title>
    <url>/2019/08/20/leetcode/1-100/3.wu-chong-fu-zi-fu-de-zui-chang-zi-chuan/</url>
    <content><![CDATA[<h4 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h4><p>思路：</p>
<p>采用滑动窗口,左指针记录窗口内无重复字符时的左边界,不断移动右指针,找到最大符合窗口</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        unordered_set&lt;<span class="keyword">char</span>&gt; lookup;</span><br><span class="line">        <span class="keyword">int</span> maxStr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">while</span> (lookup.<span class="built_in">find</span>(s[i]) != lookup.<span class="built_in">end</span>())&#123;</span><br><span class="line">                lookup.<span class="built_in">erase</span>(s[left]);</span><br><span class="line">                left ++;</span><br><span class="line">            &#125;</span><br><span class="line">            maxStr = <span class="built_in">max</span>(maxStr,i-left+<span class="number">1</span>);</span><br><span class="line">            lookup.<span class="built_in">insert</span>(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> maxStr;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-31.下一个排列</title>
    <url>/2019/08/29/leetcode/1-100/31.xia-yi-ge-pai-lie/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p>
<p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p>
<p>必须原地修改，只允许使用额外常数空间。</p>
<span id="more"></span>

<p>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。<br>1,2,3 → 1,3,2<br>3,2,1 → 1,2,3<br>1,1,5 → 1,5,1</p>
<h4 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h4><p>思路：</p>
<p>1.从右向左找到第一个索引i-1满足nums[i]&gt;nums[i-1]</p>
<p>2.再从右向左找到第一个索引j满足nums[j]&gt;nums[i-1]</p>
<p>3.交换nums[j],nums[i-1]</p>
<p>4.翻转i-1到最后的数组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> right;</span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i<span class="number">-1</span>]&lt;nums[i])</span><br><span class="line">            &#123;</span><br><span class="line">                left=i<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left!=<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">for</span>(j=n<span class="number">-1</span>;j&gt;left;j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j]&gt;nums[i<span class="number">-1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    right=j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">swap</span>(nums[left],nums[right]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>()+left+<span class="number">1</span>,nums.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-30.串联所有单词的字串</title>
    <url>/2019/08/28/leetcode/1-100/30.chuan-lian-suo-you-dan-ci-de-zi-chuan/</url>
    <content><![CDATA[<p>给定一个字符串 s 和一些长度相同的单词 words。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。</p>
<p>注意子串要与 words 中的单词完全匹配，中间不能有其他字符，但不需要考虑 words 中单词串联的顺序。</p>
<p> <span id="more"></span></p>
<p>示例 1：</p>
<p>输入：<br>  s = “barfoothefoobarman”,<br>  words = [“foo”,”bar”]<br>输出：[0,9]<br>解释：<br>从索引 0 和 9 开始的子串分别是 “barfoor” 和 “foobar” 。<br>输出的顺序不重要, [9,0] 也是有效答案。<br>示例 2：</p>
<p>输入：<br>  s = “wordgoodgoodgoodbestword”,<br>  words = [“word”,”good”,”best”,”word”]<br>输出：[]</p>
<h4 id="解法1：滑动窗口"><a href="#解法1：滑动窗口" class="headerlink" title="解法1：滑动窗口"></a>解法1：滑动窗口</h4><p>普通滑动窗口</p>
<p>思路：</p>
<ul>
<li>1.用hashmap将words中的所有单词个数记录</li>
<li>2.遍历s字符串，找到符合的连续子串记录起始位置</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">findSubstring</span><span class="params">(string s, vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(words.<span class="built_in">size</span>()&lt;<span class="number">1</span>||s.<span class="built_in">size</span>()&lt;<span class="number">1</span>||words[<span class="number">0</span>].<span class="built_in">size</span>()*words.<span class="built_in">size</span>()&gt;s.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> wordlen=words[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> len=wordlen*words.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;string,<span class="keyword">int</span>&gt; hashmapword;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;words.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            hashmapword[words[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>()-len+<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="function">unordered_map&lt;string,<span class="keyword">int</span>&gt; <span class="title">hashmaps</span><span class="params">(hashmapword)</span></span>;</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;words.<span class="built_in">size</span>();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                string str=s.<span class="built_in">substr</span>(i+j*words[<span class="number">0</span>].<span class="built_in">size</span>(),words[<span class="number">0</span>].<span class="built_in">size</span>());</span><br><span class="line">                <span class="keyword">if</span>(hashmaps[str]==<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    hashmaps.<span class="built_in">clear</span>();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                hashmaps[str]--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j==words.<span class="built_in">size</span>())</span><br><span class="line">                res.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="解法2：优化的滑动窗口"><a href="#解法2：优化的滑动窗口" class="headerlink" title="解法2：优化的滑动窗口"></a>解法2：优化的滑动窗口</h4><p>我们发现其中有很多不必要的步骤可以简化，</p>
<p>在解法1中我们每次都是移动一个字符，因为每个单词长度相同所有，我们可以每次移动一个单词的长度，将这些移动分为words[i].size()类</p>
<p>我们以从0开始移动为例，开始讨论优化情况</p>
<ol>
<li><p>情况一：当子串完全匹配，移动到下一子串的时候。</p>
<p>保存当前匹配情况，只让起始位置的单词变为当前下一位置单词进行判断</p>
</li>
<li><p>情况二：当判断过程中，出现不符合单词</p>
<p>i直接移动当前位置，将当前匹配情况清空</p>
</li>
<li><p>情况三：出现符合的单词，但次数超过。</p>
<p>将当前匹配情况从头开始退出，直到该符合的单词被移除，即当前匹配hashmap中次数与要求次数相等时，即可进行正常判断，i前进单词数*单词长度个单位</p>
</li>
</ol>
<p>注意：我们需要添加一个bool hashRemoved 防止情况3移除后情况1继续移除，我们需要一个新的hashmap保存当前匹配情况</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">findSubstring</span><span class="params">(string s, vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(words.<span class="built_in">size</span>()&lt;<span class="number">1</span>||s.<span class="built_in">size</span>()&lt;<span class="number">1</span>||words[<span class="number">0</span>].<span class="built_in">size</span>()*words.<span class="built_in">size</span>()&gt;s.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> wordlen=words[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> len=words.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;string,<span class="keyword">int</span>&gt; hashmapword;</span><br><span class="line">        <span class="keyword">int</span> k;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;words.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            hashmapword[words[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;wordlen;k++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">            unordered_map&lt;string,<span class="keyword">int</span>&gt; hashmaps;</span><br><span class="line">            <span class="keyword">for</span>(i=k;i&lt;s.<span class="built_in">size</span>()-len*wordlen+<span class="number">1</span>;i+=wordlen)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">bool</span> hashremove=<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">while</span>(count&lt;len)</span><br><span class="line">                &#123;</span><br><span class="line">                    string str=s.<span class="built_in">substr</span>(i+count*wordlen,wordlen);</span><br><span class="line">                    <span class="keyword">if</span>(hashmapword.<span class="built_in">count</span>(str)!=<span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        hashmaps[str]++;</span><br><span class="line">                        <span class="keyword">if</span>(hashmaps[str]&gt;hashmapword[str])</span><br><span class="line">                        &#123;</span><br><span class="line">                            hashremove=<span class="literal">true</span>;</span><br><span class="line">                            <span class="keyword">int</span> removenum=<span class="number">0</span>;</span><br><span class="line">                            <span class="keyword">while</span>(hashmaps[str]&gt;hashmapword[str])</span><br><span class="line">                            &#123;</span><br><span class="line">                                string first=s.<span class="built_in">substr</span>(i+removenum*wordlen,wordlen);</span><br><span class="line">                                hashmaps[first]--;</span><br><span class="line">                                removenum++;</span><br><span class="line">                            &#125;</span><br><span class="line">                            count=count-removenum+<span class="number">1</span>;</span><br><span class="line">                            i=i+(removenum<span class="number">-1</span>)*wordlen;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        hashmaps.<span class="built_in">clear</span>();</span><br><span class="line">                        i=i+count*wordlen;</span><br><span class="line">                        count=<span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(count==words.<span class="built_in">size</span>())</span><br><span class="line">                    res.<span class="built_in">push_back</span>(i);</span><br><span class="line">                <span class="keyword">if</span>(count&gt;<span class="number">0</span>&amp;&amp;(!hashremove))</span><br><span class="line">                &#123;</span><br><span class="line">                    string first=s.<span class="built_in">substr</span>(i,wordlen);</span><br><span class="line">                    hashmaps[first]--;</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-32.最长有效括号</title>
    <url>/2019/08/29/leetcode/1-100/32.zui-chang-you-xiao-gua-hao/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。</p>
<span id="more"></span>

<p>示例 1:</p>
<p>输入: “(()”<br>输出: 2<br>解释: 最长有效括号子串为 “()”<br>示例 2:</p>
<p>输入: “)()())”<br>输出: 4<br>解释: 最长有效括号子串为 “()()”</p>
<h4 id="解法1：动态规划"><a href="#解法1：动态规划" class="headerlink" title="解法1：动态规划"></a>解法1：动态规划</h4><p>1.状态</p>
<p>创建一维dp数组,dp[i]表示i位置能构成的括号匹配子串长度,</p>
<p>即若s[i]=’(‘则dp[i]必然为0</p>
<p>2.状态转移方程</p>
<p>当 s[i]=’)’ 时</p>
<p>​    1）当s[i-1]=’(‘时 dp[i]=dp[i-2]+2;  if(i&lt;2 dp[i]=2)    //因为i&lt;2且出现这种情况则只有开头为（）才会出现</p>
<p>​    2）当s[i-1]=’)’时  ;</p>
<p>·当 (i-dp[i-1]&gt;0&amp;&amp;dp[i-dp[i-1]-1]==’(‘)  则dp[i]=dp[i-1]+dp[i-dp[i-1]-1-1]+2；若i-dp[i-1]&lt;2 则dp[i]=dp[i-1]+2; //因为只有开头为(())时 才会出现这种情况</p>
<p>·当 (dp[i-dp[i-1]-1]==’)’)  则dp[i]=0;</p>
<p>为何状态转移方程为这个式子</p>
<p>​    s[i-1]=’(‘很好理解。</p>
<p>主要是s[i-1]=’)’</p>
<p>​    以（（））为例 i=3 s[i]=’)’ s[i-1]=’)’      若想知道当前dp[i]的值， 已设dp表示i位置能构成的括号匹配子串长度，假设有个’(‘跟s[i]匹配，那么咱们现在要找到它的位置，如何找到呢，dp[i-1]已经算出来，dp[i-1]表示i-1位置匹配的子串长度，那么让i-dp[i-1]-1就找到了前面那一个未匹配的字符,如果这一字符又刚好是’(‘则正好和s[i]匹配，</p>
<p>dp[i]=前一个位置匹配的子串长度+左括号前一位位置匹配的字符长度+这一对括号的长度</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i,max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=s.<span class="built_in">length</span>();</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt;<span class="built_in">dp</span>(n,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i<span class="number">-1</span>]==<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i]=(i&gt;=<span class="number">2</span>?dp[i<span class="number">-2</span>]:<span class="number">0</span>)+<span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i-dp[i<span class="number">-1</span>]&gt;<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(s[i-dp[i<span class="number">-1</span>]<span class="number">-1</span>]==<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                        dp[i]=dp[i<span class="number">-1</span>]+((i-dp[i<span class="number">-1</span>])&gt;=<span class="number">2</span>?dp[i-dp[i<span class="number">-1</span>]<span class="number">-1</span><span class="number">-1</span>]:<span class="number">0</span>)+<span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                max=max&gt;dp[i]?max:dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-33.搜索旋转排序数组</title>
    <url>/2019/08/29/leetcode/1-100/33.sou-suo-xuan-zhuan-pai-xu-shu-zu/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p>
<p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。</p>
<p>你可以假设数组中不存在重复的元素。</p>
<p>你的算法时间复杂度必须是 O(log n) 级别。</p>
<span id="more"></span>

<p>示例 1:</p>
<p>输入: nums = [4,5,6,7,0,1,2], target = 0<br>输出: 4<br>示例 2:</p>
<p>输入: nums = [4,5,6,7,0,1,2], target = 3<br>输出: -1</p>
<h4 id="解法1：二分查找"><a href="#解法1：二分查找" class="headerlink" title="解法1：二分查找"></a>解法1：二分查找</h4><p>1.判断查找范围  [0,n-1]</p>
<p>2.选择中间元素和左右边界比较，</p>
<p>3.选择左中位数还是右中位数</p>
<p>4.判断是否进行 后处理 nums[left]==target?left:-1;</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>(),mid;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            mid=left+(right-left+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&lt;nums[right])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//后半段有序</span></span><br><span class="line">                <span class="keyword">if</span>(nums[mid]&lt;=target&amp;&amp;target&lt;=nums[right])</span><br><span class="line">                    left=mid;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    right=mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[left]&lt;=target&amp;&amp;target&lt;=nums[mid<span class="number">-1</span>])</span><br><span class="line">                    right=mid<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    left=mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[left]==target?left:<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-34.在排序数组中查找元素的第一个和最后一个位置</title>
    <url>/2019/08/30/leetcode/1-100/34.zai-pai-xu-shu-zu-zhong-cha-zhao-yuan-su-de-di-yi-ge-he-zui-hou-yi-ge-wei-zhi/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p>
<p>你的算法时间复杂度必须是 O(log n) 级别。</p>
<span id="more"></span>

<p>如果数组中不存在目标值，返回 [-1, -1]。</p>
<p>示例 1:</p>
<p>输入: nums = [5,7,7,8,8,10], target = 8<br>输出: [3,4]<br>示例 2:</p>
<p>输入: nums = [5,7,7,8,8,10], target = 6<br>输出: [-1,-1]</p>
<h4 id="解法1：二分"><a href="#解法1：二分" class="headerlink" title="解法1：二分"></a>解法1：二分</h4><p>思路：</p>
<p>1.两次二分，第一次二分找到最左边为目标值的索引，第二次二分找到最右边为目标值的索引</p>
<p>2.以找到左边目标值为例，如何找到最左边目标值</p>
<p>我们可以通过判断nums[mid]（以下简称mid）&lt;target 找到最左边目标值，思考当mid &lt;target 意味着 区间需要向右移动以使得mid值变大，当mid &gt;=target 区间先左移动，若存在目标值，那么最后得到的必然是最左端的目标值，</p>
<p>3.后处理：先找到左边目标值，若左边目标值不存在，直接返回[-1,-1]</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(<span class="number">-1</span>);</span><br><span class="line">            res.<span class="built_in">push_back</span>(<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> first,second;</span><br><span class="line">        <span class="keyword">int</span> left,right,mid;</span><br><span class="line">        left=<span class="number">0</span>,right=n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&lt;target)</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[left]!=target)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(<span class="number">-1</span>);</span><br><span class="line">            res.<span class="built_in">push_back</span>(<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        first=left;</span><br><span class="line">        left=<span class="number">0</span>,right=n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            mid=left+(right-left+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;target)</span><br><span class="line">                right=mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                left=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        second=left;</span><br><span class="line">        res.<span class="built_in">push_back</span>(first);</span><br><span class="line">        res.<span class="built_in">push_back</span>(second);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-36.有效的数独</title>
    <url>/2019/08/30/leetcode/1-100/36.you-xiao-de-shu-du/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。</p>
<p>数字 1-9 在每一行只能出现一次。<br>数字 1-9 在每一列只能出现一次。<br>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。</p>
<p><img src="/../../../images/lc36.png" alt="lc36"></p>
<span id="more"></span>


<p>上图是一个部分填充的有效的数独。</p>
<p>数独部分空格内已填入了数字，空白格用 ‘.’ 表示。</p>
<p>示例 1:</p>
<p>输入:<br>[<br>  [“5”,”3”,”.”,”.”,”7”,”.”,”.”,”.”,”.”],<br>  [“6”,”.”,”.”,”1”,”9”,”5”,”.”,”.”,”.”],<br>  [“.”,”9”,”8”,”.”,”.”,”.”,”.”,”6”,”.”],<br>  [“8”,”.”,”.”,”.”,”6”,”.”,”.”,”.”,”3”],<br>  [“4”,”.”,”.”,”8”,”.”,”3”,”.”,”.”,”1”],<br>  [“7”,”.”,”.”,”.”,”2”,”.”,”.”,”.”,”6”],<br>  [“.”,”6”,”.”,”.”,”.”,”.”,”2”,”8”,”.”],<br>  [“.”,”.”,”.”,”4”,”1”,”9”,”.”,”.”,”5”],<br>  [“.”,”.”,”.”,”.”,”8”,”.”,”.”,”7”,”9”]<br>]<br>输出: true<br>示例 2:</p>
<p>输入:<br>[<br>  [“8”,”3”,”.”,”.”,”7”,”.”,”.”,”.”,”.”],<br>  [“6”,”.”,”.”,”1”,”9”,”5”,”.”,”.”,”.”],<br>  [“.”,”9”,”8”,”.”,”.”,”.”,”.”,”6”,”.”],<br>  [“8”,”.”,”.”,”.”,”6”,”.”,”.”,”.”,”3”],<br>  [“4”,”.”,”.”,”8”,”.”,”3”,”.”,”.”,”1”],<br>  [“7”,”.”,”.”,”.”,”2”,”.”,”.”,”.”,”6”],<br>  [“.”,”6”,”.”,”.”,”.”,”.”,”2”,”8”,”.”],<br>  [“.”,”.”,”.”,”4”,”1”,”9”,”.”,”.”,”5”],<br>  [“.”,”.”,”.”,”.”,”8”,”.”,”.”,”7”,”9”]<br>]<br>输出: false<br>解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。<br>     但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。<br>说明:</p>
<p>一个有效的数独（部分已被填充）不一定是可解的。<br>只需要根据以上规则，验证已经填入的数字是否有效即可。<br>给定数独序列只包含数字 1-9 和字符 ‘.’ 。<br>给定数独永远是 9x9 形式的。</p>
<h4 id="解法1：一次迭代"><a href="#解法1：一次迭代" class="headerlink" title="解法1：一次迭代"></a>解法1：一次迭代</h4><p>思路:</p>
<p>构建三个二维数组，row,col,box 表示，这一位位置的行，列，宫是否符合要求</p>
<p>注意：box下标可以用 row/3*3+col/3 求得</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidSudoku</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">        <span class="keyword">int</span> col[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">        <span class="keyword">int</span> box[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">        <span class="built_in">memset</span>(row,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(row));</span><br><span class="line">        <span class="built_in">memset</span>(col,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(col));</span><br><span class="line">        <span class="built_in">memset</span>(box,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(box));</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">int</span> k;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">9</span>;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j]==<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    k=board[i][j]-<span class="string">&#x27;0&#x27;</span><span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(row[i][k]!=<span class="number">0</span>||col[j][k]!=<span class="number">0</span>||box[i/<span class="number">3</span>*<span class="number">3</span>+j/<span class="number">3</span>][k]!=<span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    row[i][k]++;</span><br><span class="line">                    col[j][k]++;</span><br><span class="line">                    box[i/<span class="number">3</span>*<span class="number">3</span>+j/<span class="number">3</span>][k]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-35.搜索插入位置</title>
    <url>/2019/08/30/leetcode/1-100/35.sou-suo-cha-ru-wei-zhi/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>你可以假设数组中无重复元素。</p>
<span id="more"></span>

<p>示例 1:</p>
<p>输入: [1,3,5,6], 5<br>输出: 2<br>示例 2:</p>
<p>输入: [1,3,5,6], 2<br>输出: 1<br>示例 3:</p>
<p>输入: [1,3,5,6], 7<br>输出: 4<br>示例 4:</p>
<p>输入: [1,3,5,6], 0<br>输出: 0</p>
<h4 id="解法1：二分"><a href="#解法1：二分" class="headerlink" title="解法1：二分"></a>解法1：二分</h4><p>思路：</p>
<p>1.这是一个排序数组，自然想到通过二分找到他的位置。</p>
<p>2.判断区间范围，这里注意，有可能目标值大于数组最大值，那么目标值就要放在第n位上（数组长度n），所以区间范围为[0,n]</p>
<p>3.套用二分法模板，注意不要出现死循环。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left,right,mid;</span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        left=<span class="number">0</span>,right=n;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&lt;target)</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-37.解数独</title>
    <url>/2019/08/30/leetcode/1-100/37.jie-shu-du/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>编写一个程序，通过已填充的空格来解决数独问题。</p>
<p>一个数独的解法需遵循如下规则：</p>
<p>数字 1-9 在每一行只能出现一次。<br>数字 1-9 在每一列只能出现一次。<br>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。<br>空白格用 ‘.’ 表示。</p>
<span id="more"></span>

<p><img src="/../../../images/lc36.png" alt="lc36"></p>
<p>一个数独。 </p>
<p><img src="/../../../images/lc37.png" alt="lc37"></p>
<p>答案被标成红色。</p>
<p>Note:</p>
<p>给定的数独序列只包含数字 1-9 和字符 ‘.’ 。<br>你可以假设给定的数独只有唯一解。<br>给定数独永远是 9x9 形式的。</p>
<h4 id="解法1：回溯"><a href="#解法1：回溯" class="headerlink" title="解法1：回溯"></a>解法1：回溯</h4><p>1.同样建立3个数组row,col,box 表示行，列，宫</p>
<p>2.将本来存在的数字在对应行，列，宫中存下</p>
<p>3.开始回溯插入</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> row[<span class="number">9</span>][<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">int</span> col[<span class="number">9</span>][<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">int</span> box[<span class="number">9</span>][<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">int</span> res;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(row,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(row));</span><br><span class="line">        <span class="built_in">memset</span>(col,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(col));</span><br><span class="line">        <span class="built_in">memset</span>(box,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(box));</span><br><span class="line">        res=<span class="number">0</span>;                  <span class="comment">//标志位，如果找到解，res=1，使其退出回溯函数</span></span><br><span class="line">        <span class="keyword">int</span> i,j,k;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">9</span>;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j]==<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                k=board[i][j]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                row[i][k]++;</span><br><span class="line">                col[j][k]++;</span><br><span class="line">                box[i/<span class="number">3</span>*<span class="number">3</span>+j/<span class="number">3</span>][k]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">9</span>;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j]!=<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="built_in">insert</span>(board,i,j);</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> q;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">9</span>)			<span class="comment">//如果j==9表示要在新的一行进行解数独</span></span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">9</span>&amp;&amp;j&lt;<span class="number">9</span>)		<span class="comment">//如果i=9||j=9，表示找到一个数独解，直接返回退出函数</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(board[i][j]!=<span class="string">&#x27;.&#x27;</span>)			<span class="comment">//找到下个待数字的位置</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">8</span>&amp;&amp;j==<span class="number">8</span>)				<span class="comment">//到达数独最后1位，表示找到了数独解，直接返回退出</span></span><br><span class="line">                &#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    <span class="keyword">return</span>  ;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j==<span class="number">8</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                    j=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(q=<span class="number">1</span>;q&lt;=<span class="number">9</span>;q++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(row[i][q]!=<span class="number">0</span>||col[j][q]!=<span class="number">0</span>||box[i/<span class="number">3</span>*<span class="number">3</span>+j/<span class="number">3</span>][q]!=<span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                row[i][q]++;</span><br><span class="line">                col[j][q]++;</span><br><span class="line">                box[i/<span class="number">3</span>*<span class="number">3</span>+j/<span class="number">3</span>][q]++;</span><br><span class="line">                board[i][j]=(<span class="keyword">char</span>)q+<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">insert</span>(board,i,j+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(res!=<span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                row[i][q]--;</span><br><span class="line">                col[j][q]--;</span><br><span class="line">                box[i/<span class="number">3</span>*<span class="number">3</span>+j/<span class="number">3</span>][q]--;</span><br><span class="line">                board[i][j]=<span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(q&gt;<span class="number">9</span>)</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        res++;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-38.报数</title>
    <url>/2019/08/30/leetcode/1-100/38.bao-shu/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下：</p>
<ol>
<li><pre><code>1
</code></pre>
</li>
<li><pre><code>11
</code></pre>
</li>
<li><pre><code>21
</code></pre>
</li>
<li><pre><code>1211
</code></pre>
</li>
<li> 111221<br>1 被读作  “one 1”  (“一个一”) , 即 11。<br>11 被读作 “two 1s” (“两个一”）, 即 21。<br>21 被读作 “one 2”,  “one 1” （”一个二” ,  “一个一”) , 即 1211。</li>
</ol>
<p>给定一个正整数 n（1 ≤ n ≤ 30），输出报数序列的第 n 项。</p>
<p>注意：整数顺序将表示为一个字符串。</p>
<p> <span id="more"></span></p>
<p>示例 1:</p>
<p>输入: 1<br>输出: “1”<br>示例 2:</p>
<p>输入: 4<br>输出: “1211”</p>
<h4 id="解法1：迭代"><a href="#解法1：迭代" class="headerlink" title="解法1：迭代"></a>解法1：迭代</h4><p>以第一项为基准，开始迭代，</p>
<p>根据题意记录连续的字符个数和字符</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        string res[<span class="number">31</span>];</span><br><span class="line">        res[<span class="number">1</span>]=<span class="string">&quot;1&quot;</span>;</span><br><span class="line">        res[<span class="number">2</span>]=<span class="string">&quot;11&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> res[n];</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">int</span> k;</span><br><span class="line">        <span class="keyword">char</span> ch;</span><br><span class="line">        <span class="keyword">char</span> a;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">3</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            k=<span class="number">0</span>;</span><br><span class="line">            a=res[i<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;res[i<span class="number">-1</span>].<span class="built_in">length</span>();)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(res[i<span class="number">-1</span>][j]==a)</span><br><span class="line">                &#123;</span><br><span class="line">                    k++;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ch=k+<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    <span class="keyword">if</span>(k&gt;<span class="number">0</span>)</span><br><span class="line">                        res[i]=res[i]+ch+a;</span><br><span class="line">                    a=res[i<span class="number">-1</span>][j];</span><br><span class="line">                    k=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ch=k+<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(k&gt;<span class="number">0</span>)</span><br><span class="line">                res[i]=res[i]+ch+a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>迭代</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-39.组合总和</title>
    <url>/2019/08/30/leetcode/1-100/39.zu-he-zong-he/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的数字可以无限制重复被选取。</p>
<p>说明：</p>
<p>所有数字（包括 target）都是正整数。<br>解集不能包含重复的组合。 </p>
<span id="more"></span>

<p>示例 1:</p>
<p>输入: candidates = [2,3,6,7], target = 7,<br>所求解集为:<br>[<br>  [7],<br>  [2,2,3]<br>]<br>示例 2:</p>
<p>输入: candidates = [2,3,5], target = 8,<br>所求解集为:<br>[<br>  [2,2,2,2],<br>  [2,3,3],<br>  [3,5]<br>]</p>
<h4 id="解法1：回溯-剪枝"><a href="#解法1：回溯-剪枝" class="headerlink" title="解法1：回溯+剪枝"></a>解法1：回溯+剪枝</h4><p>先对数组从小到大排序，然后进行回溯，</p>
<p>当当前和等于目标值 加入res，并返回，</p>
<p>若当前和+当前值&gt;目标值    则进行下一轮回溯</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(),candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>,i=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">search</span>(candidates,target,sum,i);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target,<span class="keyword">int</span> sum,<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=candidates.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">if</span>(sum==target)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum&lt;target)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;n&amp;&amp;sum+candidates[i]&lt;=target)</span><br><span class="line">            &#123;</span><br><span class="line">               <span class="keyword">for</span>(j=<span class="number">0</span>;sum+candidates[i]*j&lt;=target;j++)</span><br><span class="line">               &#123;</span><br><span class="line">                   sum+=candidates[i]*j;</span><br><span class="line">                   <span class="keyword">int</span> k=j;</span><br><span class="line">                   <span class="keyword">while</span>(k--&gt;<span class="number">0</span>)</span><br><span class="line">                       temp.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">                   <span class="built_in">search</span>(candidates,target,sum,i+<span class="number">1</span>);</span><br><span class="line">                   k=j;</span><br><span class="line">                   <span class="keyword">while</span>(k--&gt;<span class="number">0</span>)</span><br><span class="line">                       temp.<span class="built_in">pop_back</span>();</span><br><span class="line">                   sum-=candidates[i]*j;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>回溯</tag>
        <tag>剪枝</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-4. 寻找两个有序数组的中位数</title>
    <url>/2019/08/20/leetcode/1-100/4.xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-shu/</url>
    <content><![CDATA[<h4 id="4-寻找两个有序数组的中位数"><a href="#4-寻找两个有序数组的中位数" class="headerlink" title="4. 寻找两个有序数组的中位数"></a><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">4. 寻找两个有序数组的中位数</a></h4><span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> n = nums1.<span class="built_in">size</span>();</span><br><span class="line">		<span class="keyword">int</span> m = nums2.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (n &gt; m)  <span class="comment">//保证数组1一定最短</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">findMedianSortedArrays</span>(nums2, nums1);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Ci 为第i个数组的割,比如C1为2时表示第1个数组只有2个元素。LMaxi为第i个数组割后的左元素。RMini为第i个数组割后的右元素。</span></span><br><span class="line">		<span class="keyword">int</span> LMax1, LMax2, RMin1, RMin2, c1, c2, lo = <span class="number">0</span>, hi = <span class="number">2</span> * n;  <span class="comment">//我们目前是虚拟加了&#x27;#&#x27;所以数组1是2*n长度</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (lo &lt;= hi)   <span class="comment">//二分</span></span><br><span class="line">		&#123;</span><br><span class="line">			c1 = (lo + hi) / <span class="number">2</span>;  <span class="comment">//c1是二分的结果</span></span><br><span class="line">			c2 = m + n - c1;</span><br><span class="line"></span><br><span class="line">			LMax1 = (c1 == <span class="number">0</span>) ? INT_MIN : nums1[(c1 - <span class="number">1</span>) / <span class="number">2</span>];</span><br><span class="line">			RMin1 = (c1 == <span class="number">2</span> * n) ? INT_MAX : nums1[c1 / <span class="number">2</span>];</span><br><span class="line">			LMax2 = (c2 == <span class="number">0</span>) ? INT_MIN : nums2[(c2 - <span class="number">1</span>) / <span class="number">2</span>];</span><br><span class="line">			RMin2 = (c2 == <span class="number">2</span> * m) ? INT_MAX : nums2[c2 / <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (LMax1 &gt; RMin2)</span><br><span class="line">				hi = c1 - <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (LMax2 &gt; RMin1)</span><br><span class="line">				lo = c1 + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> (<span class="built_in">max</span>(LMax1, LMax2) + <span class="built_in">min</span>(RMin1, RMin2)) / <span class="number">2.0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-40.组合总和II</title>
    <url>/2019/08/30/leetcode/1-100/40.zu-he-zong-he-ii/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的每个数字在每个组合中只能使用一次。</p>
<p>说明：</p>
<p>所有数字（包括目标数）都是正整数。<br>解集不能包含重复的组合。 </p>
<span id="more"></span>

<p>示例 1:</p>
<p>输入: candidates = [10,1,2,7,6,1,5], target = 8,<br>所求解集为:<br>[<br>  [1, 7],<br>  [1, 2, 5],<br>  [2, 6],<br>  [1, 1, 6]<br>]<br>示例 2:</p>
<p>输入: candidates = [2,5,2,1,2], target = 5,<br>所求解集为:<br>[<br>  [1,2,2],<br>  [5]<br>]</p>
<h4 id="解法1：回溯-剪枝"><a href="#解法1：回溯-剪枝" class="headerlink" title="解法1：回溯+剪枝"></a>解法1：回溯+剪枝</h4><p>与39题类似，这次只需要判断1次或0次添加到数组中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(),candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">search</span>(candidates,target,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target,<span class="keyword">int</span> sum,<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=candidates.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">if</span>(sum==target)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;n&amp;&amp;sum+candidates[k]&lt;=target;k++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(k&gt;i&amp;&amp;candidates[k]==candidates[k<span class="number">-1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp.<span class="built_in">push_back</span>(candidates[k]);</span><br><span class="line">            <span class="built_in">search</span>(candidates,target,sum+candidates[k],k+<span class="number">1</span>);</span><br><span class="line">            temp.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>回溯</tag>
        <tag>剪枝</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-41.缺失的第一个正数</title>
    <url>/2019/08/31/leetcode/1-100/41.que-shi-de-di-yi-ge-zheng-shu/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个未排序的整数数组，找出其中没有出现的最小的正整数。</p>
<span id="more"></span>

<p>示例 1:</p>
<p>输入: [1,2,0]<br>输出: 3<br>示例 2:</p>
<p>输入: [3,4,-1,1]<br>输出: 2<br>示例 3:</p>
<p>输入: [7,8,9,11,12]<br>输出: 1<br>说明:</p>
<p>你的算法的时间复杂度应为O(n)，并且只能使用常数级别的空间。</p>
<h4 id="解法1：桶排序"><a href="#解法1：桶排序" class="headerlink" title="解法1：桶排序"></a>解法1：桶排序</h4><p>思路：</p>
<p>1.”一个萝卜1个坑“，即以自身作为hash表，将自身放入对应位置，例如nums[3]=2，那么就让他放入自身的第2个位置，即swap(nums[nums[3]-1],nums[3]),然后对交换过来的元素进行操作</p>
<p>2.如果该数的范围&lt;=0||&gt;n则自身没有地方放该数，那么就让该数在原地，不对他进行操作</p>
<p>3.如果要换的位置已经放入了正确的数，则跳出循环，对下一个nums[i]进行操作</p>
<p>4.遍历自身数组，当nums[i]!=i-1时，即该位置缺少对应的数，则找到了最小的缺失正数，返回，若遍历发现没有缺失，表示该数组从1到n,都有数字，则返回n+1</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(nums[i]&gt;<span class="number">0</span>&amp;&amp;nums[i]&lt;=n)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]==nums[nums[i]<span class="number">-1</span>])</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="built_in">swap</span>(nums[i],nums[nums[i]<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=i+<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>桶排序</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-42.接雨水</title>
    <url>/2019/08/31/leetcode/1-100/42.jie-yu-shui/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<p><img src="/../../../images/lc42.png" alt="lc5"></p>
<p>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 感谢 Marcos 贡献此图。</p>
<span id="more"></span>

<p>示例:</p>
<p>输入: [0,1,0,2,1,0,1,3,2,1,2,1]<br>输出: 6</p>
<h4 id="解法1：两次遍历"><a href="#解法1：两次遍历" class="headerlink" title="解法1：两次遍历"></a>解法1：两次遍历</h4><p>思路：</p>
<p>1.第一次遍历找到最高点的位置k</p>
<p>2.第二次先从0到k遍历，记录当前能接住的雨水和sum,</p>
<p>​    1）首先sum-当前柱子值,然后如果当前值是从0到k最高的柱子则sum+=（height-max）*（k-i）即当前位置到最高柱子能存的雨水数</p>
<p>3.同样从n-1到k遍历，与第二部相似</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=height.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> k;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(max&lt;height[i])</span><br><span class="line">            &#123;</span><br><span class="line">                max=height[i];</span><br><span class="line">                k=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum-=height[i];</span><br><span class="line">            <span class="keyword">if</span>(height[i]&gt;max)</span><br><span class="line">            &#123;</span><br><span class="line">                sum+=(height[i]-max)*(k-i);</span><br><span class="line">                max=height[i];</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;k;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            sum-=height[i];</span><br><span class="line">            <span class="keyword">if</span>(height[i]&gt;max)</span><br><span class="line">            &#123;</span><br><span class="line">                sum+=(height[i]-max)*(i-k);</span><br><span class="line">                max=height[i];</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<h4 id="解法2：动态规划"><a href="#解法2：动态规划" class="headerlink" title="解法2：动态规划"></a>解法2：动态规划</h4><p>思路：</p>
<p>1.对于每一列我们求它左边最高的墙，和它右边最高的墙，我们可以用两个数组max_left[i]表示第i列左边墙最高墙的高度,max_right[i]表示右边最高墙的高度，那么i位置能存的水就是则可以这些写：</p>
<p>mins=min(max_left[i],max_right[i]);if(mins&gt;height[i])    i位置的水为mins-height[i];</p>
<p>对应max_left我们可以这样求max_left[i]=max(max_left[i-1],height[i-1])。它前边的墙左边的最高墙的高度，和它前边的墙的高度取一个较大值，同理max_right[i]=max(max_left[i+1],height[i+1])</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=height.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">max_left</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">max_right</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            max_left[i]=<span class="built_in">max</span>(max_left[i<span class="number">-1</span>],height[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=n<span class="number">-2</span>;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            max_right[i]=<span class="built_in">max</span>(max_right[i+<span class="number">1</span>],height[i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mins=<span class="built_in">min</span>(max_left[i],max_right[i]);</span><br><span class="line">            <span class="keyword">if</span>(mins&gt;height[i])</span><br><span class="line">                sum+=mins-height[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<h4 id="解法3：双指针"><a href="#解法3：双指针" class="headerlink" title="解法3：双指针"></a>解法3：双指针</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max_left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max_right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> n=height.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> right =n- <span class="number">2</span>; <span class="comment">// 加右指针进去</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//从左到右更</span></span><br><span class="line">            <span class="keyword">if</span> (height[left - <span class="number">1</span>] &lt; height[right + <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                max_left =<span class="built_in">max</span>(max_left, height[left - <span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">int</span> mins = max_left;</span><br><span class="line">                <span class="keyword">if</span> (mins &gt; height[left])</span><br><span class="line">                &#123;</span><br><span class="line">                    sum = sum + (mins - height[left]);</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            <span class="comment">//从右到左更</span></span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                max_right =<span class="built_in">max</span>(max_right, height[right + <span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">int</span> mins = max_right;</span><br><span class="line">                <span class="keyword">if</span> (mins &gt; height[right])</span><br><span class="line">                &#123;</span><br><span class="line">                    sum = sum + (mins - height[right]);</span><br><span class="line">                &#125;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<h4 id="解法4：栈"><a href="#解法4：栈" class="headerlink" title="解法4：栈"></a>解法4：栈</h4><p>说到栈，我们肯定会想到括号匹配了。我们仔细观察蓝色的部分，可以和括号匹配类比下。每次匹配出一对括号（找到对应的一堵墙），就计算这两堵墙中的水。</p>
<p>我们用栈保存每堵墙。</p>
<p>当遍历墙的高度的时候，如果当前高度小于栈顶的墙高度，说明这里会有积水，我们将墙的高度的下标入栈。</p>
<p>如果当前高度大于栈顶的墙的高度，说明之前的积水到这里停下，我们可以计算下有多少积水了。计算完，就把当前的墙继续入栈，作为新的积水的墙。</p>
<p>总体的原则就是，</p>
<p>当前高度小于等于栈顶高度，入栈，指针后移。</p>
<p>当前高度大于栈顶高度，出栈，计算出当前墙和栈顶的墙之间水的多少，然后计算当前的高度和新栈的高度的关系，重复第 2 步。直到当前墙的高度不大于栈顶高度或者栈空，然后把当前墙入栈，指针后移。</p>
<p>作者：windliang<br>链接：<a href="https://leetcode-cn.com/problems/trapping-rain-water/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-8/">https://leetcode-cn.com/problems/trapping-rain-water/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-8/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=height.<span class="built_in">size</span>();</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">int</span> current=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(current&lt;n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!st.<span class="built_in">empty</span>()&amp;&amp;height[current]&gt;height[st.<span class="built_in">top</span>()])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> h=height[st.<span class="built_in">top</span>()];</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(st.<span class="built_in">empty</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> distance=current-st.<span class="built_in">top</span>()<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">int</span> mins=<span class="built_in">min</span>(height[current],height[st.<span class="built_in">top</span>()]);</span><br><span class="line">                sum+=(mins-h)*distance;</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">push</span>(current);</span><br><span class="line">            current++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-43.字符串相乘</title>
    <url>/2019/08/31/leetcode/1-100/43.zi-fu-chuan-xiang-cheng/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。</p>
<p>示例 1:</p>
<p>输入: num1 = “2”, num2 = “3”<br>输出: “6”<br>示例 2:</p>
<p>输入: num1 = “123”, num2 = “456”<br>输出: “56088”</p>
<span id="more"></span>

<p>说明：</p>
<p>num1 和 num2 的长度小于110。<br>num1 和 num2 只包含数字 0-9。<br>num1 和 num2 均不以零开头，除非是数字 0 本身。<br>不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/multiply-strings">https://leetcode-cn.com/problems/multiply-strings</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法1：暴力模拟"><a href="#解法1：暴力模拟" class="headerlink" title="解法1：暴力模拟"></a>解法1：暴力模拟</h4><p>建议先做415题字符串相加，然后做这题思路就很清晰了</p>
<p>解题思路：</p>
<p>1.模拟竖式乘法，即nums1乘上nums2的每一位，累加求和就得到了nums1*nums2的结果</p>
<p>保证nums1.size()&gt;nums2.size() 这样能节约一部分时间</p>
<p>注意乘nums2每一位的结果要向左移动相应位数，即在字符串后面补‘0’；</p>
<p>全部乘完后构成一个字符串数组，用415题的函数累加求和便得到了结果res</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">multiply</span><span class="params">(string num1, string num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=num1.<span class="built_in">size</span>(),m=num2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n&lt;m)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">multiply</span>(num2,num1);</span><br><span class="line">        <span class="keyword">int</span> i=n<span class="number">-1</span>,j=m<span class="number">-1</span>,l=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mul;</span><br><span class="line">        vector&lt;string&gt; temp;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(j&gt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(num2[j]!=<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                string te;</span><br><span class="line">                <span class="keyword">while</span>(i&gt;=<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    a=num1[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    b=num2[j]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    mul=a*b+k;</span><br><span class="line">                    k=mul/<span class="number">10</span>;</span><br><span class="line">                    mul%=<span class="number">10</span>;</span><br><span class="line">                    </span><br><span class="line">                    te+=mul+<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    </span><br><span class="line">                    i--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(k!=<span class="number">0</span>)</span><br><span class="line">                    te+=k+<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="built_in">reverse</span>(te.<span class="built_in">begin</span>(),te.<span class="built_in">end</span>());</span><br><span class="line">                <span class="keyword">int</span> q=l;</span><br><span class="line">                <span class="keyword">while</span>(q--&gt;<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    te+=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                temp.<span class="built_in">push_back</span>(te);</span><br><span class="line">            &#125;</span><br><span class="line">            j--;</span><br><span class="line">            l++;</span><br><span class="line">            i=n<span class="number">-1</span>;</span><br><span class="line">            k=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        string res=<span class="string">&quot;0&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;temp.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res=<span class="built_in">addStrings</span>(res,temp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">addStrings</span><span class="params">(string num1, string num2)</span> </span>&#123;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">if</span>(num2==<span class="string">&quot;&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> num1;</span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i=num1.<span class="built_in">size</span>()<span class="number">-1</span>,j=num2.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="keyword">int</span> sum;</span><br><span class="line">        <span class="keyword">char</span> ch;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>&amp;&amp;j&gt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            a=num1[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            b=num2[j]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            </span><br><span class="line">            sum=a+b+k;</span><br><span class="line">            <span class="keyword">if</span>(sum&gt;<span class="number">9</span>)</span><br><span class="line">                k=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                k=<span class="number">0</span>;</span><br><span class="line">            sum%=<span class="number">10</span>;</span><br><span class="line">            ch=sum+<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            res+=ch;</span><br><span class="line">            i--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            a=num1[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            sum=a+k;</span><br><span class="line">            <span class="keyword">if</span>(sum&gt;<span class="number">9</span>)</span><br><span class="line">                k=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                k=<span class="number">0</span>;</span><br><span class="line">            sum%=<span class="number">10</span>;</span><br><span class="line">            ch=sum+<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            res+=ch;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            b=num2[j]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            sum=b+k;</span><br><span class="line">            <span class="keyword">if</span>(sum&gt;<span class="number">9</span>)</span><br><span class="line">                k=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                k=<span class="number">0</span>;</span><br><span class="line">            sum%=<span class="number">10</span>;</span><br><span class="line">            ch=sum+<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            res+=ch;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">1</span>)</span><br><span class="line">            res+=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-44.通配符匹配</title>
    <url>/2019/09/01/leetcode/1-100/44.tong-pei-fu-pi-pei/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 ‘?’ 和 ‘*’ 的通配符匹配。</p>
<p>‘?’ 可以匹配任何单个字符。<br>‘*’ 可以匹配任意字符串（包括空字符串）。<br>两个字符串完全匹配才算匹配成功。</p>
<span id="more"></span>

<p>说明:</p>
<p>s 可能为空，且只包含从 a-z 的小写字母。<br>p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。<br>示例 1:</p>
<p>输入:<br>s = “aa”<br>p = “a”<br>输出: false<br>解释: “a” 无法匹配 “aa” 整个字符串。<br>示例 2:</p>
<p>输入:<br>s = “aa”<br>p = “<em>“<br>输出: true<br>解释: ‘</em>‘ 可以匹配任意字符串。<br>示例 3:</p>
<p>输入:<br>s = “cb”<br>p = “?a”<br>输出: false<br>解释: ‘?’ 可以匹配 ‘c’, 但第二个 ‘a’ 无法匹配 ‘b’。<br>示例 4:</p>
<p>输入:<br>s = “adceb”<br>p = “<em>a</em>b”<br>输出: true<br>解释: 第一个 ‘<em>‘ 可以匹配空字符串, 第二个 ‘</em>‘ 可以匹配字符串 “dce”.<br>示例 5:</p>
<p>输入:<br>s = “acdcb”<br>p = “a*c?b”<br>输入: false</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/wildcard-matching">https://leetcode-cn.com/problems/wildcard-matching</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法1：动态规划"><a href="#解法1：动态规划" class="headerlink" title="解法1：动态规划"></a>解法1：动态规划</h4><p>此题与10题正则表达式匹配类似，同样用dp解决</p>
<p>思路：</p>
<p>1.状态</p>
<p>dp[i][j]表示s前i个字符与p前j个字符能否匹配</p>
<p>2.状态转移方程</p>
<p>​    ·当s[i]=p[j]或p[j]=’?’，dp[i][j]=dp[i-1][j-1]</p>
<p>​    ·当p[j]=’*’时 </p>
<p>​        1）当p匹配空串dp[i][j]=dp[i][j-1]</p>
<p>​        2）当匹配s的第i个字符dp[i][j]=dp[i-1][j]</p>
<p>3.初始化</p>
<p>dp[0][0]=true;</p>
<p>dp[0][i]=dp[0][i-1]&amp;&amp;p[i]==’*’</p>
<p>即s为空串 与 s2的前i个字符是否匹配</p>
<p>4.结果</p>
<p>dp[n][m];</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=s.<span class="built_in">size</span>(),m=p.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">dp</span>(n+<span class="number">1</span>,vector&lt;<span class="keyword">bool</span>&gt;(m+<span class="number">1</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m+<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i]=(dp[<span class="number">0</span>][i<span class="number">-1</span>]&amp;&amp;p[i<span class="number">-1</span>]==<span class="string">&#x27;*&#x27;</span>)?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i<span class="number">-1</span>]==p[j<span class="number">-1</span>]||p[j<span class="number">-1</span>]==<span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(p[j<span class="number">-1</span>]==<span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                   dp[i][j]=(dp[i<span class="number">-1</span>][j]||dp[i][j<span class="number">-1</span>])?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-45.跳跃游戏</title>
    <url>/2019/09/02/leetcode/1-100/45.tiao-yue-you-xi/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p>
<span id="more"></span>

<p>示例:</p>
<p>输入: [2,3,1,1,4]<br>输出: 2<br>解释: 跳到最后一个位置的最小跳跃数是 2。<br>     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。<br>说明:</p>
<p>假设你总是可以到达数组的最后一个位置。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/jump-game-ii">https://leetcode-cn.com/problems/jump-game-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法1：贪心"><a href="#解法1：贪心" class="headerlink" title="解法1：贪心"></a>解法1：贪心</h4><p>采用贪心策略，计算每一步所能到达的最远位置，选择当前步能跳到的最优位置进行跳跃</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> s=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> j=i;</span><br><span class="line">        i=i+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> l;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s+j&gt;=n<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;=s+j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(max&lt;=(nums[i]+i))</span><br><span class="line">                &#123;</span><br><span class="line">                    max=nums[i]+i;</span><br><span class="line">                    l=i;</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            s=nums[l];</span><br><span class="line">            j=l;</span><br><span class="line">            i=l+<span class="number">1</span>;</span><br><span class="line">            count++;</span><br><span class="line">            max=<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>代码优化</p>
<p>创建一个end变量，表示能跳到的边界，如果遍历数组到达了边界就重新更新新的边界</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> end=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">int</span> maxs=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            maxs=<span class="built_in">max</span>(maxs,nums[i]+i);</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=end)</span><br><span class="line">            &#123;</span><br><span class="line">                end=maxs;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-46.全排列</title>
    <url>/2019/09/02/leetcode/1-100/46.quan-pai-lie/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个没有重复数字的序列，返回其所有可能的全排列。</p>
<p>示例:</p>
<p>输入: [1,2,3]<br>输出:<br>[<br>  [1,2,3],<br>  [1,3,2],<br>  [2,1,3],<br>  [2,3,1],<br>  [3,1,2],<br>  [3,2,1]<br>]</p>
<span id="more"></span>

<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/permutations">https://leetcode-cn.com/problems/permutations</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法1：回溯"><a href="#解法1：回溯" class="headerlink" title="解法1：回溯"></a>解法1：回溯</h4><p>典型的回溯问题，构建一个used数组，来确定当前数字是否已在该序列中，进行回溯，</p>
<p>注意：回溯的重点是返回上一层时要将状态复原</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">bool</span> *used=<span class="keyword">new</span> <span class="keyword">bool</span> [n]();</span><br><span class="line">        <span class="built_in">findall</span>(nums,used,count,n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">findall</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">bool</span> *used,<span class="keyword">int</span> count,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count==n)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(pre);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!used[i])</span><br><span class="line">            &#123;</span><br><span class="line">                used[i]=<span class="literal">true</span>;</span><br><span class="line">                </span><br><span class="line">                pre.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                <span class="built_in">findall</span>(nums,used,count+<span class="number">1</span>,n);</span><br><span class="line">                pre.<span class="built_in">pop_back</span>();</span><br><span class="line">                </span><br><span class="line">                used[i]=<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; pre;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-47.全排列II</title>
    <url>/2019/09/02/leetcode/1-100/47.quan-pai-lie-ii/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个可包含重复数字的序列，返回所有不重复的全排列。</p>
<p>示例:</p>
<p>输入: [1,1,2]<br>输出:<br>[<br>  [1,1,2],<br>  [1,2,1],<br>  [2,1,1]<br>]</p>
<span id="more"></span>

<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/permutations-ii">https://leetcode-cn.com/problems/permutations-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法1：回溯-剪枝"><a href="#解法1：回溯-剪枝" class="headerlink" title="解法1：回溯+剪枝"></a>解法1：回溯+剪枝</h4><p>与45题相似，多了一个不能出现重复数组，也就是循环的时候进行判断是否与上一个数字相等，如果相等直接进行剪枝也就是进入下一循环</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">bool</span> *used=<span class="keyword">new</span> <span class="keyword">bool</span> [n]();</span><br><span class="line">        <span class="built_in">findall</span>(nums,used,count,n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">findall</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">bool</span> *used,<span class="keyword">int</span> count,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count==n)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(pre);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!used[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i<span class="number">-1</span>]&amp;&amp;(used[i<span class="number">-1</span>]==<span class="literal">false</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                used[i]=<span class="literal">true</span>;</span><br><span class="line">                </span><br><span class="line">                pre.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                <span class="built_in">findall</span>(nums,used,count+<span class="number">1</span>,n);</span><br><span class="line">                pre.<span class="built_in">pop_back</span>();</span><br><span class="line">                </span><br><span class="line">                used[i]=<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; pre;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-48.旋转图像</title>
    <url>/2019/09/03/leetcode/1-100/48.xuan-zhuan-tu-xiang/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个 n × n 的二维矩阵表示一个图像。</p>
<p>将图像顺时针旋转 90 度。</p>
<p>说明：</p>
<p>你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。</p>
<span id="more"></span>

<p>示例 1:</p>
<p>给定 matrix =<br>[<br>  [1,2,3],<br>  [4,5,6],<br>  [7,8,9]<br>],</p>
<p>原地旋转输入矩阵，使其变为:<br>[<br>  [7,4,1],<br>  [8,5,2],<br>  [9,6,3]<br>]<br>示例 2:</p>
<p>给定 matrix =<br>[<br>  [ 5, 1, 9,11],<br>  [ 2, 4, 8,10],<br>  [13, 3, 6, 7],<br>  [15,14,12,16]<br>], </p>
<p>原地旋转输入矩阵，使其变为:<br>[<br>  [15,13, 2, 5],<br>  [14, 3, 4, 1],<br>  [12, 6, 8, 9],<br>  [16, 7,10,11]<br>]</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/rotate-image">https://leetcode-cn.com/problems/rotate-image</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法1：转置-翻转"><a href="#解法1：转置-翻转" class="headerlink" title="解法1：转置+翻转"></a>解法1：转置+翻转</h4><p>观察前后矩阵，发现输出后矩阵是先转置后进行翻转</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(j=i;j&lt;n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(matrix[i][j],matrix[j][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">reverse</span>(matrix[i].<span class="built_in">begin</span>(),matrix[i].<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-49.字母异位词分组</title>
    <url>/2019/09/03/leetcode/1-100/49.zi-mu-yi-wei-ci-fen-zu/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</p>
<p>示例:</p>
<p>输入: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”],<br>输出:<br>[<br>  [“ate”,”eat”,”tea”],<br>  [“nat”,”tan”],<br>  [“bat”]<br>]</p>
<span id="more"></span>

<p>说明：</p>
<p>所有输入均为小写字母。<br>不考虑答案输出的顺序。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/group-anagrams">https://leetcode-cn.com/problems/group-anagrams</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法1：map"><a href="#解法1：map" class="headerlink" title="解法1：map"></a>解法1：map</h4><p>思路：</p>
<p>用map将每个词存起来</p>
<p>​    1)将词存起来的时候我们可以先对这个词各个字母进行排序，这样再把排序后的词当做map的键，这样便于后面的分类</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        map&lt;string,vector&lt;string&gt;&gt; m;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">        <span class="keyword">int</span> i,n=strs.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            string str=strs[i];</span><br><span class="line">            <span class="built_in">sort</span>(str.<span class="built_in">begin</span>(),str.<span class="built_in">end</span>());</span><br><span class="line">            m[str].<span class="built_in">push_back</span>(strs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:m)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(i.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>map</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-5.最长回文子串</title>
    <url>/2019/08/21/leetcode/1-100/5.zui-chang-hui-wen-zi-chuan/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p><img src="/../../../images/lc5.png" alt="lc5"></p>
<span id="more"></span>

<h4 id="解法1：动态规划"><a href="#解法1：动态规划" class="headerlink" title="解法1：动态规划"></a>解法1：动态规划</h4><p>1.定义dp数组</p>
<p>定义一个bool型dp二维数组dp[i][j]，i表示开始位置，j表示结束位置,true表示是回文子串</p>
<p>2.初始状态</p>
<ul>
<li><code>dp[i][i]=1; //单个字符是回文串</code></li>
<li><code>dp[i][i+1]=1 if s[i]=s[i+1]; //连续两个相同字符是回文串</code></li>
</ul>
<p>3.状态转移方程</p>
<p><code>dp[i][j]=dp[i+1][j-1]</code>&amp;&amp; $s_i==s_j$</p>
<p>4.初始化一字母和二字母回文，然后找到所有三字母，以此类推</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> n=s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;  <span class="built_in">bp</span>(n,vector&lt;<span class="keyword">int</span>&gt;(n));<span class="comment">//定义二维动态数组</span></span><br><span class="line">        <span class="keyword">int</span> l;</span><br><span class="line">        <span class="keyword">int</span> length=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            bp[i][i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>((i&lt;n<span class="number">-1</span>)&amp;&amp;s[i]==s[i+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                bp[i][i+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">                length=<span class="number">2</span>;</span><br><span class="line">                start=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(l=<span class="number">3</span>;l&lt;=n;l++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>;i+l<span class="number">-1</span>&lt;n;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> j=i+l<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">if</span>(s[i]==s[j]&amp;&amp;(bp[i+<span class="number">1</span>][j<span class="number">-1</span>]==<span class="number">1</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    bp[i][j]=<span class="number">1</span>;</span><br><span class="line">                    length=l;</span><br><span class="line">                    start=i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(start,length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>复杂度分析</p>
<ul>
<li>时间复杂度（$n^2$）</li>
<li>空间复杂度（$n^2$）</li>
</ul>
<h4 id="解法2：中心扩展算法"><a href="#解法2：中心扩展算法" class="headerlink" title="解法2：中心扩展算法"></a>解法2：中心扩展算法</h4><p>事实上，只需使用恒定的空间，我们就可以在 O($n^2$) 的时间内解决这个问题。 </p>
<p>我们知道回文串一定是对称的，所以我们可以每次循环选择一个中心，进行左右扩展，判断左右字符是否相等即可。 </p>
<p>由于存在奇数的字符串和偶数的字符串，所以我们需要从一个字符开始扩展，或者从两个字符之间开始扩展，所以总共有 n + n - 1 个中心。 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> n=s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">int</span> length=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> len1=<span class="built_in">expandAroundCenter</span>(s,i,i);</span><br><span class="line">            <span class="keyword">int</span> len2=<span class="built_in">expandAroundCenter</span>(s,i,i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> len=<span class="built_in">max</span>(len1,len2);</span><br><span class="line">            <span class="keyword">if</span>(len&gt;length)</span><br><span class="line">            &#123;</span><br><span class="line">                start=i-(len<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">                length=len;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(start,length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">expandAroundCenter</span><span class="params">(string s,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=left,r=right;</span><br><span class="line">        <span class="keyword">while</span>(l&gt;=<span class="number">0</span>&amp;&amp;r&lt;s.<span class="built_in">length</span>()&amp;&amp;s[l]==s[r])</span><br><span class="line">        &#123;</span><br><span class="line">            l--;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r-l<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>复杂度分析</p>
<ul>
<li>时间复杂度（$n^2$）</li>
<li>空间复杂度（1）</li>
</ul>
<h4 id="解法3-Manacher’s-Algorithm-马拉车算法"><a href="#解法3-Manacher’s-Algorithm-马拉车算法" class="headerlink" title="解法3.Manacher’s Algorithm 马拉车算法"></a>解法3.Manacher’s Algorithm 马拉车算法</h4><blockquote>
<p>马拉车算法 Manacher‘s Algorithm 是用来查找一个字符串的最长回文子串的线性方法，由一个叫Manacher的人在1975年发明的，这个方法的最大贡献是在于将时间复杂度提升到了线性。 </p>
</blockquote>
<p>参考下边链接。</p>
<p><a href="https://segmentfault.com/a/1190000008484167">https://segmentfault.com/a/1190000008484167</a></p>
<p><a href="https://blog.crimx.com/2017/07/06/manachers-algorithm/">https://blog.crimx.com/2017/07/06/manachers-algorithm/</a></p>
<p><a href="http://ju.outofmemory.cn/entry/130005">http://ju.outofmemory.cn/entry/130005</a></p>
<p><a href="https://articles.leetcode.com/longest-palindromic-substring-part-ii/">https://articles.leetcode.com/longest-palindromic-substring-part-ii/</a></p>
<p><a href="https://leetcode.wang/leetCode-5-Longest-Palindromic-Substring.html">https://leetcode.wang/leetCode-5-Longest-Palindromic-Substring.html</a></p>
]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-51.N皇后</title>
    <url>/2019/09/07/leetcode/1-100/51.n-huang-hou/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
<p><img src="/../../../images/8-queens.png" alt="8-queens"></p>
<span id="more"></span>

<p>上图为 8 皇后问题的一种解法。</p>
<p>给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。</p>
<p>每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p>
<p>示例:</p>
<p>输入: 4<br>输出: [<br> [“.Q..”,  // 解法 1<br>  “…Q”,<br>  “Q…”,<br>  “..Q.”],</p>
<p> [“..Q.”,  // 解法 2<br>  “Q…”,<br>  “…Q”,<br>  “.Q..”]<br>]<br>解释: 4 皇后问题存在两个不同的解法。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/n-queens">https://leetcode-cn.com/problems/n-queens</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法1：回溯"><a href="#解法1：回溯" class="headerlink" title="解法1：回溯"></a>解法1：回溯</h4><p>记录列，对角线，反对角线的棋子放置情况，采用回溯</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">solveNQueens</span>(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">pre</span><span class="params">(n,string(n,<span class="string">&#x27;.&#x27;</span>))</span></span>;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">col</span><span class="params">(n,<span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">ll</span><span class="params">(<span class="number">2</span>*n<span class="number">-1</span>,<span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">rr</span><span class="params">(<span class="number">2</span>*n<span class="number">-1</span>,<span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> row=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">solve</span>(n,row,col,ll,rr,pre,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> row,vector&lt;<span class="keyword">bool</span>&gt; &amp;col,vector&lt;<span class="keyword">bool</span>&gt; &amp;ll,vector&lt;<span class="keyword">bool</span>&gt; &amp;rr,vector&lt;string&gt; &amp;pre,vector&lt;vector&lt;string&gt;&gt; &amp;res)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">if</span>(row==n)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(pre);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>  i=row;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j!=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(col[j]==<span class="literal">true</span>||ll[i+j]==<span class="literal">true</span>||rr[i-j+n<span class="number">-1</span>]==<span class="literal">true</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            col[j]=<span class="literal">true</span>;</span><br><span class="line">            ll[i+j]=<span class="literal">true</span>;</span><br><span class="line">            rr[i-j+n<span class="number">-1</span>]=<span class="literal">true</span>;</span><br><span class="line">            pre[i][j]=<span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            <span class="built_in">solve</span>(n,row+<span class="number">1</span>,col,ll,rr,pre,res);</span><br><span class="line">            pre[i][j]=<span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            </span><br><span class="line">            col[j]=<span class="literal">false</span>;</span><br><span class="line">            ll[i+j]=<span class="literal">false</span>;</span><br><span class="line">            rr[i-j+n<span class="number">-1</span>]=<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-50.Pow(x,n)</title>
    <url>/2019/09/03/leetcode/1-100/50.pow-x-n/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>实现 pow(x, n) ，即计算 x 的 n 次幂函数。</p>
<span id="more"></span>

<p>示例 1:</p>
<p>输入: 2.00000, 10<br>输出: 1024.00000<br>示例 2:</p>
<p>输入: 2.10000, 3<br>输出: 9.26100<br>示例 3:</p>
<p>输入: 2.00000, -2<br>输出: 0.25000<br>解释: 2-2 = 1/22 = 1/4 = 0.25<br>说明:</p>
<p>-100.0 &lt; x &lt; 100.0<br>n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/powx-n">https://leetcode-cn.com/problems/powx-n</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法1：快速幂（递归）"><a href="#解法1：快速幂（递归）" class="headerlink" title="解法1：快速幂（递归）"></a>解法1：快速幂（递归）</h4><p>借鉴：leetcode官方</p>
<p>假设我们已经得到了$x^n$,我们如何得 $x^{2n}$呢？很明显我们不需要再将x再乘n次，我们直接使用$(x^n)^2=x^{2n}$,通过一次计算，我们就得到了结果值</p>
<p>同样对于$x^n$我们可以通过求$x^{n/2}$（A）来得到$x^n$我们可以根据n的奇偶性来分别讨论$x^n$的值。如果n为偶，那么$(x^n)^2=x^{2n}$来得到$x^n$=A*A如果n为奇数那么$x^n$= A * A *x</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">fastPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> <span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> half = <span class="built_in">fastPow</span>(x, n / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> half * half;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> half * half * x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> N = n;</span><br><span class="line">        <span class="keyword">if</span> (N &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = <span class="number">1</span> / x;</span><br><span class="line">            N = -N;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">fastPow</span>(x, N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="解法2：快速幂（循环）"><a href="#解法2：快速幂（循环）" class="headerlink" title="解法2：快速幂（循环）"></a>解法2：快速幂（循环）</h4><p>使用公式$x^{a+b}=x^a+x^b$我们可以将n看做一系列正整数之和，即n=$b_1+b_2+b_3+……+b_n$那么到底将n分成那些数的和呢，我们可以以x的10次方为例，10的二进制为1010，然后把它展成2的幂次的和。</p>
<p>$x^{10}=x^{(1010)_2}=x^{1<em>2^3+0</em>2^2+1<em>2^1+0</em>2^0}$即$x^{10}=x^{2^3}*x^{2^1}$</p>
<p>同时10的二进制数 在 3 1 位置为1 也就是说我们把1位置对应的项累乘就能得到结果，</p>
<p>那么累成的项，我们可以发现前一项是后一项的自乘，即$x^8=x^4*x^4$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> N=n;</span><br><span class="line">        <span class="keyword">if</span>(N&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            N=-N;</span><br><span class="line">            x=<span class="number">1</span>/x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> res=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(N)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(N&amp;<span class="number">1</span>)</span><br><span class="line">                res*=x;</span><br><span class="line">            x*=x;</span><br><span class="line">            N&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-52.N皇后II</title>
    <url>/2019/09/07/leetcode/1-100/52.n-huang-hou-ii/</url>
    <content><![CDATA[<p>这题让返回总共解法数，与上题一样，直接改为统计个数就行了</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">col</span><span class="params">(n,<span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">ll</span><span class="params">(<span class="number">2</span>*n<span class="number">-1</span>,<span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">rr</span><span class="params">(<span class="number">2</span>*n<span class="number">-1</span>,<span class="literal">false</span>)</span></span>;</span><br><span class="line">        _col=&amp;col;</span><br><span class="line">        _ll=&amp;ll;</span><br><span class="line">        _rr=&amp;rr;</span><br><span class="line">        <span class="keyword">int</span> row=<span class="number">0</span>;</span><br><span class="line">        total=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">totaln</span>(n,row);</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">totaln</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> row)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">if</span>(row==n)</span><br><span class="line">        &#123;</span><br><span class="line">            total++;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i=row;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j!=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((*_col)[j]==<span class="literal">true</span>||(*_ll)[i+j]==<span class="literal">true</span>||(*_rr)[i-j+n<span class="number">-1</span>]==<span class="literal">true</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            (*_col)[j]=<span class="literal">true</span>;</span><br><span class="line">            (*_ll)[i+j]=<span class="literal">true</span>;</span><br><span class="line">            (*_rr)[i-j+n<span class="number">-1</span>]=<span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">totaln</span>(n,row+<span class="number">1</span>);</span><br><span class="line">            (*_col)[j]=<span class="literal">false</span>;</span><br><span class="line">            (*_ll)[i+j]=<span class="literal">false</span>;</span><br><span class="line">            (*_rr)[i-j+n<span class="number">-1</span>]=<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="keyword">bool</span>&gt;* _col=<span class="literal">nullptr</span>;</span><br><span class="line">    vector&lt;<span class="keyword">bool</span>&gt;* _ll=<span class="literal">nullptr</span>;</span><br><span class="line">    vector&lt;<span class="keyword">bool</span>&gt;* _rr=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">int</span> total;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-53.最大子序和</title>
    <url>/2019/09/07/leetcode/1-100/53.zui-da-zi-xu-he/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>示例:</p>
<p>输入: [-2,1,-3,4,-1,2,1,-5,4],<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。<br>进阶:</p>
<p>如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。</p>
<span id="more"></span>

<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/maximum-subarray">https://leetcode-cn.com/problems/maximum-subarray</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法1：动态规划"><a href="#解法1：动态规划" class="headerlink" title="解法1：动态规划"></a>解法1：动态规划</h4><p>思路：</p>
<p>1.记录当前连续子数组的和，若当前和加上这个位置的数小于当前和，就让这个位置变为当前和，负责加上当前位置。每次都判断最大和，与当前和的最大值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>,res=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(sum+nums[i]&gt;nums[i])</span><br><span class="line">                sum+=nums[i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                sum=nums[i];</span><br><span class="line">            res=<span class="built_in">max</span>(res,sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-54.螺旋矩阵</title>
    <url>/2019/09/07/leetcode/1-100/54.luo-xuan-ju-zhen/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。</p>
<span id="more"></span>

<p>示例 1:</p>
<p>输入:<br>[<br> [ 1, 2, 3 ],<br> [ 4, 5, 6 ],<br> [ 7, 8, 9 ]<br>]<br>输出: [1,2,3,6,9,8,7,4,5]<br>示例 2:</p>
<p>输入:<br>[<br>  [1, 2, 3, 4],<br>  [5, 6, 7, 8],<br>  [9,10,11,12]<br>]<br>输出: [1,2,3,4,8,12,11,10,9,5,6,7]</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/spiral-matrix">https://leetcode-cn.com/problems/spiral-matrix</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法1：模拟"><a href="#解法1：模拟" class="headerlink" title="解法1：模拟"></a>解法1：模拟</h4><p>完全模拟螺旋矩阵，考虑各种情况，代码比较乱</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=matrix.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;matrix[<span class="number">0</span>].<span class="built_in">size</span>();i++)</span><br><span class="line">                res.<span class="built_in">push_back</span>(matrix[<span class="number">0</span>][i]);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m=matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">used</span>(n,vector&lt;<span class="keyword">bool</span>&gt;(m,<span class="literal">false</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> r=<span class="number">0</span>,c=<span class="number">1</span>,i=<span class="number">0</span>,j=<span class="number">0</span>,x=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l=n*m;</span><br><span class="line">        <span class="keyword">while</span>(x++&lt;l)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(matrix[i][j]);</span><br><span class="line">           </span><br><span class="line">            used[i][j]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(j==m<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                c=<span class="number">0</span>;</span><br><span class="line">                r=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(i==n<span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    r=<span class="number">0</span>;</span><br><span class="line">                    c=<span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i==n<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                c=<span class="number">-1</span>;</span><br><span class="line">                r=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(j==<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    r=<span class="number">-1</span>;c=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j==<span class="number">0</span>&amp;&amp;i!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                c=<span class="number">0</span>;</span><br><span class="line">                r=<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    r=<span class="number">0</span>;c=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> qm=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(used[i+r][j+c]!=<span class="literal">false</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span>(r==<span class="number">0</span>&amp;&amp;c==<span class="number">1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        r=<span class="number">1</span>;c=<span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(r==<span class="number">1</span>&amp;&amp;c==<span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        r=<span class="number">0</span>;c=<span class="number">-1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(r==<span class="number">0</span>&amp;&amp;c==<span class="number">-1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        r=<span class="number">-1</span>;c=<span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(r==<span class="number">-1</span>&amp;&amp;c==<span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        r=<span class="number">0</span>;c=<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    qm++;</span><br><span class="line">                    <span class="keyword">if</span>(qm==<span class="number">4</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            i+=r;</span><br><span class="line">            j+=c;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="解法2：模拟"><a href="#解法2：模拟" class="headerlink" title="解法2：模拟"></a>解法2：模拟</h4><p>改变思想，</p>
<p>这次我们改变边界值，使得代码简洁了很多</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=matrix.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=matrix[<span class="number">0</span>].<span class="built_in">size</span>()<span class="number">-1</span>,t=<span class="number">0</span>,b=matrix.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r&amp;&amp;t&lt;=b)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(matrix[t][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            t++;</span><br><span class="line">            <span class="keyword">if</span>(t&gt;b) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=t;i&lt;=b;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(matrix[i][r]);</span><br><span class="line">            &#125;</span><br><span class="line">            r--;</span><br><span class="line">            <span class="keyword">if</span>(l&gt;r) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=r;i&gt;=l;i--)</span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(matrix[b][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            b--;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=b;i&gt;=t;i--)</span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(matrix[i][l]);</span><br><span class="line">            &#125;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-55.跳跃游戏</title>
    <url>/2019/09/07/leetcode/1-100/55.tiao-yue-you-xi/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达最后一个位置。</p>
<span id="more"></span>

<p>示例 1:</p>
<p>输入: [2,3,1,1,4]<br>输出: true<br>解释: 从位置 0 到 1 跳 1 步, 然后跳 3 步到达最后一个位置。<br>示例 2:</p>
<p>输入: [3,2,1,0,4]<br>输出: false<br>解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/jump-game">https://leetcode-cn.com/problems/jump-game</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法1：贪心"><a href="#解法1：贪心" class="headerlink" title="解法1：贪心"></a>解法1：贪心</h4><p>定义当前能达到的最大位置end，更新每次的end值，最后判断end值与n-1的关系</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> end=<span class="number">0</span>,start=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(start&lt;=end&amp;&amp;end&lt;n<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            end=<span class="built_in">max</span>(end,nums[start]+start);</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> end&gt;=n<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-56.合并区间</title>
    <url>/2019/09/07/leetcode/1-100/56.he-bing-qu-jian/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给出一个区间的集合，请合并所有重叠的区间。</p>
<span id="more"></span>

<p>示例 1:</p>
<p>输入: [[1,3],[2,6],[8,10],[15,18]]<br>输出: [[1,6],[8,10],[15,18]]<br>解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].<br>示例 2:</p>
<p>输入: [[1,4],[4,5]]<br>输出: [[1,5]]<br>解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/merge-intervals">https://leetcode-cn.com/problems/merge-intervals</a></p>
<p>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处.</p>
<h4 id="解法1：贪心"><a href="#解法1：贪心" class="headerlink" title="解法1：贪心"></a>解法1：贪心</h4><p>思路：</p>
<p>1.先对区间排序，按左区间大小从小到达排序</p>
<p>2.选择一个为a，判断后面的b区间，若a[1]&gt;=b[0],则证明区间重叠，更新区间范围，为max(a[1],b[1])</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(),intervals.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; pre;</span><br><span class="line">        <span class="keyword">int</span> i,n=intervals.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        pre.<span class="built_in">push_back</span>(intervals[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">        pre.<span class="built_in">push_back</span>(intervals[<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>]&lt;=pre[<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(pre[<span class="number">1</span>]&gt;=intervals[i][<span class="number">1</span>])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    pre[<span class="number">1</span>]=intervals[i][<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(pre);</span><br><span class="line">                pre.<span class="built_in">clear</span>();</span><br><span class="line">                pre.<span class="built_in">push_back</span>(intervals[i][<span class="number">0</span>]);</span><br><span class="line">                pre.<span class="built_in">push_back</span>(intervals[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!pre.<span class="built_in">empty</span>())</span><br><span class="line">            res.<span class="built_in">push_back</span>(pre);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-57.插入区间</title>
    <url>/2019/09/07/leetcode/1-100/57.cha-ru-qu-jian/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给出一个无重叠的 ，按照区间起始端点排序的区间列表。</p>
<p>在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。</p>
<span id="more"></span>

<p>示例 1:</p>
<p>输入: intervals = [[1,3],[6,9]], newInterval = [2,5]<br>输出: [[1,5],[6,9]]<br>示例 2:</p>
<p>输入: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]<br>输出: [[1,2],[3,10],[12,16]]<br>解释: 这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/insert-interval">https://leetcode-cn.com/problems/insert-interval</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法1：暴力"><a href="#解法1：暴力" class="headerlink" title="解法1：暴力"></a>解法1：暴力</h4><p>考虑各种情况，完全模拟，代码很乱</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">insert</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals, vector&lt;<span class="keyword">int</span>&gt;&amp; newInterval) &#123;</span><br><span class="line">        <span class="keyword">int</span> n=intervals.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(newInterval);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i,l=n;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; pre;</span><br><span class="line">        <span class="keyword">if</span>(newInterval[<span class="number">1</span>]&lt;intervals[<span class="number">0</span>][<span class="number">0</span>])      <span class="comment">//  放在头部，且不用合并</span></span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(newInterval);</span><br><span class="line">            l=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(newInterval[<span class="number">0</span>]&lt;=intervals[i][<span class="number">1</span>])           <span class="comment">//找到插入位置</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(newInterval[<span class="number">1</span>]&lt;=intervals[i][<span class="number">1</span>]&amp;&amp;newInterval[<span class="number">0</span>]&gt;=intervals[i][<span class="number">0</span>])    <span class="comment">//插入位置被包含在一个区间，直接返回，不用合并</span></span><br><span class="line">                    &#123;   </span><br><span class="line">                        <span class="keyword">return</span> intervals;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(newInterval[<span class="number">0</span>]&lt;=intervals[i][<span class="number">0</span>])     <span class="comment">//  判断新的插入位置，以哪个作为左位置，是新区间还是要插入的这个区间</span></span><br><span class="line">                        pre.<span class="built_in">push_back</span>(newInterval[<span class="number">0</span>]);</span><br><span class="line">                    <span class="keyword">else</span> pre.<span class="built_in">push_back</span>(intervals[i][<span class="number">0</span>]);</span><br><span class="line">                    <span class="keyword">int</span> j=i;</span><br><span class="line">                    <span class="keyword">for</span>(;j&lt;n;j++)                           </span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(newInterval[<span class="number">1</span>]&lt;intervals[j][<span class="number">0</span>])          <span class="comment">//找到右位置应插入的位置</span></span><br><span class="line">                        &#123;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span>(newInterval[<span class="number">1</span>]&lt;intervals[j<span class="number">-1</span>][<span class="number">1</span>])        <span class="comment">//如果右位置比上一个区间的右位置小，把上一区间右位置记录</span></span><br><span class="line">                                pre.<span class="built_in">push_back</span>(intervals[j<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                pre.<span class="built_in">push_back</span>(newInterval[<span class="number">1</span>]);          <span class="comment">//否则记录右位置</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    l=j;</span><br><span class="line">                    <span class="keyword">if</span>(newInterval[<span class="number">1</span>]&gt;=intervals[n<span class="number">-1</span>][<span class="number">1</span>])               <span class="comment">//如果插入区间右区间在最后，进行判断</span></span><br><span class="line">                        pre.<span class="built_in">push_back</span>(newInterval[<span class="number">1</span>]);</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(newInterval[<span class="number">1</span>]&gt;=intervals[n<span class="number">-1</span>][<span class="number">0</span>])</span><br><span class="line">                        pre.<span class="built_in">push_back</span>(intervals[n<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">                    res.<span class="built_in">push_back</span>(pre);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                res.<span class="built_in">push_back</span>(intervals[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;n)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(intervals[l]);</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(newInterval[<span class="number">0</span>]&gt;intervals[n<span class="number">-1</span>][<span class="number">1</span>])                    <span class="comment">//如果插入区间左区间在最后</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(newInterval);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O（N）</p>
<h4 id="解法2：插入，合并"><a href="#解法2：插入，合并" class="headerlink" title="解法2：插入，合并"></a>解法2：插入，合并</h4><p>直接把新节点插入到最后，然后按照56题合并区间进行合并</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">insert</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals, vector&lt;<span class="keyword">int</span>&gt;&amp; newInterval) &#123;</span><br><span class="line">        intervals.<span class="built_in">push_back</span>(newInterval);</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(),intervals.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; pre;</span><br><span class="line">        <span class="keyword">int</span> i,n=intervals.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        pre.<span class="built_in">push_back</span>(intervals[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">        pre.<span class="built_in">push_back</span>(intervals[<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>]&lt;=pre[<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(pre[<span class="number">1</span>]&gt;=intervals[i][<span class="number">1</span>])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    pre[<span class="number">1</span>]=intervals[i][<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(pre);</span><br><span class="line">                pre.<span class="built_in">clear</span>();</span><br><span class="line">                pre.<span class="built_in">push_back</span>(intervals[i][<span class="number">0</span>]);</span><br><span class="line">                pre.<span class="built_in">push_back</span>(intervals[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!pre.<span class="built_in">empty</span>())</span><br><span class="line">            res.<span class="built_in">push_back</span>(pre);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O（NlogN）</p>
<h4 id="解法3：找左右重合区域"><a href="#解法3：找左右重合区域" class="headerlink" title="解法3：找左右重合区域"></a>解法3：找左右重合区域</h4><p>1.先找到左边重合区域，即若newInterval[0] &gt; intervals[i][1]就将intervals加入res。</p>
<p>2.找右边重合区域，若newInterval[1] &gt;= intervals[i][0]就与temp找到区间范围最大的</p>
<p>3.最后将后面未遍历的intervals添加进res</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">insert</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals, vector&lt;<span class="keyword">int</span>&gt;&amp; newInterval) &#123;</span><br><span class="line">        intervals.<span class="built_in">push_back</span>(newInterval);</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(),intervals.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; pre;</span><br><span class="line">        <span class="keyword">int</span> i,n=intervals.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        pre.<span class="built_in">push_back</span>(intervals[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">        pre.<span class="built_in">push_back</span>(intervals[<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>]&lt;=pre[<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(pre[<span class="number">1</span>]&gt;=intervals[i][<span class="number">1</span>])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    pre[<span class="number">1</span>]=intervals[i][<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(pre);</span><br><span class="line">                pre.<span class="built_in">clear</span>();</span><br><span class="line">                pre.<span class="built_in">push_back</span>(intervals[i][<span class="number">0</span>]);</span><br><span class="line">                pre.<span class="built_in">push_back</span>(intervals[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!pre.<span class="built_in">empty</span>())</span><br><span class="line">            res.<span class="built_in">push_back</span>(pre);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-58.最后一个单词长度</title>
    <url>/2019/09/11/leetcode/1-100/58.zui-hou-yi-ge-dan-ci-de-chang-du/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个仅包含大小写字母和空格 ‘ ‘ 的字符串，返回其最后一个单词的长度。</p>
<p>如果不存在最后一个单词，请返回 0 。</p>
<p>说明：一个单词是指由字母组成，但不包含任何空格的字符串。</p>
<span id="more"></span>

<p>示例:</p>
<p>输入: “Hello World”<br>输出: 5</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/length-of-last-word">https://leetcode-cn.com/problems/length-of-last-word</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法1：暴力模拟"><a href="#解法1：暴力模拟" class="headerlink" title="解法1：暴力模拟"></a>解法1：暴力模拟</h4><p>先把尾部的空格清除，然后从后向前遍历，找到空格或者到达头部停止，记录长度</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLastWord</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        i=n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]!=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-59.螺旋矩阵II</title>
    <url>/2019/09/11/leetcode/1-100/59.luo-xuan-ju-zhen-ii/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个正整数 n，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。</p>
<span id="more"></span>

<p>示例:</p>
<p>输入: 3<br>输出:<br>[<br> [ 1, 2, 3 ],<br> [ 8, 9, 4 ],<br> [ 7, 6, 5 ]<br>]</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/spiral-matrix-ii">https://leetcode-cn.com/problems/spiral-matrix-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法1：模拟"><a href="#解法1：模拟" class="headerlink" title="解法1：模拟"></a>解法1：模拟</h4><p>模拟螺旋矩阵，不断更新四个边界值，与54螺旋矩阵相似</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span> i,t=<span class="number">0</span>,b=n<span class="number">-1</span>,r=n<span class="number">-1</span>,l=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num=<span class="number">1</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">res</span>(n,vector&lt;<span class="keyword">int</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">while</span>(num&lt;=n*n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(i=l;i&lt;=r;i++)</span><br><span class="line">                res[t][i]=num++;</span><br><span class="line">            t++;</span><br><span class="line">            <span class="keyword">for</span>(i=t;i&lt;=b;i++)</span><br><span class="line">                res[i][r]=num++;</span><br><span class="line">            r--;</span><br><span class="line">            <span class="keyword">for</span>(i=r;i&gt;=l;i--)</span><br><span class="line">                res[b][i]=num++;</span><br><span class="line">            b--;</span><br><span class="line">            <span class="keyword">for</span>(i=b;i&gt;=t;i--)</span><br><span class="line">                res[i][l]=num++;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-6. Z 字形变换</title>
    <url>/2019/08/20/leetcode/1-100/6.z-zi-xing-bian-huan/</url>
    <content><![CDATA[<h4 id="6-Z-字形变换"><a href="#6-Z-字形变换" class="headerlink" title="6. Z 字形变换"></a><a href="https://leetcode-cn.com/problems/zigzag-conversion/">6. Z 字形变换</a></h4><p>思路：</p>
<p>设置一个方向指针，发现z规律</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">convert</span><span class="params">(string s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numRows==<span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">rows</span><span class="params">(min(<span class="keyword">int</span>(s.length()),numRows))</span></span>;</span><br><span class="line">        <span class="keyword">int</span> curRow=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> go=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:s)</span><br><span class="line">        &#123;</span><br><span class="line">            rows[curRow]+=c;</span><br><span class="line">            <span class="keyword">if</span>(curRow==<span class="number">0</span>||curRow==numRows<span class="number">-1</span>)    go=!go;</span><br><span class="line">            curRow+=(go)?<span class="number">1</span>:<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        string m;</span><br><span class="line">        <span class="keyword">for</span>(string row:rows)</span><br><span class="line">            m+=row;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-60.第k个排列</title>
    <url>/2019/09/11/leetcode/1-100/60.di-k-ge-pai-lie/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。</p>
<p>按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：</p>
<p>“123”<br>“132”<br>“213”<br>“231”<br>“312”<br>“321”<br>给定 n 和 k，返回第 k 个排列。</p>
<p>说明：</p>
<p>给定 n 的范围是 [1, 9]。<br>给定 k 的范围是[1,  n!]。</p>
<span id="more"></span>

<p>示例 1:</p>
<p>输入: n = 3, k = 3<br>输出: “213”<br>示例 2:</p>
<p>输入: n = 4, k = 9<br>输出: “2314”</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/permutation-sequence">https://leetcode-cn.com/problems/permutation-sequence</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法1：回溯-剪枝"><a href="#解法1：回溯-剪枝" class="headerlink" title="解法1：回溯+剪枝"></a>解法1：回溯+剪枝</h4><p>思路：</p>
<p>明显的回溯题，一开始自信满满写了个回溯模板，一提交，TL出现，</p>
<p>思考：我们没有进行剪枝优化，</p>
<p>1.每次进入一个新的分支时，我们判断这个分支的叶子节点数是否大于k，如果小于k表示这个分支的所有的排列都不是我们要的第k个排列，我们就进行剪枝，让k=k-这个分支叶子节点数，然后判断下一个分支。循环重复，找到第k个排列。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">used</span><span class="params">(n,<span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        string temp;</span><br><span class="line">        <span class="keyword">int</span> factorial[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">24</span>, <span class="number">120</span>, <span class="number">720</span>, <span class="number">5040</span>, <span class="number">40320</span>, <span class="number">362880</span>&#125;;</span><br><span class="line">        m=<span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">search</span>(k,used,n,count,temp,factorial);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> k,vector&lt;<span class="keyword">bool</span>&gt; &amp;used,<span class="keyword">int</span> n,<span class="keyword">int</span> count,string temp,<span class="keyword">int</span> factorial[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count==n)</span><br><span class="line">        &#123;</span><br><span class="line">            m=<span class="literal">true</span>;</span><br><span class="line">            res=temp;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> p=factorial[n<span class="number">-1</span>-count];</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(used[i])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(p&lt;k)</span><br><span class="line">            &#123;</span><br><span class="line">                k-=p;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            used[i]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">char</span> ch=<span class="string">&#x27;0&#x27;</span>+i+<span class="number">1</span>;</span><br><span class="line">         <span class="comment">//   cout&lt;&lt;temp&lt;&lt;endl;</span></span><br><span class="line">            <span class="built_in">search</span>(k,used,n,count+<span class="number">1</span>,temp+ch,factorial);</span><br><span class="line">            <span class="keyword">if</span>(m)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    </span><br><span class="line">    string res;</span><br><span class="line">    <span class="keyword">bool</span> m;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>回溯</tag>
        <tag>剪枝</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-61.旋转链表</title>
    <url>/2019/09/11/leetcode/1-100/61.xuan-zhuan-lian-biao/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。</p>
<span id="more"></span>

<p>示例 1:</p>
<p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2<br>输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL<br>解释:<br>向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL<br>向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL<br>示例 2:</p>
<p>输入: 0-&gt;1-&gt;2-&gt;NULL, k = 4<br>输出: 2-&gt;0-&gt;1-&gt;NULL<br>解释:<br>向右旋转 1 步: 2-&gt;0-&gt;1-&gt;NULL<br>向右旋转 2 步: 1-&gt;2-&gt;0-&gt;NULL<br>向右旋转 3 步: 0-&gt;1-&gt;2-&gt;NULL<br>向右旋转 4 步: 2-&gt;0-&gt;1-&gt;NULL</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/rotate-list">https://leetcode-cn.com/problems/rotate-list</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法1：双指针"><a href="#解法1：双指针" class="headerlink" title="解法1：双指针"></a>解法1：双指针</h4><p>思路：</p>
<p>1.先遍历链表确定链表长度len。</p>
<p>2.k对len取余，确定实际右移了几个位置。</p>
<p>3.先让前指针移动k个单位，然后前后指针同时移动，直到前指针的下一位为空。此时后指针所在位置就是右移后的末位指针。</p>
<p>4.先把前指针与原链表头指针链接，然后让头指针指向后指针的下一位，然后让后指针下一位指向空，返回头指针head</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">rotateRight</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode *p=head;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(len&lt;=<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        k%=len;</span><br><span class="line">        ListNode *pr=head;</span><br><span class="line">        <span class="keyword">while</span>(k--&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pr=pr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *pl=head;</span><br><span class="line">        <span class="keyword">while</span>(pr-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pl=pl-&gt;next;</span><br><span class="line">            pr=pr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        pr-&gt;next=head;</span><br><span class="line">        head=pl-&gt;next;</span><br><span class="line">        pl-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-62.不同路径</title>
    <url>/2019/09/12/leetcode/1-100/62.bu-tong-lu-jing/</url>
    <content><![CDATA[<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>问总共有多少条不同的路径？</p>
<p><img src="/../../../images/lc62.png" alt="lc62"></p>
<p>例如，上图是一个7 x 3 的网格。有多少可能的路径？</p>
<p>说明：m 和 n 的值均不超过 100。</p>
<span id="more"></span>

<p>示例 1:</p>
<p>输入: m = 3, n = 2<br>输出: 3<br>解释:<br>从左上角开始，总共有 3 条路径可以到达右下角。</p>
<ol>
<li>向右 -&gt; 向右 -&gt; 向下</li>
<li>向右 -&gt; 向下 -&gt; 向右</li>
<li>向下 -&gt; 向右 -&gt; 向右<br>示例 2:</li>
</ol>
<p>输入: m = 7, n = 3<br>输出: 28</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/unique-paths">https://leetcode-cn.com/problems/unique-paths</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法1：动态规划"><a href="#解法1：动态规划" class="headerlink" title="解法1：动态规划"></a>解法1：动态规划</h4><p>1.定义二维数组dp[i][j]表示从左上角到第i行 第j列的路径总数</p>
<p>2.写出状态转移方程</p>
<p>dp[i][j]=dp[i-1][j]+dp[i][j-1]</p>
<p>因为每一步都只能从上方或者左方过来，所以将这两种情况一加就是这个位置的路径总数</p>
<p>3.初始化左上角路径总数为dp[0][1]=1；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(n+<span class="number">1</span>,vector&lt;<span class="keyword">int</span>&gt;(m+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n+<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;m+<span class="number">1</span>;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j]=dp[i<span class="number">-1</span>][j]+dp[i][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-63.不同路径II</title>
    <url>/2019/09/12/leetcode/1-100/63.bu-tong-lu-jing-ii/</url>
    <content><![CDATA[<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>
<p><img src="/../../../images/lc62.png" alt="lc62"></p>
<p>网格中的障碍物和空位置分别用 1 和 0 来表示。</p>
<p>说明：m 和 n 的值均不超过 100。</p>
<span id="more"></span>

<p>示例 1:</p>
<p>输入:<br>[<br>  [0,0,0],<br>  [0,1,0],<br>  [0,0,0]<br>]<br>输出: 2<br>解释:<br>3x3 网格的正中间有一个障碍物。<br>从左上角到右下角一共有 2 条不同的路径：</p>
<ol>
<li>向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</li>
<li>向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</li>
</ol>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/unique-paths-ii">https://leetcode-cn.com/problems/unique-paths-ii</a></p>
<p>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法1：动态规划"><a href="#解法1：动态规划" class="headerlink" title="解法1：动态规划"></a>解法1：动态规划</h4><p>思路：</p>
<p>跟上题一样采用动态规划，有了障碍物，额外判断下当目标地为障碍物的时候将路径总数为0，其他与62题相同。</p>
<p>注意数据量可能很大，采用long long防止溢出</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(obstacleGrid.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt; <span class="built_in">dp</span>(obstacleGrid.<span class="built_in">size</span>()+<span class="number">1</span>,vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(obstacleGrid[<span class="number">0</span>].<span class="built_in">size</span>()+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">int</span> n=obstacleGrid.<span class="built_in">size</span>(),m=obstacleGrid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n+<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;m+<span class="number">1</span>;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(obstacleGrid[i<span class="number">-1</span>][j<span class="number">-1</span>]==<span class="number">1</span>)</span><br><span class="line">                    dp[i][j]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j]+dp[i][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-64.最小路径和</title>
    <url>/2019/09/12/leetcode/1-100/64.zui-xiao-lu-jing-he/</url>
    <content><![CDATA[<p>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p>说明：每次只能向下或者向右移动一步。</p>
<span id="more"></span>

<p>示例:</p>
<p>输入:<br>[<br>  [1,3,1],<br>  [1,5,1],<br>  [4,2,1]<br>]<br>输出: 7<br>解释: 因为路径 1→3→1→1→1 的总和最小。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/minimum-path-sum">https://leetcode-cn.com/problems/minimum-path-sum</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法1：动态规划"><a href="#解法1：动态规划" class="headerlink" title="解法1：动态规划"></a>解法1：动态规划</h4><p>典型的dp问题</p>
<p>1.构建dp[i][j],表示从左上角到第i行第j列的最小和</p>
<p>2.状态转移方程</p>
<p>dp[i][j]=min(dp[i-1][j],dp[i][j-1])+grid[i][j];</p>
<p>3.初始化</p>
<p>dp[0][0]=grid[0][0]</p>
<p>dp[0][j]=dp[0][j-1]+grid[0][j]</p>
<p>dp[i][0]=dp[i-1][0]+grid[i][0]</p>
<p>注意：</p>
<p>我们可以用grid作为动态规划数组，这样我们就不用额外的空间来存储，空间复杂度变为了O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m=grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            grid[i][<span class="number">0</span>]=grid[i][<span class="number">0</span>]+grid[i<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            grid[<span class="number">0</span>][i]=grid[<span class="number">0</span>][i]+grid[<span class="number">0</span>][i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;m;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                grid[i][j]=<span class="built_in">min</span>(grid[i<span class="number">-1</span>][j],grid[i][j<span class="number">-1</span>])+grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid[n<span class="number">-1</span>][m<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-65.有效数字</title>
    <url>/2019/09/12/leetcode/1-100/65.you-xiao-shu-zi/</url>
    <content><![CDATA[<p>验证给定的字符串是否可以解释为十进制数字。</p>
<span id="more"></span>

<p>例如:</p>
<p>“0” =&gt; true<br>“ 0.1 “ =&gt; true<br>“abc” =&gt; false<br>“1 a” =&gt; false<br>“2e10” =&gt; true<br>“ -90e3   “ =&gt; true<br>“ 1e” =&gt; false<br>“e3” =&gt; false<br>“ 6e-1” =&gt; true<br>“ 99e2.5 “ =&gt; false<br>“53.5e93” =&gt; true<br>“ –6 “ =&gt; false<br>“-+3” =&gt; false<br>“95a54e53” =&gt; false</p>
<p>说明: 我们有意将问题陈述地比较模糊。在实现代码之前，你应当事先思考所有可能的情况。这里给出一份可能存在于有效十进制数字中的字符列表：</p>
<p>数字 0-9<br>指数 - “e”<br>正/负号 - “+”/“-“<br>小数点 - “.”<br>当然，在输入中，这些字符的上下文也很重要。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/valid-number">https://leetcode-cn.com/problems/valid-number</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法1：模拟"><a href="#解法1：模拟" class="headerlink" title="解法1：模拟"></a>解法1：模拟</h4><p>考虑各种情况模拟</p>
<p>1.先把前后空格去掉</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isNumber</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,e=<span class="number">0</span>,f=<span class="number">0</span>,d=<span class="number">0</span>,num=<span class="number">0</span>,k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(s[k]==<span class="string">&#x27; &#x27;</span>)     k++;</span><br><span class="line">        <span class="keyword">int</span> j=n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(s[j]==<span class="string">&#x27; &#x27;</span>)    j--;</span><br><span class="line">        n=j+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(k&gt;=n)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=k;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&#x27;0&#x27;</span>&lt;=s[i]&amp;&amp;s[i]&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;e&#x27;</span>&amp;&amp;e==<span class="number">0</span>&amp;&amp;i&gt;k&amp;&amp;i&lt;n<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="string">&#x27;0&#x27;</span>&gt;s[i+<span class="number">1</span>]||s[i+<span class="number">1</span>]&gt;<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(s[i+<span class="number">1</span>]!=<span class="string">&#x27;-&#x27;</span>&amp;&amp;s[i+<span class="number">1</span>]!=<span class="string">&#x27;+&#x27;</span>)    <span class="keyword">return</span> <span class="literal">false</span>;                        </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>((<span class="string">&#x27;0&#x27;</span>&lt;=s[i<span class="number">-1</span>]&amp;&amp;s[i<span class="number">-1</span>]&lt;=<span class="string">&#x27;9&#x27;</span>)||s[i<span class="number">-1</span>]==<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    e++;f=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>((s[i]==<span class="string">&#x27;-&#x27;</span>||s[i]==<span class="string">&#x27;+&#x27;</span>)&amp;&amp;f==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i==n<span class="number">-1</span>)  <span class="keyword">return</span> <span class="literal">false</span>;                    </span><br><span class="line">                <span class="keyword">if</span>(i&gt;k)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(s[i<span class="number">-1</span>]!=<span class="string">&#x27;e&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;                                           </span><br><span class="line">                &#125;</span><br><span class="line">                f++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;.&#x27;</span>&amp;&amp;e==<span class="number">0</span>&amp;&amp;d==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i==k)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(i==n<span class="number">-1</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(<span class="string">&#x27;0&#x27;</span>&gt;s[i+<span class="number">1</span>]||s[i+<span class="number">1</span>]&gt;<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="string">&#x27;0&#x27;</span>&gt;s[i<span class="number">-1</span>]||s[i<span class="number">-1</span>]&gt;<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(i==n<span class="number">-1</span>)</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&#x27;0&#x27;</span>&gt;s[i+<span class="number">1</span>]||s[i+<span class="number">1</span>]&gt;<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                d=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-66.加一</title>
    <url>/2019/09/22/leetcode/1-100/66.jia-yi/</url>
    <content><![CDATA[<p>给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。</p>
<p>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。</p>
<p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p>
<span id="more"></span>

<p>示例 1:</p>
<p>输入: [1,2,3]<br>输出: [1,2,4]<br>解释: 输入数组表示数字 123。<br>示例 2:</p>
<p>输入: [4,3,2,1]<br>输出: [4,3,2,2]<br>解释: 输入数组表示数字 4321。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/plus-one">https://leetcode-cn.com/problems/plus-one</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h4><p>两次翻转，各位单独处理。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">plusOne</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=digits.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">reverse</span>(digits.<span class="built_in">begin</span>(),digits.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        digits[<span class="number">0</span>]+=<span class="number">1</span>;</span><br><span class="line">        k=digits[<span class="number">0</span>]/<span class="number">10</span>;</span><br><span class="line">        digits[<span class="number">0</span>]%=<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n&amp;&amp;k!=<span class="number">0</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            digits[i]=digits[i]+<span class="number">1</span>;</span><br><span class="line">            k=digits[i]/<span class="number">10</span>;</span><br><span class="line">            digits[i]%=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k!=<span class="number">0</span>)</span><br><span class="line">            digits.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">reverse</span>(digits.<span class="built_in">begin</span>(),digits.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="解法2："><a href="#解法2：" class="headerlink" title="解法2："></a>解法2：</h4><p>分析+1的特性，两种情况</p>
<p>1.原位置是9，则+1后必然成为0，直到找到第一个不为9的位置，将该位置+1，返回数组</p>
<p>2.全部位置是9，则开头变为1，末位添1个0，就得到了结果。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">plusOne</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=digits.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(digits[i]==<span class="number">9</span>)</span><br><span class="line">                digits[i]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                digits[i]+=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> digits;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        digits[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        digits.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-67.二进制求和</title>
    <url>/2019/09/22/leetcode/1-100/67.er-jin-zhi-qiu-he/</url>
    <content><![CDATA[<p>给定两个二进制字符串，返回他们的和（用二进制表示）。</p>
<p>输入为非空字符串且只包含数字 1 和 0。</p>
<span id="more"></span>

<p>示例 1：</p>
<p>输入: a = “11”, b = “1”<br>输出: “100”<br>示例 2:</p>
<p>输入: a = “1010”, b = “1011”<br>输出: “10101”</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/add-binary">https://leetcode-cn.com/problems/add-binary</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法1：模拟"><a href="#解法1：模拟" class="headerlink" title="解法1：模拟"></a>解法1：模拟</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">addBinary</span><span class="params">(string a, string b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=a.<span class="built_in">size</span>(),m=b.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> i=n<span class="number">-1</span>,j=m<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> temp,t1,t2;</span><br><span class="line">        string c;</span><br><span class="line">        <span class="keyword">char</span> ch;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>&amp;&amp;j&gt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            t1=a[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            t2=b[j]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            temp=t1+t2+k;</span><br><span class="line">            k=temp/<span class="number">2</span>;</span><br><span class="line">            temp%=<span class="number">2</span>;</span><br><span class="line">            ch=temp+<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            c+=ch;</span><br><span class="line">          </span><br><span class="line">            i--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            t1=a[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            temp=t1+k;</span><br><span class="line">            k=temp/<span class="number">2</span>;</span><br><span class="line">            temp%=<span class="number">2</span>;</span><br><span class="line">            ch=temp+<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            c+=ch;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            t2=b[j]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            temp=t2+k;</span><br><span class="line">            k=temp/<span class="number">2</span>;</span><br><span class="line">            temp%=<span class="number">2</span>;</span><br><span class="line">            ch=temp+<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            c+=ch;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">if</span>(k!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ch=k+<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            c+=ch;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">reverse</span>(c.<span class="built_in">begin</span>(),c.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-68.文本左右对齐</title>
    <url>/2019/09/22/leetcode/1-100/68.wen-ben-zuo-you-dui-qi/</url>
    <content><![CDATA[<p>给定一个单词数组和一个长度 maxWidth，重新排版单词，使其成为每行恰好有 maxWidth 个字符，且左右两端对齐的文本。</p>
<p>你应该使用“贪心算法”来放置给定的单词；也就是说，尽可能多地往每行中放置单词。必要时可用空格 ‘ ‘ 填充，使得每行恰好有 maxWidth 个字符。</p>
<p>要求尽可能均匀分配单词间的空格数量。如果某一行单词间的空格不能均匀分配，则左侧放置的空格数要多于右侧的空格数。</p>
<p>文本的最后一行应为左对齐，且单词之间不插入额外的空格。</p>
<span id="more"></span>

<p>说明:</p>
<p>单词是指由非空格字符组成的字符序列。<br>每个单词的长度大于 0，小于等于 maxWidth。<br>输入单词数组 words 至少包含一个单词。<br>示例:</p>
<p>输入:<br>words = [“This”, “is”, “an”, “example”, “of”, “text”, “justification.”]<br>maxWidth = 16<br>输出:<br>[<br>   “This    is    an”,<br>   “example  of text”,<br>   “justification.  “<br>]<br>示例 2:</p>
<p>输入:<br>words = [“What”,”must”,”be”,”acknowledgment”,”shall”,”be”]<br>maxWidth = 16<br>输出:<br>[<br>  “What   must   be”,<br>  “acknowledgment  “,<br>  “shall be        “<br>]<br>解释: 注意最后一行的格式应为 “shall be    “ 而不是 “shall     be”,<br>     因为最后一行应为左对齐，而不是左右两端对齐。<br>     第二行同样为左对齐，这是因为这行只包含一个单词。<br>示例 3:</p>
<p>输入:<br>words = [“Science”,”is”,”what”,”we”,”understand”,”well”,”enough”,”to”,”explain”,<br>         “to”,”a”,”computer.”,”Art”,”is”,”everything”,”else”,”we”,”do”]<br>maxWidth = 20<br>输出:<br>[<br>  “Science  is  what we”,<br>  “understand      well”,<br>  “enough to explain to”,<br>  “a  computer.  Art is”,<br>  “everything  else  we”,<br>  “do                  “<br>]</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/text-justification">https://leetcode-cn.com/problems/text-justification</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法1：模拟"><a href="#解法1：模拟" class="headerlink" title="解法1：模拟"></a>解法1：模拟</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    vector&lt;string&gt; nowword;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">fullJustify</span><span class="params">(vector&lt;string&gt;&amp; words, <span class="keyword">int</span> maxWidth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">int</span> wordlen;</span><br><span class="line">        n=words.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> nowwordlen=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> nownum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> leftblank;</span><br><span class="line">        <span class="keyword">int</span> blank;</span><br><span class="line">        string temp;</span><br><span class="line">        i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n)</span><br><span class="line">        &#123;</span><br><span class="line">            wordlen=words[i].<span class="built_in">length</span>();</span><br><span class="line">            <span class="keyword">if</span>(nowwordlen+nownum+wordlen&lt;=maxWidth)         <span class="comment">//判断能否放入</span></span><br><span class="line">            &#123;</span><br><span class="line">                nowword.<span class="built_in">push_back</span>(words[i]);</span><br><span class="line">                nowwordlen+=wordlen;</span><br><span class="line">                nownum++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nownum==<span class="number">1</span>)                               <span class="comment">//如果只有一个单词左对齐</span></span><br><span class="line">                &#123;</span><br><span class="line">                    temp=words[i<span class="number">-1</span>];</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;maxWidth-words[i<span class="number">-1</span>].<span class="built_in">length</span>();j++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        temp+=<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">                    temp=<span class="string">&quot;&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>                                         <span class="comment">//多个单词</span></span><br><span class="line">                &#123;</span><br><span class="line">                    leftblank=(maxWidth-nowwordlen)%(nownum<span class="number">-1</span>);         <span class="comment">//左边放置空格多于右边的数量</span></span><br><span class="line">                    blank=(maxWidth-nowwordlen)/(nownum<span class="number">-1</span>);             <span class="comment">//若正好每个空格应放多少&quot; &quot;</span></span><br><span class="line">                    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">while</span>(leftblank--&gt;<span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        temp+=nowword[j];</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> z=<span class="number">0</span>;z&lt;blank+<span class="number">1</span>;z++)</span><br><span class="line">                        &#123;</span><br><span class="line">                            temp+=<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        j++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span>(j&lt;nownum<span class="number">-1</span>)                               <span class="comment">//  -1最后一个单词没有空格</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        temp+=nowword[j];</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> z=<span class="number">0</span>;z&lt;blank;z++)</span><br><span class="line">                        &#123;</span><br><span class="line">                            temp+=<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        j++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    temp+=nowword[j];       </span><br><span class="line">                    res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">                    temp=<span class="string">&quot;&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                nowword.<span class="built_in">clear</span>();                            <span class="comment">//置初值</span></span><br><span class="line">                nowwordlen=<span class="number">0</span>;</span><br><span class="line">                nownum=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;nownum<span class="number">-1</span>)                                   <span class="comment">//最后一行左对齐</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp+=nowword[j];</span><br><span class="line">            temp+=<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        temp+=nowword[j];</span><br><span class="line">        <span class="keyword">int</span> len=maxWidth-temp.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> z=<span class="number">0</span>;z&lt;len;z++)</span><br><span class="line">            temp+=<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-69.x的平方根</title>
    <url>/2019/09/22/leetcode/1-100/69.x-de-ping-fang-gen/</url>
    <content><![CDATA[<p>实现 int sqrt(int x) 函数。</p>
<p>计算并返回 x 的平方根，其中 x 是非负整数。</p>
<p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p>
<span id="more"></span>

<p>示例 1:</p>
<p>输入: 4<br>输出: 2<br>示例 2:</p>
<p>输入: 8<br>输出: 2<br>说明: 8 的平方根是 2.82842…,<br>     由于返回类型是整数，小数部分将被舍去。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/sqrtx">https://leetcode-cn.com/problems/sqrtx</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法1：二分"><a href="#解法1：二分" class="headerlink" title="解法1：二分"></a>解法1：二分</h4><p>1.找到左右边界[0,x];</p>
<p>2.写出中位数逻辑判断,影响right还是left</p>
<p>3.思考选择左中位数，右中位数。</p>
<p>4.判断是否进行后处理</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> left=<span class="number">0</span>,right=x;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> mid=left+(right-left+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(mid*mid&gt;x)</span><br><span class="line">                right=mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                left=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-7. 整数反转</title>
    <url>/2019/08/20/leetcode/1-100/7.zheng-shu-fan-zhuan/</url>
    <content><![CDATA[<h4 id="7-整数反转"><a href="#7-整数反转" class="headerlink" title="7. 整数反转"></a><a href="https://leetcode-cn.com/problems/reverse-integer/">7. 整数反转</a></h4><p>思路：</p>
<p>各位挨个取余，注意边界值，INT_MAX= 2147483647,INT_MIN=-2147483648 </p>
<p>判断 1.如果当前翻转s&gt;INT_MAX/10||s==INT_MAX/10&amp;&amp;当前取余大于7 必然溢出</p>
<p>2.如果当前s&lt;INT_MIN/10||(s==INT_MIN/10&amp;&amp;当前取余&lt;-8) 必然溢出</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pop;</span><br><span class="line">        <span class="keyword">int</span> s=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span>(x!=<span class="number">0</span>)</span><br><span class="line">       &#123;</span><br><span class="line">        pop=x%<span class="number">10</span>;</span><br><span class="line">        x=x/<span class="number">10</span>;</span><br><span class="line">           <span class="keyword">if</span>(s&gt;INT_MAX/<span class="number">10</span>||(s==INT_MAX/<span class="number">10</span>&amp;&amp;pop&gt;<span class="number">7</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">if</span>(s&lt;INT_MIN/<span class="number">10</span>||(s==INT_MIN/<span class="number">10</span>&amp;&amp;pop&lt;<span class="number">-8</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        s=s*<span class="number">10</span>+pop;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-70.爬楼梯</title>
    <url>/2019/09/22/leetcode/1-100/70.pa-lou-ti/</url>
    <content><![CDATA[<p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p>注意：给定 n 是一个正整数。</p>
<span id="more"></span>

<p>示例 1：</p>
<p>输入： 2<br>输出： 2<br>解释： 有两种方法可以爬到楼顶。</p>
<ol>
<li> 1 阶 + 1 阶</li>
<li>2 阶<br>示例 2：</li>
</ol>
<p>输入： 3<br>输出： 3<br>解释： 有三种方法可以爬到楼顶。</p>
<ol>
<li> 1 阶 + 1 阶 + 1 阶</li>
<li> 1 阶 + 2 阶</li>
<li> 2 阶 + 1 阶</li>
</ol>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/climbing-stairs">https://leetcode-cn.com/problems/climbing-stairs</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法1：动态规划"><a href="#解法1：动态规划" class="headerlink" title="解法1：动态规划"></a>解法1：动态规划</h4><p>思路：</p>
<p>1.dp[i]表示从0到i层台阶可走的方法</p>
<p>2.dp[0]=1;dp[1]=1;</p>
<p>3.状态转移方程dp[i]=dp[i-1]+dp[i-2];</p>
<p>4.返回dp[n];</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">3</span>;i&lt;n+<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i]=dp[i<span class="number">-1</span>]+dp[i<span class="number">-2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-71.简化路径</title>
    <url>/2019/09/22/leetcode/1-100/71.jian-hua-lu-jing/</url>
    <content><![CDATA[<p>以 Unix 风格给出一个文件的绝对路径，你需要简化它。或者换句话说，将其转换为规范路径。</p>
<p>在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。更多信息请参阅：Linux / Unix中的绝对路径 vs 相对路径</p>
<p>请注意，返回的规范路径必须始终以斜杠 / 开头，并且两个目录名之间必须只有一个斜杠 /。最后一个目录名（如果存在）不能以 / 结尾。此外，规范路径必须是表示绝对路径的最短字符串。</p>
<p> <span id="more"></span></p>
<p>示例 1：</p>
<p>输入：”/home/“<br>输出：”/home”<br>解释：注意，最后一个目录名后面没有斜杠。<br>示例 2：</p>
<p>输入：”/../“<br>输出：”/“<br>解释：从根目录向上一级是不可行的，因为根是你可以到达的最高级。<br>示例 3：</p>
<p>输入：”/home//foo/“<br>输出：”/home/foo”<br>解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。<br>示例 4：</p>
<p>输入：”/a/./b/../../c/“<br>输出：”/c”<br>示例 5：</p>
<p>输入：”/a/../../b/../c//.//“<br>输出：”/c”<br>示例 6：</p>
<p>输入：”/a//b////c/d//././/..”<br>输出：”/a/b/c”</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/simplify-path">https://leetcode-cn.com/problems/simplify-path</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法1：栈"><a href="#解法1：栈" class="headerlink" title="解法1：栈"></a>解法1：栈</h4><p>将各种情况考虑到，进行模拟。用res string数组存下路径名称，最后整合到strng r字符串</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">simplifyPath</span><span class="params">(string path)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        string r;</span><br><span class="line">        string temp=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> i,n=path.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(path[i]!=<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                temp+=path[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(path[i]==<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(temp==<span class="string">&quot;.&quot;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp=<span class="string">&quot;&quot;</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                 <span class="keyword">if</span>(temp==<span class="string">&quot;..&quot;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(!res.<span class="built_in">empty</span>())</span><br><span class="line">                        res.<span class="built_in">pop_back</span>();</span><br><span class="line">                    temp=<span class="string">&quot;&quot;</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(temp==<span class="string">&quot;&quot;</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">                    temp=<span class="string">&quot;&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp!=<span class="string">&quot;&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(temp==<span class="string">&quot;..&quot;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!res.<span class="built_in">empty</span>())</span><br><span class="line">                    res.<span class="built_in">pop_back</span>();</span><br><span class="line">              </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(temp!=<span class="string">&quot;.&quot;</span>)</span><br><span class="line">                res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;res.<span class="built_in">size</span>();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            r=r+<span class="string">&#x27;/&#x27;</span>+res[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(r==<span class="string">&quot;&quot;</span>)</span><br><span class="line">            r+=<span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-72.编辑距离</title>
    <url>/2019/09/25/leetcode/1-100/72.bian-ji-ju-chi/</url>
    <content><![CDATA[<p>给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<p>插入一个字符<br>删除一个字符<br>替换一个字符</p>
<span id="more"></span>

<p>示例 1:</p>
<p>输入: word1 = “horse”, word2 = “ros”<br>输出: 3<br>解释:<br>horse -&gt; rorse (将 ‘h’ 替换为 ‘r’)<br>rorse -&gt; rose (删除 ‘r’)<br>rose -&gt; ros (删除 ‘e’)<br>示例 2:</p>
<p>输入: word1 = “intention”, word2 = “execution”<br>输出: 5<br>解释:<br>intention -&gt; inention (删除 ‘t’)<br>inention -&gt; enention (将 ‘i’ 替换为 ‘e’)<br>enention -&gt; exention (将 ‘n’ 替换为 ‘x’)<br>exention -&gt; exection (将 ‘n’ 替换为 ‘c’)<br>exection -&gt; execution (插入 ‘u’)</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/edit-distance">https://leetcode-cn.com/problems/edit-distance</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法1：动态规划"><a href="#解法1：动态规划" class="headerlink" title="解法1：动态规划"></a>解法1：动态规划</h4><p>1.dp[i][j]表示word1的前i个字符转化成word2的前j个字符所需要使用的最少操作数</p>
<p>2.状态转移方程</p>
<p>(1).word1[i-1]==word2[j-1],dp[i][j]=dp[i-1][j-1];</p>
<p>(2).word1[i-1]!=word2[j-1],dp[i][j]=min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1;</p>
<p>​    其中dp[i-1][j-1]表示从dp[i-1][j-1]到dp[i][j]对word1进行替换操作,dp[i][j-1]表示从dp[i][j-1]到dp[i][j]对word1进行添加操作，dp[i-1][j]表示从dp[i-1][j]到dp[i][j]对word1进行删除操作。</p>
<p>3.针对第一行第一列我们引入’’。</p>
<p>4.返回dp[n][m];</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=word1.<span class="built_in">size</span>(),m=word2.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(n+<span class="number">1</span>,vector&lt;<span class="keyword">int</span>&gt;(m+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">            dp[<span class="number">0</span>][i]=i;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            &#123;</span><br><span class="line">               <span class="keyword">if</span>(word1[i<span class="number">-1</span>]==word2[j<span class="number">-1</span>])</span><br><span class="line">                   dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j]=<span class="built_in">min</span>(<span class="built_in">min</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]),dp[i<span class="number">-1</span>][j<span class="number">-1</span>])+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-73.矩阵置零</title>
    <url>/2019/09/25/leetcode/1-100/73.ju-zhen-zhi-ling/</url>
    <content><![CDATA[<p>给定一个 m x n 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用原地算法。</p>
<span id="more"></span>

<p>示例 1:</p>
<p>输入:<br>[<br>  [1,1,1],<br>  [1,0,1],<br>  [1,1,1]<br>]<br>输出:<br>[<br>  [1,0,1],<br>  [0,0,0],<br>  [1,0,1]<br>]<br>示例 2:</p>
<p>输入:<br>[<br>  [0,1,2,0],<br>  [3,4,5,2],<br>  [1,3,1,5]<br>]<br>输出:<br>[<br>  [0,0,0,0],<br>  [0,4,5,0],<br>  [0,3,1,0]<br>]<br>进阶:</p>
<p>一个直接的解决方案是使用  O(mn) 的额外空间，但这并不是一个好的解决方案。<br>一个简单的改进方案是使用 O(m + n) 的额外空间，但这仍然不是最好的解决方案。<br>你能想出一个常数空间的解决方案吗？</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/set-matrix-zeroes">https://leetcode-cn.com/problems/set-matrix-zeroes</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法1：O（1）空间复杂度"><a href="#解法1：O（1）空间复杂度" class="headerlink" title="解法1：O（1）空间复杂度"></a>解法1：O（1）空间复杂度</h4><p>关键：用matrix第一行第一列记录该行该列是否有0，作为标记位</p>
<p>但对于第一行第一列要设置一个标志位，为了防止自己这一行（一列）出现0的情况</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">int</span> m=matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">bool</span> row_zero=<span class="literal">false</span>,col_zero=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][<span class="number">0</span>]==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                row_zero=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[<span class="number">0</span>][i]==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                col_zero=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;m;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j]==<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    matrix[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">                    matrix[<span class="number">0</span>][j]=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;m;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][<span class="number">0</span>]==<span class="number">0</span>||matrix[<span class="number">0</span>][j]==<span class="number">0</span>)</span><br><span class="line">                    matrix[i][j]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(row_zero)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">                matrix[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(col_zero)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                matrix[<span class="number">0</span>][i]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-74.搜索二维矩阵</title>
    <url>/2019/09/26/leetcode/1-100/74.sou-suo-er-wei-ju-zhen/</url>
    <content><![CDATA[<p>编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：</p>
<p>每行中的整数从左到右按升序排列。<br>每行的第一个整数大于前一行的最后一个整数。</p>
<span id="more"></span>

<p>示例 1:</p>
<p>输入:<br>matrix = [<br>  [1,   3,  5,  7],<br>  [10, 11, 16, 20],<br>  [23, 30, 34, 50]<br>]<br>target = 3<br>输出: true<br>示例 2:</p>
<p>输入:<br>matrix = [<br>  [1,   3,  5,  7],<br>  [10, 11, 16, 20],<br>  [23, 30, 34, 50]<br>]<br>target = 13<br>输出: false</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/search-a-2d-matrix">https://leetcode-cn.com/problems/search-a-2d-matrix</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法1：二分"><a href="#解法1：二分" class="headerlink" title="解法1：二分"></a>解法1：二分</h4><p>思路：</p>
<p>通过分析我们能发现如果将这个二维数组展开，将会得到一个有序的一维数组，所以我们可以直接采用二分查找。</p>
<p>关键是如何将一维下标映射到对应的二维下标，分析得：我们用i=mid/m,j=mid%m(m为列数)即可得到二维下标</p>
<p>然后开始写二分查找</p>
<p>1.范围[0,n*m]</p>
<p>2.判断中位数逻辑，是让left=mid+1，还是right=mid-1</p>
<p>3.根据left，right缩进方式选择左中位数还是右中位数</p>
<p>4.后处理，判断能否找到该值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> m=matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(m==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=n*m;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(matrix[mid/m][mid%m]&lt;target)</span><br><span class="line">            &#123;</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> right=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left&lt;n*m&amp;&amp;matrix[left/m][left%m]==target;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-75.颜色分类</title>
    <url>/2019/09/26/leetcode/1-100/75.yan-se-fen-lei/</url>
    <content><![CDATA[<p>排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>
<p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p>
<span id="more"></span>

<p>注意:<br>不能使用代码库中的排序函数来解决这道题。</p>
<p>示例:</p>
<p>输入: [2,0,2,1,1,0]<br>输出: [0,0,1,1,2,2]<br>进阶：</p>
<p>一个直观的解决方案是使用计数排序的两趟扫描算法。<br>首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。<br>你能想出一个仅使用常数空间的一趟扫描算法吗？</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/sort-colors">https://leetcode-cn.com/problems/sort-colors</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法1：双指针"><a href="#解法1：双指针" class="headerlink" title="解法1：双指针"></a>解法1：双指针</h4><p>思路：</p>
<p>构建两个指针p0,p2，p0表示下一个0应该放在的位置,p2表示下一个2应该放在的位置</p>
<p>1.curr指针遍历数组，当curr指向0时与p0指向位置元素进行交换,然后curr与p0都+1,</p>
<p>​    注：curr指向0与p0交换后只有两种情况换到一个0或者一个1这种情况都应该让curr++</p>
<p>2.or当curr指向2与p2指向位置元进行交换，然后p2–然后继续判断该位置元素</p>
<p>3.curr指向1，则让curr++</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> p0=<span class="number">0</span>,p2=n<span class="number">-1</span>,curr=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(curr&lt;=p2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[curr]==<span class="number">0</span>)</span><br><span class="line">                <span class="built_in">swap</span>(nums[curr++],nums[p0++]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[curr]==<span class="number">2</span>)</span><br><span class="line">                <span class="built_in">swap</span>(nums[curr],nums[p2--]);</span><br><span class="line">            <span class="keyword">else</span> curr++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-76.最小覆盖子串</title>
    <url>/2019/09/26/leetcode/1-100/76.zui-xiao-fu-gai-zi-chuan/</url>
    <content><![CDATA[<p>给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字母的最小子串。</p>
<span id="more"></span>

<p>示例：</p>
<p>输入: S = “ADOBECODEBANC”, T = “ABC”<br>输出: “BANC”<br>说明：</p>
<p>如果 S 中不存这样的子串，则返回空字符串 “”。<br>如果 S 中存在这样的子串，我们保证它是唯一的答案。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/minimum-window-substring">https://leetcode-cn.com/problems/minimum-window-substring</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法1：滑动窗口"><a href="#解法1：滑动窗口" class="headerlink" title="解法1：滑动窗口"></a>解法1：滑动窗口</h4><p>思路：</p>
<p>1.两个map，need存需要的字符个数量，window存当前窗口的各字符数量，</p>
<p>2.每次滑动右边界,判断该窗口是否符合子串要求，若符合要求，1是判断该字符是否在need中，若在是否数量==了need中的数量，若==将目标值match+1，当match==need.size表示该窗口符合子串要求</p>
<p>3.开始移动左边界，直到不符合要求，中间记录最小长度子串的起始位置及长度</p>
<p>4.最后返回空字符串或者找到的最小子串</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>,minlen=INT_MAX,left=<span class="number">0</span>,right=<span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; window;</span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; need;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:t) need[c]++;</span><br><span class="line">        <span class="keyword">int</span> match=<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(right&lt;s.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> c1=s[right];</span><br><span class="line">            <span class="keyword">if</span>(need.<span class="built_in">count</span>(c1))</span><br><span class="line">            &#123;</span><br><span class="line">                window[c1]++;</span><br><span class="line">                <span class="keyword">if</span>(window[c1]==need[c1])</span><br><span class="line">                &#123;</span><br><span class="line">                    match++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">            <span class="keyword">while</span>(match==need.<span class="built_in">size</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(right-left&lt;minlen)</span><br><span class="line">                &#123;</span><br><span class="line">                    start=left;</span><br><span class="line">                    minlen=right-left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">char</span> c2=s[left];</span><br><span class="line">                <span class="keyword">if</span>(need.<span class="built_in">count</span>(c2))</span><br><span class="line">                &#123;</span><br><span class="line">                    window[c2]--;</span><br><span class="line">                    <span class="keyword">if</span>(window[c2]&lt;need[c2])</span><br><span class="line">                        match--;</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minlen == INT_MAX ? <span class="string">&quot;&quot;</span> : s.<span class="built_in">substr</span>(start, minlen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-77.组合</title>
    <url>/2019/09/27/leetcode/1-100/77.zu-he/</url>
    <content><![CDATA[<p>给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。</p>
<span id="more"></span>

<p>示例:</p>
<p>输入: n = 4, k = 2<br>输出:<br>[<br>  [2,4],<br>  [3,4],<br>  [2,3],<br>  [1,2],<br>  [1,3],<br>  [1,4],<br>]</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/combinations">https://leetcode-cn.com/problems/combinations</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法1：回溯"><a href="#解法1：回溯" class="headerlink" title="解法1：回溯"></a>解法1：回溯</h4><p>对1,n个数进行回溯，当当前count记录==k将这一组合添加到res</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">twonumber</span>(count,n,k,j);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">twonumber</span><span class="params">(<span class="keyword">int</span> count,<span class="keyword">int</span> n,<span class="keyword">int</span> k,<span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count==k)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=j+<span class="number">1</span>;i&lt;=n-(k-temp.<span class="built_in">size</span>())+<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            temp.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="built_in">twonumber</span>(count+<span class="number">1</span>,n,k,i);</span><br><span class="line">            temp.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-78.子集</title>
    <url>/2019/09/28/leetcode/1-100/78.zi-ji/</url>
    <content><![CDATA[<p>给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p>
<span id="more"></span>

<p>说明：解集不能包含重复的子集。</p>
<p>示例:</p>
<p>输入: nums = [1,2,3]<br>输出:<br>[<br>  [3],<br>  [1],<br>  [2],<br>  [1,2,3],<br>  [1,3],<br>  [2,3],<br>  [1,2],<br>  []<br>]</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/subsets">https://leetcode-cn.com/problems/subsets</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法1：回溯"><a href="#解法1：回溯" class="headerlink" title="解法1：回溯"></a>解法1：回溯</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">ziji</span>(nums,n,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ziji</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;nums,<span class="keyword">int</span> n,<span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=j;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            temp.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">ziji</span>(nums,n,i+<span class="number">1</span>);</span><br><span class="line">            temp.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="解法2：位运算"><a href="#解法2：位运算" class="headerlink" title="解法2：位运算"></a>解法2：位运算</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n=<span class="number">1</span>&lt;&lt;nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;nums.<span class="built_in">size</span>();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>((i&gt;&gt;j)&amp;<span class="number">1</span>)</span><br><span class="line">                    temp.<span class="built_in">push_back</span>(nums[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>回溯</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-79.单词搜索</title>
    <url>/2019/09/28/leetcode/1-100/79.dan-ci-sou-suo/</url>
    <content><![CDATA[<p>给定一个二维网格和一个单词，找出该单词是否存在于网格中。</p>
<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
<span id="more"></span>

<p>示例:</p>
<p>board =<br>[<br>  [‘A’,’B’,’C’,’E’],<br>  [‘S’,’F’,’C’,’S’],<br>  [‘A’,’D’,’E’,’E’]<br>]</p>
<p>给定 word = “ABCCED”, 返回 true.<br>给定 word = “SEE”, 返回 true.<br>给定 word = “ABCB”, 返回 false.</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/word-search">https://leetcode-cn.com/problems/word-search</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法1：DFS"><a href="#解法1：DFS" class="headerlink" title="解法1：DFS"></a>解法1：DFS</h4><p>direction保存点行进的方向</p>
<p>创建used记录该点是否访问过,然后进行dfs遍历，每次判断该点board==word对应字符</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt; board;</span><br><span class="line">    string word;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; used;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">int</span> wordlen;</span><br><span class="line">    <span class="keyword">int</span> direction[<span class="number">4</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;</span><br><span class="line">        n=board.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        m=board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">used</span>(n,vector&lt;<span class="keyword">bool</span>&gt;(m,<span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">this</span>-&gt;board=board;</span><br><span class="line">        <span class="keyword">this</span>-&gt;word=word;</span><br><span class="line">        <span class="keyword">this</span>-&gt;used=used;</span><br><span class="line">        <span class="keyword">this</span>-&gt;wordlen=word.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">dfs</span>(i,j,<span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(len&gt;=wordlen<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> board[i][j]==word[len];</span><br><span class="line">        <span class="keyword">if</span>(board[i][j]==word[len])</span><br><span class="line">        &#123;</span><br><span class="line">            used[i][j]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> newx=i+direction[k][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> newy=j+direction[k][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(newx&gt;=<span class="number">0</span>&amp;&amp;newx&lt;n&amp;&amp;newy&gt;=<span class="number">0</span>&amp;&amp;newy&lt;m&amp;&amp;!used[newx][newy])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">dfs</span>(newx,newy,len+<span class="number">1</span>))</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;   </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            used[i][j]=<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>DFS</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-8.字符串转换整数（atoi）</title>
    <url>/2019/08/21/leetcode/1-100/8.zi-fu-chuan-zhuan-huan-zheng-shu/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p><img src="/../../../images/lc8.png" alt="1566376157844"></p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        <span class="keyword">int</span> key=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> w=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;str[i]==<span class="string">&#x27; &#x27;</span>&amp;&amp;i&lt;str.<span class="built_in">length</span>();i++)        <span class="comment">//排除无用开头空格字符</span></span><br><span class="line">        &#123;;&#125;    </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(str[i]!=<span class="string">&#x27;+&#x27;</span>&amp;&amp;str[i]!=<span class="string">&#x27;-&#x27;</span>&amp;&amp;(!(<span class="string">&#x27;0&#x27;</span>&lt;=str[i]&amp;&amp;str[i]&lt;=<span class="string">&#x27;9&#x27;</span>))||i==str.<span class="built_in">length</span>())    <span class="comment">//如果开头不为+，-，或数字则不能有效转换</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(str[i]==<span class="string">&#x27;-&#x27;</span>)             <span class="comment">//开头为-时，标记</span></span><br><span class="line">        &#123;</span><br><span class="line">            key=<span class="number">1</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(str[i]==<span class="string">&#x27;+&#x27;</span>)        <span class="comment">//开头为+时，跳过这一位，判断后面的位</span></span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;str.<span class="built_in">length</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&#x27;0&#x27;</span>&lt;=str[i]&amp;&amp;str[i]&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                t=str[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>((res&gt;INT_MAX/<span class="number">10</span>||(res==INT_MAX/<span class="number">10</span>&amp;&amp;t&gt;<span class="number">7</span>))&amp;&amp;key==<span class="number">0</span>) <span class="keyword">return</span> INT_MAX;    <span class="comment">//正数溢出</span></span><br><span class="line">                <span class="keyword">if</span>((res&gt;INT_MAX/<span class="number">10</span>||(res==INT_MAX/<span class="number">10</span>&amp;&amp;t&gt;<span class="number">8</span>))&amp;&amp;key==<span class="number">1</span>) <span class="keyword">return</span> INT_MIN;    <span class="comment">//负数溢出</span></span><br><span class="line">                <span class="keyword">if</span>(res==INT_MAX/<span class="number">10</span>&amp;&amp;key==<span class="number">1</span>)             <span class="comment">//负数较大时</span></span><br><span class="line">                &#123;</span><br><span class="line">                    res=-res*<span class="number">10</span>-t;</span><br><span class="line">                    w=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    res=res*<span class="number">10</span>+t;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(key==<span class="number">1</span>&amp;&amp;w==<span class="number">0</span>)</span><br><span class="line">            res=-res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-80.删除排序数组中重复项II</title>
    <url>/2019/09/28/leetcode/1-100/80.shan-chu-pai-xu-shu-zu-zhong-chong-fu-xiang-ii/</url>
    <content><![CDATA[<p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p>
<span id="more"></span>

<p>示例 1:</p>
<p>给定 nums = [1,1,1,2,2,3],</p>
<p>函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。</p>
<p>你不需要考虑数组中超出新长度后面的元素。<br>示例 2:</p>
<p>给定 nums = [0,0,1,1,1,1,2,3,3],</p>
<p>函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。</p>
<p>你不需要考虑数组中超出新长度后面的元素。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法1：双指针"><a href="#解法1：双指针" class="headerlink" title="解法1：双指针"></a>解法1：双指针</h4><p>一个指针记录当前应返还的数组长度len，一个遍历当前数组，若当前指针所指数值跟应len-2所指数值不同，则将该为替换到len位置，且len+1</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(len&lt;<span class="number">2</span>||nums[i]!=nums[len<span class="number">-2</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                nums[len]=nums[i];</span><br><span class="line">                len++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-81.搜索旋转排序数组 II</title>
    <url>/2019/09/28/leetcode/1-100/81.sou-suo-xuan-zhuan-pai-xu-shu-zu-ii/</url>
    <content><![CDATA[<p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。</p>
<p>编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。</p>
<span id="more"></span>

<p>示例 1:</p>
<p>输入: nums = [2,5,6,0,0,1,2], target = 0<br>输出: true<br>示例 2:</p>
<p>输入: nums = [2,5,6,0,0,1,2], target = 3<br>输出: false<br>进阶:</p>
<p>这是 搜索旋转排序数组 的延伸题目，本题中的 nums  可能包含重复元素。<br>这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii">https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法1：二分"><a href="#解法1：二分" class="headerlink" title="解法1：二分"></a>解法1：二分</h4><p>思路：跟33题一样的思路采用二分，不过由于多了重复元素，所以我们添加一条判断</p>
<p>当nums[mid]==nums[right]时，判断nums[mid]是否为目标值，若不是让右边界收缩（因为是取的是右中位数）。</p>
<p>时间复杂度：最优O（logn），最坏O（n）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(right==<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&lt;nums[right])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[mid]&lt;=target&amp;&amp;target&lt;=nums[right])</span><br><span class="line">                &#123;</span><br><span class="line">                    left=mid;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> right=mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&gt;nums[right])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[left]&lt;=target&amp;&amp;target&lt;=nums[mid<span class="number">-1</span>])</span><br><span class="line">                    right=mid<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">else</span> left=mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[right]==target)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                right-=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[left]==target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-82.删除排序链表中的重复元素 II</title>
    <url>/2019/09/28/leetcode/1-100/82.shan-chu-pai-xu-lian-biao-zhong-de-chong-fu-yuan-su-ii/</url>
    <content><![CDATA[<p>给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。</p>
<span id="more"></span>

<p>示例 1:</p>
<p>输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5<br>输出: 1-&gt;2-&gt;5<br>示例 2:</p>
<p>输入: 1-&gt;1-&gt;1-&gt;2-&gt;3<br>输出: 2-&gt;3</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法1：快慢指针"><a href="#解法1：快慢指针" class="headerlink" title="解法1：快慢指针"></a>解法1：快慢指针</h4><p>在原链表上修改：</p>
<p>一个指针pfront记录当前没有出现重复数字指针位置，一个指针p遍历链表，将不是重复数字的节点记录让pfront-&gt;next=p，然后pfront=pfront-&gt;next,继续遍历p到链尾。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *p=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        ListNode *pfront=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        p=head;</span><br><span class="line">        pfront-&gt;next=head;</span><br><span class="line">        <span class="keyword">int</span> v;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;val==p-&gt;next-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                v=p-&gt;val;</span><br><span class="line">                p=p-&gt;next-&gt;next;</span><br><span class="line">                <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(p-&gt;val==v)</span><br><span class="line">                        p=p-&gt;next;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(pfront-&gt;next==head)</span><br><span class="line">                &#123;  </span><br><span class="line">                    head=p;</span><br><span class="line">                    pfront-&gt;next=head;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    pfront-&gt;next=p;</span><br><span class="line">                <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                pfront=pfront-&gt;next;</span><br><span class="line">                </span><br><span class="line">                p=p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-83.删除排序链表中的重复元素</title>
    <url>/2019/09/28/leetcode/1-100/83-shan-chu-pai-xu-lian-biao-zhong-de-chong-fu-yuan-su/</url>
    <content><![CDATA[<p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p>
<span id="more"></span>

<p>示例 1:</p>
<p>输入: 1-&gt;1-&gt;2<br>输出: 1-&gt;2<br>示例 2:</p>
<p>输入: 1-&gt;1-&gt;2-&gt;3-&gt;3<br>输出: 1-&gt;2-&gt;3</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h4><p>若当前指针元素与下一位元素相同，则这一位直接指向下一位的下一位（及跳过下一位）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *pfirst=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        ListNode *p=head;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;p-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;val==p-&gt;next-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                p-&gt;next=p-&gt;next-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-84.柱状图中最大的矩形</title>
    <url>/2019/09/28/leetcode/1-100/84.zhu-zhuang-tu-zhong-zui-da-ju-xing/</url>
    <content><![CDATA[<p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p>
<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram.png" alt="1"></p>
<p>以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram_area.png"></p>
<p>图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。</p>
<p> <span id="more"></span></p>
<p>示例:</p>
<p>输入: [2,1,5,6,2,3]<br>输出: 10</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram">https://leetcode-cn.com/problems/largest-rectangle-in-histogram</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法1：栈"><a href="#解法1：栈" class="headerlink" title="解法1：栈"></a>解法1：栈</h4><p>维护一个单调递增栈，当i小于栈顶元素时出栈，记录对应高度</p>
<p>然后进行比较新栈顶位置与i组成的矩形面积和最大面积，</p>
<p>继续出栈直到i大于栈顶元素。</p>
<p>遍历数组结束后，处理栈中元素直到栈中只有标志位-1</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        st.<span class="built_in">push</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> n=heights.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(st.<span class="built_in">top</span>()!=<span class="number">-1</span>&amp;&amp;heights[st.<span class="built_in">top</span>()]&gt;heights[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> c=heights[st.<span class="built_in">top</span>()];</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                res=<span class="built_in">max</span>(res,(i-st.<span class="built_in">top</span>()<span class="number">-1</span>)*c);</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(st.<span class="built_in">top</span>()!=<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> c=heights[st.<span class="built_in">top</span>()];</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            res=<span class="built_in">max</span>(res,(i-st.<span class="built_in">top</span>()<span class="number">-1</span>)*c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-85.最大矩形</title>
    <url>/2019/09/28/leetcode/1-100/85.zui-da-ju-xing/</url>
    <content><![CDATA[<p>给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。</p>
<span id="more"></span>

<p>示例:</p>
<p>输入:<br>[<br>  [“1”,”0”,”1”,”0”,”0”],<br>  [“1”,”0”,”1”,”1”,”1”],<br>  [“1”,”1”,”1”,”1”,”1”],<br>  [“1”,”0”,”0”,”1”,”0”]<br>]<br>输出: 6</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/maximal-rectangle">https://leetcode-cn.com/problems/maximal-rectangle</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法1：栈"><a href="#解法1：栈" class="headerlink" title="解法1：栈"></a>解法1：栈</h4><p>对每一行统计一次各个列的高度，dp[j]=(matrix[i][j]==’1’)?dp[j+1]:0;</p>
<p>然后对每一行应用84题解法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m=matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(m,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[j]=(matrix[i][j]==<span class="string">&#x27;1&#x27;</span>)?dp[j]+<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res=<span class="built_in">max</span>(res,<span class="built_in">largestRectangleArea</span>(dp));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        st.<span class="built_in">push</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> n=heights.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(st.<span class="built_in">top</span>()!=<span class="number">-1</span>&amp;&amp;heights[st.<span class="built_in">top</span>()]&gt;heights[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> c=heights[st.<span class="built_in">top</span>()];</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                res=<span class="built_in">max</span>(res,(i-st.<span class="built_in">top</span>()<span class="number">-1</span>)*c);</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(st.<span class="built_in">top</span>()!=<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> c=heights[st.<span class="built_in">top</span>()];</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            res=<span class="built_in">max</span>(res,(i-st.<span class="built_in">top</span>()<span class="number">-1</span>)*c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="解法2：动态规划"><a href="#解法2：动态规划" class="headerlink" title="解法2：动态规划"></a>解法2：动态规划</h4><p>用height记录当前行为底,第j列高度是多少. </p>
<p>用left记录第i行为底，第j列构建最大矩形的左边界（从j列往前左边第一个小于height[j]的位置）</p>
<p>用right记录第j行为底，第j列构建的最大矩形的右边界(从j列往后最右边第一个小于height[i]的位置)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m=matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">height</span> <span class="params">(m,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">left</span><span class="params">(m,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">right</span><span class="params">(m,m)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> cur_left=<span class="number">0</span>,cur_right=m;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cur_left=<span class="number">0</span>;</span><br><span class="line">            cur_right=m;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">                height[j]=(matrix[i][j]==<span class="string">&#x27;1&#x27;</span>)?(height[j]+<span class="number">1</span>):<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j]==<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                    left[j]=<span class="built_in">max</span>(left[j],cur_left);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    left[j]=<span class="number">0</span>;</span><br><span class="line">                    cur_left=j+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(j=m<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j]==<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                    right[j]=<span class="built_in">min</span>(right[j],cur_right);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    right[j]=m;</span><br><span class="line">                    cur_right=j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">                res=<span class="built_in">max</span>(res,height[j]*(right[j]-left[j]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>动态规划</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-86.分隔链表</title>
    <url>/2019/10/01/leetcode/1-100/86.fen-ge-lian-biao/</url>
    <content><![CDATA[<p>给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。</p>
<p>你应当保留两个分区中每个节点的初始相对位置。</p>
<span id="more"></span>

<p>示例:</p>
<p>输入: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3<br>输出: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/partition-list">https://leetcode-cn.com/problems/partition-list</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法1：双指针"><a href="#解法1：双指针" class="headerlink" title="解法1：双指针"></a>解法1：双指针</h4><p>采用双指针。分析题目就是找到第一个大于x的位置，然后在这个位置前面插入它后面所有小于x的结点。所以我们可以用双指针来解决。</p>
<p>1.p指针用来遍历链表。</p>
<p>2.pfirst指针是p指针的前指针，用来进行删除某个结点操作</p>
<p>3.pleft，pright是要插入位置的前指针和后指针</p>
<p>4.pnew是新链表的头指针，pm是新链表的尾指针</p>
<p>5.find用来确定链表中有没有大于x的结点，如果没有直接返回原链表</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">partition</span><span class="params">(ListNode* head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        ListNode *pnew=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        ListNode *pm=pnew;</span><br><span class="line">        ListNode *p=head;</span><br><span class="line">        ListNode *pfirst=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        pfirst-&gt;next=head;</span><br><span class="line">        ListNode *pleft=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        ListNode *pright=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> find=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;val&gt;=x)</span><br><span class="line">            &#123;</span><br><span class="line">                find=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pfirst=p;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(find==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">if</span>(p==head)</span><br><span class="line">        &#123;</span><br><span class="line">            pright=p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pleft=pfirst;</span><br><span class="line">            pright=p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;val&lt;x)</span><br><span class="line">            &#123;</span><br><span class="line">                ListNode *p2=<span class="keyword">new</span> <span class="built_in">ListNode</span>(p-&gt;val);</span><br><span class="line">                pm-&gt;next=p2;</span><br><span class="line">                pm=pm-&gt;next;</span><br><span class="line">                pfirst-&gt;next=p-&gt;next;</span><br><span class="line">                p=p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                pfirst=p;</span><br><span class="line">                p=p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pright==head)</span><br><span class="line">        &#123;</span><br><span class="line">            pm-&gt;next=pright;</span><br><span class="line">            pnew=pnew-&gt;next;</span><br><span class="line">            <span class="keyword">return</span> pnew;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pm-&gt;next=pright;</span><br><span class="line">            pnew=pnew-&gt;next;</span><br><span class="line">            pleft-&gt;next=pnew;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-87.扰乱字符串</title>
    <url>/2019/10/01/leetcode/1-100/87.rao-luan-zi-fu-chuan/</url>
    <content><![CDATA[<p>题目链接:<a href="https://leetcode-cn.com/problems/scramble-string/">https://leetcode-cn.com/problems/scramble-string/</a> </p>
<h4 id="解法1：递归"><a href="#解法1：递归" class="headerlink" title="解法1：递归"></a>解法1：递归</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isScramble</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1.<span class="built_in">length</span>()!=s2.<span class="built_in">length</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s1==s2)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> f[<span class="number">26</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> i,a,b;</span><br><span class="line">         <span class="comment">//判断两个字符串每个字母出现的次数是否一致</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;s1.<span class="built_in">length</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            a=s1[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            b=s2[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            f[a]++;</span><br><span class="line">            f[b]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果两个字符串的字母出现不一致直接返回 false</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(f[i]!=<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历每个切割位置</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;s1.<span class="built_in">length</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//对应情况 1 ，判断 S1 的子树能否变为 S2 相应部分</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">isScramble</span>(s1.<span class="built_in">substr</span>(<span class="number">0</span>,i),s2.<span class="built_in">substr</span>(<span class="number">0</span>,i))&amp;&amp;<span class="built_in">isScramble</span>(s1.<span class="built_in">substr</span>(i,s1.<span class="built_in">length</span>()),s2.<span class="built_in">substr</span>(i,s2.<span class="built_in">length</span>())))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//对应情况 2 ，S1 两个子树先进行了交换，然后判断 S1 的子树能否变为 S2 相应部分</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isScramble</span>(s1.<span class="built_in">substr</span>(<span class="number">0</span>,i),s2.<span class="built_in">substr</span>(s2.<span class="built_in">length</span>()-i,i))&amp;&amp;<span class="built_in">isScramble</span>(s1.<span class="built_in">substr</span>(i,s1.<span class="built_in">length</span>()),s2.<span class="built_in">substr</span>(<span class="number">0</span>,s2.<span class="built_in">length</span>()-i)))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="解法2：记录化递归"><a href="#解法2：记录化递归" class="headerlink" title="解法2：记录化递归"></a>解法2：记录化递归</h4><p>理论上记录下递归应该比没有记录要快但在leetcode上反而不如前面快，可能是构建字符串会浪费一定的时间</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    map&lt;string,<span class="keyword">int</span>&gt; m;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isScramble</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">        map&lt;string,<span class="keyword">int</span>&gt;::iterator iter;</span><br><span class="line">        iter=m.<span class="built_in">find</span>(s1+<span class="string">&#x27;#&#x27;</span>+s2);</span><br><span class="line">        <span class="keyword">if</span>(iter!=m.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(iter-&gt;second==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(iter-&gt;second==<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s1.<span class="built_in">length</span>()!=s2.<span class="built_in">length</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            m.<span class="built_in">insert</span>(pair&lt;string,<span class="keyword">int</span>&gt;(s1+<span class="string">&#x27;#&#x27;</span>+s2,<span class="number">0</span>)); </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s1==s2)</span><br><span class="line">        &#123;</span><br><span class="line">            m.<span class="built_in">insert</span>(pair&lt;string,<span class="keyword">int</span>&gt;(s1+<span class="string">&#x27;#&#x27;</span>+s2,<span class="number">1</span>)); </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> f[<span class="number">26</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> i,a,b;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;s1.<span class="built_in">length</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            a=s1[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            b=s2[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            f[a]++;</span><br><span class="line">            f[b]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(f[i]!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                m.<span class="built_in">insert</span>(pair&lt;string,<span class="keyword">int</span>&gt;(s1+<span class="string">&#x27;#&#x27;</span>+s2,<span class="number">0</span>));    </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;s1.<span class="built_in">length</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">isScramble</span>(s1.<span class="built_in">substr</span>(<span class="number">0</span>,i),s2.<span class="built_in">substr</span>(<span class="number">0</span>,i))&amp;&amp;<span class="built_in">isScramble</span>(s1.<span class="built_in">substr</span>(i,s1.<span class="built_in">length</span>()),s2.<span class="built_in">substr</span>(i,s2.<span class="built_in">length</span>())))</span><br><span class="line">            &#123;</span><br><span class="line">                m.<span class="built_in">insert</span>(pair&lt;string,<span class="keyword">int</span>&gt;(s1+<span class="string">&#x27;#&#x27;</span>+s2,<span class="number">1</span>)); </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isScramble</span>(s1.<span class="built_in">substr</span>(<span class="number">0</span>,i),s2.<span class="built_in">substr</span>(s2.<span class="built_in">length</span>()-i,i))&amp;&amp;<span class="built_in">isScramble</span>(s1.<span class="built_in">substr</span>(i,s1.<span class="built_in">length</span>()),s2.<span class="built_in">substr</span>(<span class="number">0</span>,s2.<span class="built_in">length</span>()-i)))</span><br><span class="line">            &#123;</span><br><span class="line">                 m.<span class="built_in">insert</span>(pair&lt;string,<span class="keyword">int</span>&gt;(s1+<span class="string">&#x27;#&#x27;</span>+s2,<span class="number">1</span>)); </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        m.<span class="built_in">insert</span>(pair&lt;string,<span class="keyword">int</span>&gt;(s1+<span class="string">&#x27;#&#x27;</span>+s2,<span class="number">0</span>)); </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode-cn.com/problems/scramble-string/">https://leetcode-cn.com/problems/scramble-string/</a> </p>
]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-88.合并两个有序数组</title>
    <url>/2019/10/01/leetcode/1-100/88.he-bing-liang-ge-you-xu-shu-zu/</url>
    <content><![CDATA[<p>给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。</p>
<span id="more"></span>

<p>说明:</p>
<p>初始化 nums1 和 nums2 的元素数量分别为 m 和 n。<br>你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。<br>示例:</p>
<p>输入:<br>nums1 = [1,2,3,0,0,0], m = 3<br>nums2 = [2,5,6],       n = 3</p>
<p>输出: [1,2,2,3,5,6]</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/merge-sorted-array">https://leetcode-cn.com/problems/merge-sorted-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法1：双指针"><a href="#解法1：双指针" class="headerlink" title="解法1：双指针"></a>解法1：双指针</h4><p>思路：</p>
<p>从后向前比较，i从nums1的存有元素的最右端的向左移动,j从nums2的最右端向左移动，p从nums1可放元素位置的最右端向右移动，每次比较nums1[i]和nums2[j]的值放入nums1[p]中，且对应移动指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> m, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=m+n;</span><br><span class="line">        <span class="keyword">int</span> i=m<span class="number">-1</span>,j=n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> p=sum<span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(j&gt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                nums1[p]=nums2[j];</span><br><span class="line">                p--;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums1[i]&lt;=nums2[j])</span><br><span class="line">            &#123;</span><br><span class="line">                nums1[p]=nums2[j];</span><br><span class="line">                p--;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                nums1[p]=nums1[i];</span><br><span class="line">                p--;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-89.格雷编码</title>
    <url>/2019/10/01/leetcode/1-100/89.ge-lei-bian-ma/</url>
    <content><![CDATA[<p>题目链接：<a href="https://leetcode-cn.com/problems/gray-code/">https://leetcode-cn.com/problems/gray-code/</a> </p>
<span id="more"></span>

<h4 id="解法1：镜像反射"><a href="#解法1：镜像反射" class="headerlink" title="解法1：镜像反射"></a>解法1：镜像反射</h4><p>思路：分析题目</p>
<p>每次都根据$2^{n-1}$进行翻转，且在最高位补1.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">grayCode</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=<span class="built_in">pow</span>(<span class="number">2</span>,n);</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(len,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="built_in">pow</span>(<span class="number">2</span>,i<span class="number">-1</span>);j++)</span><br><span class="line">            &#123;</span><br><span class="line">                temp=res[j]+<span class="built_in">pow</span>(<span class="number">2</span>,i<span class="number">-1</span>);</span><br><span class="line">                res[<span class="built_in">pow</span>(<span class="number">2</span>,i)-j<span class="number">-1</span>]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-9. 回文数</title>
    <url>/2019/08/20/leetcode/1-100/9.hui-wen-shu/</url>
    <content><![CDATA[<h4 id="9-回文数"><a href="#9-回文数" class="headerlink" title="9. 回文数"></a><a href="https://leetcode-cn.com/problems/palindrome-number/">9. 回文数</a></h4><p>思路：负数必然不是回文数</p>
<p>反转一半的数字得到s，比较s和另一半x或x/10的相等关系</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x&lt;<span class="number">0</span>||x%<span class="number">10</span>==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> p;</span><br><span class="line">            <span class="keyword">while</span>(x&gt;s)</span><br><span class="line">            &#123;</span><br><span class="line">                p=x%<span class="number">10</span>;</span><br><span class="line">                s=s*<span class="number">10</span>+p;</span><br><span class="line">                x/=<span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x==s||x==s/<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-90.子集II</title>
    <url>/2019/10/01/leetcode/1-100/90.zi-ji-ii/</url>
    <content><![CDATA[<p>给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p>
<p>说明：解集不能包含重复的子集。</p>
<span id="more"></span>

<p>示例:</p>
<p>输入: [1,2,2]<br>输出:<br>[<br>  [2],<br>  [1],<br>  [1,2,2],<br>  [2,2],<br>  [1,2],<br>  []<br>]</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/subsets-ii">https://leetcode-cn.com/problems/subsets-ii</a></p>
<p>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法1：回溯-剪枝"><a href="#解法1：回溯-剪枝" class="headerlink" title="解法1：回溯+剪枝"></a>解法1：回溯+剪枝</h4><p>思路:78题的升级版，出现了重复子集，那么我们要先对数组排序，然后只需要在回溯过程中进行判断，若这一位与上一位相同就直接进行下一轮回溯</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">subsetsWithDup</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">ziji</span>(nums,n,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ziji</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> n,<span class="keyword">int</span> i,<span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        </span><br><span class="line">        res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        <span class="keyword">int</span> k;</span><br><span class="line">        <span class="keyword">for</span>(k=i;k&lt;n;k++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(k&gt;i&amp;&amp;nums[k]==nums[k<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            temp.<span class="built_in">push_back</span>(nums[k]);</span><br><span class="line">            <span class="built_in">ziji</span>(nums,n,k+<span class="number">1</span>,count+<span class="number">1</span>);</span><br><span class="line">            temp.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>回溯</tag>
        <tag>剪枝</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-91.解码方法</title>
    <url>/2019/10/01/leetcode/1-100/91.jie-ma-fang-fa/</url>
    <content><![CDATA[<p>题目链接：<a href="https://leetcode-cn.com/problems/decode-ways/">https://leetcode-cn.com/problems/decode-ways/</a> </p>
<span id="more"></span>

<h4 id="解法1：动态规划"><a href="#解法1：动态规划" class="headerlink" title="解法1：动态规划"></a>解法1：动态规划</h4><p>1.dp[i]表示从开始到i位置的解法方法总数</p>
<p>2.设a=s[i-1]+s[i-2]</p>
<p>（1）如果a是0直接返回0，因为若连续两位为0，必然无法进行解码</p>
<p>（2）如果s[i-1]是0，同时a&gt;26，直接返回0.因为这种情况只能s[i-2]和s[i-1]组成一个字母，但数字又大于26，所以无法解码。否则的话dp[i]=dp[i-2]</p>
<p>（3）如果a&gt;26或者a&lt;10则只能让dp[i]=dp[i-1]</p>
<p>（4）其他情况dp[i]=dp[i-1]+dp[i-2]</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> a,i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            a=(s[i<span class="number">-2</span>]-<span class="string">&#x27;0&#x27;</span>)*<span class="number">10</span>+(s[i<span class="number">-1</span>]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">if</span>(a==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((s[i<span class="number">-1</span>]-<span class="string">&#x27;0&#x27;</span>)==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(a&gt;<span class="number">26</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                dp[i]=dp[i<span class="number">-2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(a&gt;<span class="number">26</span>||a&lt;<span class="number">10</span>)</span><br><span class="line">                dp[i]=dp[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">else</span> dp[i]=dp[i<span class="number">-1</span>]+dp[i<span class="number">-2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-92.翻转链表II</title>
    <url>/2019/10/01/leetcode/1-100/92.fan-zhuan-lian-biao-ii/</url>
    <content><![CDATA[<p>题目链接:<a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">https://leetcode-cn.com/problems/reverse-linked-list-ii/</a> </p>
<span id="more"></span>

<h4 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h4><p>1.先找到翻转开始位置，将这位置的前一个结点记录，然后从这个位置到结束位置进行前插创建新链表，将新链表放入原链表中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode *phead=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        ListNode *p=head;</span><br><span class="line">        ListNode *pfirst=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        pfirst-&gt;next=head;</span><br><span class="line">        <span class="keyword">if</span>(m==<span class="number">1</span>&amp;&amp;n==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        n=n-m;</span><br><span class="line">        <span class="keyword">int</span> i=m;</span><br><span class="line">        <span class="keyword">while</span>(i--&gt;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pfirst=p;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(n--&gt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *temp=p;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">            temp-&gt;next=phead-&gt;next;</span><br><span class="line">            phead-&gt;next=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        phead=phead-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(m==<span class="number">1</span>)</span><br><span class="line">            head=phead;</span><br><span class="line">        <span class="keyword">else</span> pfirst-&gt;next=phead;</span><br><span class="line">        <span class="keyword">while</span>(phead-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">            phead=phead-&gt;next;</span><br><span class="line">        phead-&gt;next=p;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-93.复原IP地址</title>
    <url>/2019/10/03/leetcode/1-100/93.fu-yuan-ip-di-zhi/</url>
    <content><![CDATA[<p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。</p>
<p>示例:</p>
<p>输入: “25525511135”<br>输出: [“255.255.11.135”, “255.255.111.35”]</p>
<span id="more"></span>

<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/restore-ip-addresses">https://leetcode-cn.com/problems/restore-ip-addresses</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法1：回溯"><a href="#解法1：回溯" class="headerlink" title="解法1：回溯"></a>解法1：回溯</h4><p>思路：</p>
<p>1.首先我们要知道IP地址的每一部分为0-255，我们可以根据这个对回溯过程进行判断</p>
<p>2.当已经分好前三部分，对最后一部分进行判断</p>
<p>​    （1）若最后一部分长度大于3，必然不是正确的IP地址</p>
<p>​    （2）若长度==3，但字符串比255大，则不是正确IP地址</p>
<p>​    （3）若长度为0，不是正确的IP地址</p>
<p>​    （4）若长度不为1，且第一位为0，则不是正确的IP地址</p>
<p>3.循环遍历，且保证每部分长度不超过3，且长度为3时，进行判断是否符合IP规范</p>
<p>4.回溯回来时判断，这一位是否为0，若为0，则后面必然组不成IP地址，直接break 循环</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    string temp;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">restoreIpAddresses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">ip</span>(s,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ip</span><span class="params">(string s,<span class="keyword">int</span> No,<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(No==<span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            string temp2=s.<span class="built_in">substr</span>(i,s.<span class="built_in">length</span>());</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(temp2.<span class="built_in">length</span>()&gt;<span class="number">3</span>)</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            <span class="keyword">if</span>(temp2.<span class="built_in">length</span>()==<span class="number">3</span>&amp;&amp;temp2&gt;<span class="string">&quot;255&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            <span class="keyword">if</span>(temp2.<span class="built_in">length</span>()!=<span class="number">1</span>&amp;&amp;temp2[<span class="number">0</span>]==<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            <span class="keyword">if</span>(temp2==<span class="string">&quot;&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            temp+=temp2;</span><br><span class="line">            res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">            temp=temp.<span class="built_in">substr</span>(<span class="number">0</span>,temp.<span class="built_in">length</span>()-temp2.<span class="built_in">length</span>());</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> k;</span><br><span class="line">        <span class="keyword">for</span>(k=i;k&lt;i+<span class="number">3</span>&amp;&amp;k&lt;s.<span class="built_in">length</span>();k++)</span><br><span class="line">        &#123;</span><br><span class="line">            string temp1=s.<span class="built_in">substr</span>(i,k-i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(k-i+<span class="number">1</span>==<span class="number">3</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(temp1&gt;<span class="string">&quot;255&quot;</span>)</span><br><span class="line">                    <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            temp=temp+temp1+<span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            <span class="built_in">ip</span>(s,No+<span class="number">1</span>,i+k-i+<span class="number">1</span>);</span><br><span class="line">            temp=temp.<span class="built_in">substr</span>(<span class="number">0</span>,temp.<span class="built_in">length</span>()-temp1.<span class="built_in">length</span>()<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">if</span>(temp1==<span class="string">&quot;0&quot;</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-94.二叉树的中序遍历</title>
    <url>/2019/10/03/leetcode/1-100/94.er-cha-shu-de-zhong-xu-bian-li/</url>
    <content><![CDATA[<p>题目链接：<a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">https://leetcode-cn.com/problems/binary-tree-inorder-traversal/</a> </p>
<span id="more"></span>

<h4 id="解法1：递归"><a href="#解法1：递归" class="headerlink" title="解法1：递归"></a>解法1：递归</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">midfind</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">midfind</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">midfind</span>(root-&gt;left);</span><br><span class="line">            res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">            <span class="built_in">midfind</span>(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="解法2：迭代"><a href="#解法2：迭代" class="headerlink" title="解法2：迭代"></a>解法2：迭代</h4><p>用栈来暂存节点，先从根节点向左子树遍历放入栈中，然后输出栈顶元素，看右子树，循环操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode&gt; s;</span><br><span class="line">        TreeNode *t=root;</span><br><span class="line">        <span class="keyword">while</span>(t!=<span class="literal">NULL</span>||!s.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(t!=<span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                s.<span class="built_in">push</span>(*t);</span><br><span class="line">                t=t-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!s.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(s.<span class="built_in">top</span>().val);</span><br><span class="line">                t=s.<span class="built_in">top</span>().right;</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>递归</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-95.不同的二叉搜索树II</title>
    <url>/2019/10/03/leetcode/1-100/95.bu-tong-de-er-cha-sou-suo-shu-ii/</url>
    <content><![CDATA[<p>题目链接：<a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/">https://leetcode-cn.com/problems/unique-binary-search-trees-ii/</a> </p>
<span id="more"></span>

<h4 id="解法1：递归"><a href="#解法1：递归" class="headerlink" title="解法1：递归"></a>解法1：递归</h4><p>二叉搜索树的性质：左子树所有节点小于根节点，右子树所有节点大于根节点。</p>
<p>所有我们选择好根节点，将剩余节点分到左右子树，然后再分别对左右子树进行选择根节点，分好左右子树。直到如果只有一个数字，那么就只有这一种情况，把这一节点作为一棵树返回，如果没有数字，则直接返回null</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;TreeNode*&gt; res;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;TreeNode*&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getres</span>(<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;TreeNode*&gt; <span class="title">getres</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vector&lt;TreeNode*&gt; res;</span><br><span class="line">        <span class="comment">//此时没有数字，将 null 加入结果中</span></span><br><span class="line">        <span class="keyword">if</span>(start&gt;end)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(<span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//只有一个数字，当前数字作为一棵树加入结果中</span></span><br><span class="line">        <span class="keyword">if</span>(start==end)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode *tree=<span class="keyword">new</span> <span class="built_in">TreeNode</span>(start);</span><br><span class="line">            res.<span class="built_in">push_back</span>(tree);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="comment">//尝试每个数字作为根节点</span></span><br><span class="line">        <span class="keyword">for</span>(i=start;i&lt;=end;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//得到所有可能的左子树</span></span><br><span class="line">            vector&lt;TreeNode*&gt; leftTrees=<span class="built_in">getres</span>(start,i<span class="number">-1</span>);</span><br><span class="line">            <span class="comment">//得到所有可能的右子树</span></span><br><span class="line">            vector&lt;TreeNode*&gt; rightTrees=<span class="built_in">getres</span>(i+<span class="number">1</span>,end);</span><br><span class="line">            <span class="comment">//左子树右子树两两组合</span></span><br><span class="line">            <span class="keyword">for</span>(TreeNode *leftTree:leftTrees)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(TreeNode *rightTree:rightTrees)</span><br><span class="line">                &#123;</span><br><span class="line">                    TreeNode *root=<span class="keyword">new</span> <span class="built_in">TreeNode</span>(i);</span><br><span class="line">                    root-&gt;left=leftTree;</span><br><span class="line">                    root-&gt;right=rightTree;</span><br><span class="line">                    <span class="comment">//加入到最终结果中</span></span><br><span class="line">                    res.<span class="built_in">push_back</span>(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-96.不同的二叉搜索树</title>
    <url>/2019/10/04/leetcode/1-100/96.bu-tong-de-er-cha-sou-suo-shu/</url>
    <content><![CDATA[<p>给定一个整数 <em>n</em>，求以 1 … <em>n</em> 为节点组成的二叉搜索树有多少种？ </p>
<span id="more"></span>

<h4 id="解法1：动态规划"><a href="#解法1：动态规划" class="headerlink" title="解法1：动态规划"></a>解法1：动态规划</h4><p>G(n)表示长度为n的序列的不同二叉搜索树的个数</p>
<p>F(i,n)表示以i为根的不同二叉搜索树个数(1&lt;=i&lt;=n)</p>
<p>首先，根据95题的思路，不同的二叉搜索树的个数G(n),是对遍历所有i的F(i,n)之和。即:</p>
<p>G(n)=∑F(i,n)</p>
<p>特别的对于边界情况,G(0)=G(1)=1;</p>
<p>F(i,n)的是左右子树的笛卡尔积。</p>
<p>举例：F(3,7)是以3为根，总共7个节点的二叉搜索树。为了以3为根，左子树要以[1,2]序列建树，右子树要以[4,5,6,7]序列建树，然后让他们组合。巧妙之处[1,2]可以用G(2)表示，[4,5,6,7]可以用G(4)表示，因为G(n)和序列内容无关，只和序列的长度有关。于是F(3,7)=G(2)*G(4)。</p>
<p>也就是F(i,n)=G(i-1)*G(n-i)</p>
<p>结合上面的公式我们可以得到</p>
<p>G(n)=∑G(i-1)*G(n-i)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">g</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        g[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        g[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                g[i]+=g[i-j]*g[j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> g[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="解法2：数学演绎法"><a href="#解法2：数学演绎法" class="headerlink" title="解法2：数学演绎法"></a>解法2：数学演绎法</h4><p>事实上G(n)函数的值被称为卡塔兰数$C_n$,卡塔兰数更便于计算的定义如下：<br>$$<br>C_0=1,C_{n+1}=\frac{2(2n+1)}{n+2}C_n<br>$$<br>有了上述公式我们能将复杂度变为O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> c=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            c=c*(<span class="number">2</span>*(<span class="number">2</span>*i+<span class="number">1</span>))/(i+<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-97.交错字符串</title>
    <url>/2019/10/04/leetcode/1-100/97.jiao-cuo-zi-fu-chuan/</url>
    <content><![CDATA[<p>给定三个字符串 s1, s2, s3, 验证 s3 是否是由 s1 和 s2 交错组成的。</p>
<p>示例 1:</p>
<p>输入: s1 = “aabcc”, s2 = “dbbca”, s3 = “aadbbcbcac”<br>输出: true<br>示例 2:</p>
<p>输入: s1 = “aabcc”, s2 = “dbbca”, s3 = “aadbbbaccc”<br>输出: false</p>
<span id="more"></span>

<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/interleaving-string">https://leetcode-cn.com/problems/interleaving-string</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法1：动态规划"><a href="#解法1：动态规划" class="headerlink" title="解法1：动态规划"></a>解法1：动态规划</h4><p>1.dp[i][j]表示s1的前i个字符与s2的前j个字符能否组成s3的前i+j个字符串</p>
<p>2.初始化</p>
<p>​    对于第1列即s2为空dp[i][0]=dp[i-1][0]&amp;&amp;(s1[i-1]==s3[i-1]);</p>
<p>​    对于第1行即s1为空dp[0][i]=dp[0][i-1]&amp;&amp;(s2[i-1]==s3[i-1]);</p>
<p>3.状态转移方程</p>
<p>​    两种情况</p>
<p>​    （1）要么是s1[i-1]与s3[i-1+j]结合dp[i][j]=dp[i-1][j]&amp;&amp;(s1[i-1]==s3[i-1+j])</p>
<p>​    （2）要么是s2[j-1]与s3[i+j-1]结合dp[i][j]=dp[i][j-1]&amp;&amp;(s2[j-1]==s3[i+j-1])</p>
<p>4.返回dp[n][m]</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isInterleave</span><span class="params">(string s1, string s2, string s3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1.<span class="built_in">length</span>()+s2.<span class="built_in">length</span>()!=s3.<span class="built_in">length</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> n=s1.<span class="built_in">length</span>(),m=s2.<span class="built_in">length</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">dp</span>(n+<span class="number">1</span>,vector&lt;<span class="keyword">bool</span>&gt;(m+<span class="number">1</span>,<span class="literal">false</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            dp[i][<span class="number">0</span>]=dp[i<span class="number">-1</span>][<span class="number">0</span>]&amp;&amp;(s1[i<span class="number">-1</span>]==s3[i<span class="number">-1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            dp[<span class="number">0</span>][j]=dp[<span class="number">0</span>][j<span class="number">-1</span>]&amp;&amp;(s2[j<span class="number">-1</span>]==s3[j<span class="number">-1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j]=(dp[i<span class="number">-1</span>][j]&amp;&amp;(s1[i<span class="number">-1</span>]==s3[i<span class="number">-1</span>+j])||dp[i][j<span class="number">-1</span>]&amp;&amp;(s2[j<span class="number">-1</span>]==s3[i+j<span class="number">-1</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-98.验证二叉搜索树</title>
    <url>/2019/10/04/leetcode/1-100/98.yan-zheng-er-cha-sou-suo-shu/</url>
    <content><![CDATA[<p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p>
<p>假设一个二叉搜索树具有如下特征：</p>
<p>节点的左子树只包含小于当前节点的数。<br>节点的右子树只包含大于当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。</p>
<span id="more"></span>

<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/validate-binary-search-tree">https://leetcode-cn.com/problems/validate-binary-search-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法1：递归"><a href="#解法1：递归" class="headerlink" title="解法1：递归"></a>解法1：递归</h4><p>二叉搜索树的性质：二叉搜索树的中序遍历必然是一个递增数组</p>
<p>由以上性质我们直接中序遍历二叉搜索树，然后判断是不是递增数组就可知道是否符合要求</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">midDFS</span>(root);</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;res.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(res[i<span class="number">-1</span>]&gt;=res[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">midDFS</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">midDFS</span>(root-&gt;left);</span><br><span class="line">            res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">            <span class="built_in">midDFS</span>(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-99. 恢复二叉搜索树</title>
    <url>/2019/10/04/leetcode/1-100/99.hui-fu-er-cha-sou-suo-shu/</url>
    <content><![CDATA[<p>二叉搜索树中的两个节点被错误地交换。</p>
<p>请在不改变其结构的情况下，恢复这棵树。</p>
<p><strong>进阶:</strong></p>
<ul>
<li>使用 O(<em>n</em>) 空间复杂度的解法很容易实现。</li>
<li>你能想出一个只使用常数空间的解决方案吗？</li>
</ul>
<p>题目链接：<a href="https://leetcode-cn.com/problems/recover-binary-search-tree/">https://leetcode-cn.com/problems/recover-binary-search-tree/</a> </p>
<span id="more"></span>

<h4 id="解法1：递归"><a href="#解法1：递归" class="headerlink" title="解法1：递归"></a>解法1：递归</h4><p>与98题同样的思路</p>
<p>对二叉搜索树采用中序遍历，找到两个不符合规范的节点，然后交换他们的数值</p>
<p>进阶：</p>
<p>要求用常数的空间，我们用pre指针来存父节点，比较pre和当前指针的大小我们就能找到这两个错误的节点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    </span><br><span class="line">    TreeNode *left=<span class="keyword">new</span> <span class="built_in">TreeNode</span>(INT_MIN);</span><br><span class="line">    TreeNode *right=<span class="keyword">new</span> <span class="built_in">TreeNode</span>(INT_MIN);</span><br><span class="line">    TreeNode *pre=<span class="keyword">new</span> <span class="built_in">TreeNode</span>(INT_MIN);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">midbfs</span>(root);</span><br><span class="line">        <span class="built_in">swap</span>(left-&gt;val,right-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">midbfs</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">midbfs</span>(root-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(left-&gt;val==INT_MIN&amp;&amp;pre-&gt;val&gt;root-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                left=pre;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pre-&gt;val&gt;root-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                right=root;</span><br><span class="line">            &#125;</span><br><span class="line">            pre=root;</span><br><span class="line">            <span class="built_in">midbfs</span>(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>1-100</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>递归</tag>
      </tags>
  </entry>
</search>
